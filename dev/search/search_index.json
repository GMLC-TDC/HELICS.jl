{
    "docs": [
        {
            "location": "/", 
            "text": "HELICS.jl\n\n\n \n \n \n \n\n\nHELICS.jl\n is a cross-platform Julia wrapper around the \nHELICS\n library.\n\n\nThis package is now available for Windows, Mac, and Linux.\n\n\n\n\nDocumentation\n\n\nThe documentation for the development latest of this package is \nhere\n.\n\n\n\n\nInstallation\n\n\nUse the Julia package manager to install HELICS.jl\n\n\njulia\n \n]\n\n\n(\nv1\n.\n1\n)\n \nadd\n \nHELICS\n\n\n\n\n\n\nOpen the package manager REPL (using \n]\n)\n\n\nTo install the latest development version, use the following from within Julia:\n\n\n(\nv1\n.\n1\n)\n \npkg\n \nadd\n \nHELICS\n#master\n\n\n\n\n\n\nThis package includes HELICS as a library. You do not have to install HELICS separately.\n\n\nNote that this should work on 32 and 64-bit Windows systems and 64-bit Linux and Mac systems.\n\n\nIf you wish to develop \nHELICS.jl\n you may want to use the following:\n\n\n(\nv1\n.\n1\n)\n \npkg\n \ndev\n \nHELICS\n\n\n\n\n\n\nYou can also get a specific version,\n\n\n(\nv1\n.\n1\n)\n \npkg\n \nadd\n \nHELICS\n#33c98625\n\n\n\n\n\n\nor specific branch,\n\n\n(\nv1\n.\n1\n)\n \npkg\n \nadd\n \nHELICS\n#kd/some-new-feature\n\n\n\n\n\n\nif these features haven't been merged to \nmaster\n yet.\n\n\n\n\nTroubleshooting\n\n\nThis package interfaces with HELICS, so a good understanding of HELICS will help troubleshooting. There are plenty of useful resources located \nhere\n.\n\n\nIf you are having issues using this Julia interface, feel free to open an issue on GitHub \nhere\n.\n\n\n\n\nAcknowledgements\n\n\nThis work was developed as an extension to work done as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (\nNREL\n).", 
            "title": "Home"
        }, 
        {
            "location": "/#helicsjl", 
            "text": "HELICS.jl  is a cross-platform Julia wrapper around the  HELICS  library.  This package is now available for Windows, Mac, and Linux.", 
            "title": "HELICS.jl"
        }, 
        {
            "location": "/#documentation", 
            "text": "The documentation for the development latest of this package is  here .", 
            "title": "Documentation"
        }, 
        {
            "location": "/#installation", 
            "text": "Use the Julia package manager to install HELICS.jl  julia   ]  ( v1 . 1 )   add   HELICS   Open the package manager REPL (using  ] )  To install the latest development version, use the following from within Julia:  ( v1 . 1 )   pkg   add   HELICS #master   This package includes HELICS as a library. You do not have to install HELICS separately.  Note that this should work on 32 and 64-bit Windows systems and 64-bit Linux and Mac systems.  If you wish to develop  HELICS.jl  you may want to use the following:  ( v1 . 1 )   pkg   dev   HELICS   You can also get a specific version,  ( v1 . 1 )   pkg   add   HELICS #33c98625   or specific branch,  ( v1 . 1 )   pkg   add   HELICS #kd/some-new-feature   if these features haven't been merged to  master  yet.", 
            "title": "Installation"
        }, 
        {
            "location": "/#troubleshooting", 
            "text": "This package interfaces with HELICS, so a good understanding of HELICS will help troubleshooting. There are plenty of useful resources located  here .  If you are having issues using this Julia interface, feel free to open an issue on GitHub  here .", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "This work was developed as an extension to work done as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory ( NREL ).", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/terminology/", 
            "text": "Terminology\n\n\nIllustration of a simple federation consisting of two federates.\n\n\n    +--------------------+               +--------------------+\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n    Federate - \n1\n    \n|\n               \n|\n    Federate - \n2\n    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n       +-----------------+     +-----------------+       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       \n|\n helicsSharedLib \n|\n     \n|\n helicsSharedLib \n|\n       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       +---------------x-+     +-x---------------+       \n|\n\n    \n|\n                    \n|\n  ^         ^  \n|\n                    \n|\n\n    +--------------------+  \n|\n         \n|\n  +--------------------+\n                            \n|\n         \n|\n\n                            v         v\n                         +--x---------x--+\n                         \n|\n               \n|\n\n                         \n|\n               \n|\n\n                         \n|\n helics-broker \n|\n\n                         \n|\n               \n|\n\n                         \n|\n               \n|\n\n                         +---------------+\n\n\n\n\n\nA federation, also called a co-simulation consists of multiple federates, or components, agents or actors. These federates exchange data at given points in time. HELICS manages time in a distributed fashion based on how the federation is configured during initialization. If you have a Julia program, and you wish to exchange data with another HELICS federate, you can create a \nFederate\n by calling the \nHELICS.helicsCreateCombinationFederate\n function. This federate must be provided with some information in order to set it up correctly. A \nFederateInfo\n object must be first created in order to set up a \nFederate\n. This \nFederateInfo\n object contains information about what type of communication core is used in HELICS (e.g. \nzmq\n, \nmpi\n, \ntcp\n, \nudp\n), the name of the \nFederate\n, where the \nBroker\n is located, etc. All \nFederate\ns must connect to a \nBroker\n. A \nBroker\n is a separate process that can run on the same machine or a remote machine. You can start a \nBroker\n by running \nHELICS.helicsCreateBroker\n, or running \nhelics_broker -f ${NUMBER_OF_FEDERATES}\n from the command line. Both creating a \nFederateInfo\n and \nBroker\n object can take some initialization options in the form of a \ninitstring\n. See the \nexamples\n folder for more information.\n\n\nAfter creating a \nFederate\n, you will want to create \nPublication\ns and \nSubscription\ns. The strings you choose for these publications and subscriptions must be unique, and they act like topics in a federation. You can send data in the form of values from a \nPublication\n to a \nSubscription\n. Additionally, you can register \nEndpoint\ns as well, which allow you to send \nMessage\ns. \nMessage\ns can be filtered on by any \nFederate\n and can be used to model complex communication interactions.\n\n\nYou can use functions like \nHELICS.helicsPublicationPublishDouble\n to send values at the \"current time\", and use functions like \nHELICS.helicsSubscriptionGetKey\n or \nHELICS.helicsInputGetDouble\n to receive values at the \"current time\". You can use functions like \nHELICS.helicsEndpointSendMessage\n to send messages at the \"current time\", and use functions like \nHELICS.helicsEndpointGetMessage\n functions to receive messages that arrived before the \"current time\".\n\n\nYou can request to move to a time by using the \nHELICS.helicsFederateRequestTime\n function. This function returns a time back that you can safely move to. The time granted will always be less than or equal to the requested time. If you wish to move to the requested time, you may use a while loop until that the granted time is equal to the requested time.\n\n\nfor\n \nt\n \nin\n \n1\n:\n100\n\n\n    \nrequested_time\n \n=\n \nt\n\n\n    \nwhile\n \ngranted_time\n \n \nrequested_time\n\n\n        \ngranted_time\n \n=\n \nhelicsFederateRequestTime\n(\nrequested_time\n)\n\n\n    \nend\n\n\n\n    \n# granted_time here will be equal to requested time\n\n    \n# Send or Receive data here\n\n\n\nend\n\n\n\n\n\n\nHELICS.helicsFederateRequestTime\n is a blocking call. There are other asynchronous request time functions available that allow you to do work while you wait for others to move forward in simulation time.\n\n\nhelicsSharedLib\n is a shared library that is included in the Julia package. This C/C++ shared library interfaces with the broker in other to communicate with other federates.", 
            "title": "Terminology"
        }, 
        {
            "location": "/terminology/#terminology", 
            "text": "Illustration of a simple federation consisting of two federates.      +--------------------+               +--------------------+\n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |     Federate -  1      |                 |     Federate -  2      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |        +-----------------+     +-----------------+        | \n     |         |                   |       |                   |         | \n     |         |                   |       |                   |         | \n     |         |  helicsSharedLib  |       |  helicsSharedLib  |         | \n     |         |                   |       |                   |         | \n     |         |                   |       |                   |         | \n     |        +---------------x-+     +-x---------------+        | \n     |                      |   ^         ^   |                      | \n    +--------------------+   |           |   +--------------------+\n                             |           | \n                            v         v\n                         +--x---------x--+\n                          |                 | \n                          |                 | \n                          |  helics-broker  | \n                          |                 | \n                          |                 | \n                         +---------------+  A federation, also called a co-simulation consists of multiple federates, or components, agents or actors. These federates exchange data at given points in time. HELICS manages time in a distributed fashion based on how the federation is configured during initialization. If you have a Julia program, and you wish to exchange data with another HELICS federate, you can create a  Federate  by calling the  HELICS.helicsCreateCombinationFederate  function. This federate must be provided with some information in order to set it up correctly. A  FederateInfo  object must be first created in order to set up a  Federate . This  FederateInfo  object contains information about what type of communication core is used in HELICS (e.g.  zmq ,  mpi ,  tcp ,  udp ), the name of the  Federate , where the  Broker  is located, etc. All  Federate s must connect to a  Broker . A  Broker  is a separate process that can run on the same machine or a remote machine. You can start a  Broker  by running  HELICS.helicsCreateBroker , or running  helics_broker -f ${NUMBER_OF_FEDERATES}  from the command line. Both creating a  FederateInfo  and  Broker  object can take some initialization options in the form of a  initstring . See the  examples  folder for more information.  After creating a  Federate , you will want to create  Publication s and  Subscription s. The strings you choose for these publications and subscriptions must be unique, and they act like topics in a federation. You can send data in the form of values from a  Publication  to a  Subscription . Additionally, you can register  Endpoint s as well, which allow you to send  Message s.  Message s can be filtered on by any  Federate  and can be used to model complex communication interactions.  You can use functions like  HELICS.helicsPublicationPublishDouble  to send values at the \"current time\", and use functions like  HELICS.helicsSubscriptionGetKey  or  HELICS.helicsInputGetDouble  to receive values at the \"current time\". You can use functions like  HELICS.helicsEndpointSendMessage  to send messages at the \"current time\", and use functions like  HELICS.helicsEndpointGetMessage  functions to receive messages that arrived before the \"current time\".  You can request to move to a time by using the  HELICS.helicsFederateRequestTime  function. This function returns a time back that you can safely move to. The time granted will always be less than or equal to the requested time. If you wish to move to the requested time, you may use a while loop until that the granted time is equal to the requested time.  for   t   in   1 : 100 \n\n     requested_time   =   t       while   granted_time     requested_time           granted_time   =   helicsFederateRequestTime ( requested_time )       end  \n     # granted_time here will be equal to requested time \n     # Send or Receive data here  end   HELICS.helicsFederateRequestTime  is a blocking call. There are other asynchronous request time functions available that allow you to do work while you wait for others to move forward in simulation time.  helicsSharedLib  is a shared library that is included in the Julia package. This C/C++ shared library interfaces with the broker in other to communicate with other federates.", 
            "title": "Terminology"
        }, 
        {
            "location": "/api/", 
            "text": "API\n\n\n#\n\n\nHELICS.Broker\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Broker\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.CWrapper\n \n \nType\n.\n\n\nSummary\n\n\nabstract type HELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.CombinationFederate\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.CombinationFederate\n \n: \nHELICS.Federate\n\n\nsource\n\n\n#\n\n\nHELICS.Core\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Core\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Endpoint\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Endpoint\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Federate\n \n \nType\n.\n\n\nSummary\n\n\nabstract type HELICS.Federate \n: HELICS.CWrapper\n\n\nSubtypes\n\n\n\n\nHELICS.CombinationFederate\n\n\nHELICS.MessageFederate\n\n\nHELICS.ValueFederate\n\n\n\n\nSupertype Hierarchy\n\n\nHELICS.Federate \n: HELICS.CWrapper \n: Any\n\n\nsource\n\n\n#\n\n\nHELICS.FederateInfo\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.FederateInfo\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Filter\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Filter\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_CORE_TYPE\n \n \nType\n.\n\n\n\n\nHELICS_CORE_TYPE_DEFAULT\n: 0\n\n\nHELICS_CORE_TYPE_ZMQ\n: 1\n\n\nHELICS_CORE_TYPE_MPI\n: 2\n\n\nHELICS_CORE_TYPE_TEST\n: 3\n\n\nHELICS_CORE_TYPE_INTERPROCESS\n: 4\n\n\nHELICS_CORE_TYPE_IPC\n: 5\n\n\nHELICS_CORE_TYPE_TCP\n: 6\n\n\nHELICS_CORE_TYPE_UDP\n: 7\n\n\nHELICS_CORE_TYPE_ZMQ_TEST\n: 10\n\n\nHELICS_CORE_TYPE_NNG\n: 9\n\n\nHELICS_CORE_TYPE_TCP_SS\n: 11\n\n\nHELICS_CORE_TYPE_HTTP\n: 12\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_DATA_TYPE\n \n \nType\n.\n\n\n\n\nHELICS_DATA_TYPE_STRING\n: 0\n\n\nHELICS_DATA_TYPE_DOUBLE\n: 1\n\n\nHELICS_DATA_TYPE_INT\n: 2\n\n\nHELICS_DATA_TYPE_COMPLEX\n: 3\n\n\nHELICS_DATA_TYPE_VECTOR\n: 4\n\n\nHELICS_DATA_TYPE_COMPLEX_VECTOR\n: 5\n\n\nHELICS_DATA_TYPE_NAMED_POINT\n: 6\n\n\nHELICS_DATA_TYPE_BOOLEAN\n: 7\n\n\nHELICS_DATA_TYPE_TIME\n: 8\n\n\nHELICS_DATA_TYPE_RAW\n: 25\n\n\nHELICS_DATA_TYPE_ANY\n: 25262\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_ERROR_TYPES\n \n \nType\n.\n\n\n\n\nHELICS_OK\n: 0\n\n\nHELICS_ERROR_REGISTRATION_FAILURE\n: -1\n\n\nHELICS_ERROR_CONNECTION_FAILURE\n: -2\n\n\nHELICS_ERROR_INVALID_OBJECT\n: -3\n\n\nHELICS_ERROR_INVALID_ARGUMENT\n: -4\n\n\nHELICS_ERROR_DISCARD\n: -5\n\n\nHELICS_ERROR_SYSTEM_FAILURE\n: -6\n\n\nHELICS_WARNING\n: -8\n\n\nHELICS_ERROR_INVALID_STATE_TRANSITION\n: -9\n\n\nHELICS_ERROR_INVALID_FUNCTION_CALL\n: -10\n\n\nHELICS_ERROR_EXECUTION_FAILURE\n: -14\n\n\nHELICS_ERROR_OTHER\n: -101\n\n\nOTHER_ERROR_TYPE\n: -203\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_FEDERATE_FLAGS\n \n \nType\n.\n\n\n\n\nHELICS_FLAG_OBSERVER\n: 0\n\n\nHELICS_FLAG_UNINTERRUPTIBLE\n: 1\n\n\nHELICS_FLAG_INTERRUPTIBLE\n: 2\n\n\nHELICS_FLAG_SOURCE_ONLY\n: 4\n\n\nHELICS_FLAG_ONLY_TRANSMIT_ON_CHANGE\n: 6\n\n\nHELICS_FLAG_ONLY_UPDATE_ON_CHANGE\n: 8\n\n\nHELICS_FLAG_WAIT_FOR_CURRENT_TIME_UPDATE\n: 10\n\n\nHELICS_FLAG_ROLLBACK\n: 12\n\n\nHELICS_FLAG_FORWARD_COMPUTE\n: 14\n\n\nHELICS_FLAG_REALTIME\n: 16\n\n\nHELICS_FLAG_SINGLE_THREAD_FEDERATE\n: 27\n\n\nHELICS_FLAG_DELAY_INIT_ENTRY\n: 45\n\n\nHELICS_FLAG_ENABLE_INIT_ENTRY\n: 47\n\n\nHELICS_FLAG_IGNORE_TIME_MISMATCH_WARNINGS\n: 67\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_FEDERATE_STATE\n \n \nType\n.\n\n\n\n\nHELICS_STATE_STARTUP\n: 0\n\n\nHELICS_STATE_INITIALIZATION\n: 1\n\n\nHELICS_STATE_EXECUTION\n: 2\n\n\nHELICS_STATE_FINALIZE\n: 3\n\n\nHELICS_STATE_ERROR\n: 4\n\n\nHELICS_STATE_PENDING_INIT\n: 5\n\n\nHELICS_STATE_PENDING_EXEC\n: 6\n\n\nHELICS_STATE_PENDING_TIME\n: 7\n\n\nHELICS_STATE_PENDING_ITERATIVE_TIME\n: 8\n\n\nHELICS_STATE_PENDING_FINALIZE\n: 9\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_FILTER_TYPE\n \n \nType\n.\n\n\n\n\nHELICS_FILTER_TYPE_CUSTOM\n: 0\n\n\nHELICS_FILTER_TYPE_DELAY\n: 1\n\n\nHELICS_FILTER_TYPE_RANDOM_DELAY\n: 2\n\n\nHELICS_FILTER_TYPE_RANDOM_DROP\n: 3\n\n\nHELICS_FILTER_TYPE_REROUTE\n: 4\n\n\nHELICS_FILTER_TYPE_CLONE\n: 5\n\n\nHELICS_FILTER_TYPE_FIREWALL\n: 6\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_HANDLE_OPTIONS\n \n \nType\n.\n\n\n\n\nHELICS_HANDLE_OPTION_CONNECTION_REQUIRED\n: 397\n\n\nHELICS_HANDLE_OPTION_CONNECTION_OPTIONAL\n: 402\n\n\nHELICS_HANDLE_OPTION_SINGLE_CONNECTION_ONLY\n: 407\n\n\nHELICS_HANDLE_OPTION_MULTIPLE_CONNECTIONS_ALLOWED\n: 409\n\n\nHELICS_HANDLE_OPTION_BUFFER_DATA\n: 411\n\n\nHELICS_HANDLE_OPTION_STRICT_TYPE_CHECKING\n: 414\n\n\nHELICS_HANDLE_OPTION_ONLY_TRANSMIT_ON_CHANGE\n: 6\n\n\nHELICS_HANDLE_OPTION_ONLY_UPDATE_ON_CHANGE\n: 8\n\n\nHELICS_HANDLE_OPTION_IGNORE_INTERRUPTS\n: 475\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_ITERATION_REQUEST\n \n \nType\n.\n\n\n\n\nHELICS_ITERATION_REQUEST_NO_ITERATION\n: 0\n\n\nHELICS_ITERATION_REQUEST_FORCE_ITERATION\n: 1\n\n\nHELICS_ITERATION_REQUEST_ITERATE_IF_NEEDED\n: 2\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_ITERATION_RESULT\n \n \nType\n.\n\n\n\n\nHELICS_ITERATION_RESULT_NEXT_STEP\n: 0\n\n\nHELICS_ITERATION_RESULT_ERROR\n: 1\n\n\nHELICS_ITERATION_RESULT_HALTED\n: 2\n\n\nHELICS_ITERATION_RESULT_ITERATING\n: 3\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_LOG_LEVELS\n \n \nType\n.\n\n\n\n\nHELICS_LOG_LEVEL_NO_PRINT\n: -1\n\n\nHELICS_LOG_LEVEL_ERROR\n: 0\n\n\nHELICS_LOG_LEVEL_WARNING\n: 1\n\n\nHELICS_LOG_LEVEL_SUMMARY\n: 2\n\n\nHELICS_LOG_LEVEL_CONNECTIONS\n: 3\n\n\nHELICS_LOG_LEVEL_INTERFACES\n: 4\n\n\nHELICS_LOG_LEVEL_TIMING\n: 5\n\n\nHELICS_LOG_LEVEL_DATA\n: 6\n\n\nHELICS_LOG_LEVEL_TRACE\n: 7\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_PROPERTIES\n \n \nType\n.\n\n\n\n\nHELICS_PROPERTY_TIME_DELTA\n: 137\n\n\nHELICS_PROPERTY_TIME_PERIOD\n: 140\n\n\nHELICS_PROPERTY_TIME_OFFSET\n: 141\n\n\nHELICS_PROPERTY_TIME_RT_LAG\n: 143\n\n\nHELICS_PROPERTY_TIME_RT_LEAD\n: 144\n\n\nHELICS_PROPERTY_TIME_RT_TOLERANCE\n: 145\n\n\nHELICS_PROPERTY_TIME_INPUT_DELAY\n: 148\n\n\nHELICS_PROPERTY_TIME_OUTPUT_DELAY\n: 150\n\n\nHELICS_PROPERTY_INT_MAX_ITERATIONS\n: 259\n\n\nHELICS_PROPERTY_INT_LOG_LEVEL\n: 271\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.Message\n \n \nType\n.\n\n\nSummary\n\n\nstruct HELICS.Message\n\n\nFields\n\n\ntime\n::\nFloat64\n\n\ndata\n::\nString\n\n\nlength\n::\nInt64\n\n\nmessageID\n::\nInt32\n\n\nflags\n::\nInt16\n\n\noriginal_source\n::\nString\n\n\nsource\n::\nString\n\n\ndest\n::\nString\n\n\noriginal_dest\n::\nString\n\n\n\n\n\n\nSupertype Hierarchy\n\n\nHELICS.Message \n: Any\n\n\nsource\n\n\n#\n\n\nHELICS.MessageFederate\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.MessageFederate\n \n: \nHELICS.Federate\n\n\nsource\n\n\n#\n\n\nHELICS.Publication\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Publication\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Query\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Query\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Subscription\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Subscription\n \n: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.ValueFederate\n \n \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.ValueFederate\n \n: \nHELICS.Federate\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerAddDestinationFilterToEndpoint\n \n \nMethod\n.\n\n\nhelicsBrokerAddDestinationFilterToEndpoint\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerAddSourceFilterToEndpoint\n \n \nMethod\n.\n\n\nhelicsBrokerAddSourceFilterToEndpoint\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerClone\n \n \nMethod\n.\n\n\nhelicsBrokerClone\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n-\n \nHELICS\n.\nBroker\n\n\n\n\n\n\nCreate a new reference to an existing broker\n\n\nthis will create a new broker object that references the existing broker it must be freed as well\n\n\nArguments\n\n\n\n\nbroker\n: an existing \nBroker\n\n\n\n\nReturns\n\n\n\n\na new reference to the same broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerDataLink\n \n \nMethod\n.\n\n\nhelicsBrokerDataLink\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nsource\n::\nString\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nLink a named publication and named input using a broker\n\n\nArguments\n\n\n\n\nbroker\n: the \nBroker\n to generate the connection from\n\n\nsource\n: the name of the publication (cannot be NULL)\n\n\ntarget\n: the name of the target to send the publication data (cannot be NULL)\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerDestroy\n \n \nMethod\n.\n\n\nhelicsBrokerDestroy\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nDisconnect and free a broker\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerDisconnect\n \n \nMethod\n.\n\n\nhelicsBrokerDisconnect\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nDisconnect a broker\n\n\nArguments\n\n\n\n\nbroker\n: the broker to disconnect\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerFree\n \n \nMethod\n.\n\n\nhelicsBrokerFree\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nRelease the memory associated with a broker\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerGetAddress\n \n \nMethod\n.\n\n\nhelicsBrokerGetAddress\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n-\n \nString\n\n\n\n\n\n\nGet the network address associated with a broker\n\n\nArguments\n\n\n\n\nbroker\n: the broker to query\n\n\n\n\nReturns\n\n\n\n\na string with the network address of the broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerGetIdentifier\n \n \nMethod\n.\n\n\nhelicsBrokerGetIdentifier\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n-\n \nString\n\n\n\n\n\n\nGet an identifier for the broker\n\n\nArguments\n\n\n\n\nbroker\n: the broker to query\n\n\n\n\nReturns\n\n\n\n\na string containing the identifier for the broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerIsConnected\n \n \nMethod\n.\n\n\nhelicsBrokerIsConnected\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if a broker is connected. A connected broker implies is attached to cores or cores could reach out to communicate. return 0 if not connected , something else if it is connected.\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerIsValid\n \n \nMethod\n.\n\n\nhelicsBrokerIsValid\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if a broker object is a valid object\n\n\nArguments\n\n\n\n\nbroker\n: the \nBroker\n object to test\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerSetGlobal\n \n \nMethod\n.\n\n\nhelicsBrokerSetGlobal\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nvalueName\n::\nString\n,\n \nvalue\n::\nString\n)\n\n\n\n\n\n\nSet a federation global value\n\n\nthis overwrites any previous value for this name\n\n\nArguments\n\n\n\n\nbroker\n: the broker to set the global through\n\n\nvalueName\n: the name of the global to set\n\n\nvalue\n: the value of the global\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerWaitForDisconnect\n \n \nMethod\n.\n\n\nhelicsBrokerWaitForDisconnect\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nmsToWait\n::\nInt64\n)\n \n-\n \nBool\n\n\n\n\n\n\nWait for the broker to disconnect\n\n\nArguments\n\n\n\n\nbroker\n: the broker to wait for\n\n\nmsToWait\n: the time out in millisecond (\n0 for infinite timeout)\n\n\n\n\nReturns\n\n\n\n\ntrue\n if the disconnect was successful, \nfalse\n if there was a timeout\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCleanupLibrary\n \n \nMethod\n.\n\n\nhelicsCleanupLibrary\n()\n\n\n\n\n\n\nFunction to do some housekeeping work\n\n\nthis runs some cleanup routines and tries to close out any residual thread that haven't been shutdown yet.\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCloseLibrary\n \n \nMethod\n.\n\n\nhelicsCloseLibrary\n()\n\n\n\n\n\n\nCall when done using the helics library,  this function will ensure the threads are closed properly if possible     this should be the last call before exiting,\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreAddDestinationFilterToEndpoint\n \n \nMethod\n.\n\n\nhelicsCoreAddDestinationFilterToEndpoint\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreAddSourceFilterToEndpoint\n \n \nMethod\n.\n\n\nhelicsCoreAddSourceFilterToEndpoint\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nLink a named filter to a source endpoint\n\n\nArguments\n\n\n\n\ncore\n: the core to generate the connection from\n\n\nfilter\n: the name of the filter (cannot be NULL)\n\n\nendpoint\n: the name of the endpoint to filter the data from (cannot be NULL)\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreClone\n \n \nMethod\n.\n\n\nhelicsCoreClone\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n-\n \nHELICS\n.\nCore\n\n\n\n\n\n\nCreate a new reference to an existing core\n\n\nthis will create a new broker object that references the existing broker it must be freed as well\n\n\nArguments\n\n\n\n\ncore\n: an existing \nCore\n\n\n\n\nReturns\n\n\n\n\na new reference to the same \nCore\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreDataLink\n \n \nMethod\n.\n\n\nhelicsCoreDataLink\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nsource\n::\nString\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nLink a named publication and named input using a core\n\n\nArguments\n\n\n\n\ncore\n: the core to generate the connection from\n\n\nsource\n: the name of the publication (cannot be NULL)\n\n\ntarget\n: the named of the target to send the publication data (cannot be NULL)\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreDestroy\n \n \nMethod\n.\n\n\nhelicsCoreDestroy\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nDisconnect and free a core\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreDisconnect\n \n \nMethod\n.\n\n\nhelicsCoreDisconnect\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nGet an identifier for the core\n\n\nArguments\n\n\n\n\ncore\n: the core to query\n\n\n\n\nReturns\n\n\n\n\na void enumeration indicating any error condition\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreFree\n \n \nMethod\n.\n\n\nhelicsCoreFree\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nRelease the memory associated with a core\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreGetIdentifier\n \n \nMethod\n.\n\n\nhelicsCoreGetIdentifier\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n-\n \nString\n\n\n\n\n\n\nGet an identifier for the core\n\n\nArguments\n\n\n\n\ncore\n: the core to query\n\n\n\n\nReturns\n\n\n\n\na string with the identifier of the core\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreIsConnected\n \n \nMethod\n.\n\n\nhelicsCoreIsConnected\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if a core is connected. A connected core implies is attached to federate or federates could be attached to it.\n\n\nReturns\n\n\n\n\nfalse\n if not connected, \ntrue\n if it is connected\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreIsValid\n \n \nMethod\n.\n\n\nhelicsCoreIsValid\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if a core object is a valid object\n\n\nArguments\n\n\n\n\ncore\n: the \nCore\n object to test\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreRegisterCloningFilter\n \n \nMethod\n.\n\n\nhelicsCoreRegisterCloningFilter\n(\ncore\n::\nHELICS\n.\nCore\n,\n \ndeliveryEndpoint\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreRegisterFilter\n \n \nMethod\n.\n\n\nhelicsCoreRegisterFilter\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_filter_type\n},\n \nname\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreSetGlobal\n \n \nMethod\n.\n\n\nhelicsCoreSetGlobal\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nvalueName\n::\nString\n,\n \nvalue\n::\nString\n)\n\n\n\n\n\n\nSet a global value in a core\n\n\nthis overwrites any previous value for this name\n\n\nArguments\n\n\n\n\ncore\n: the core to set the global through\n\n\nvalueName\n: the name of the global to set\n\n\nvalue\n: the value of the global\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreSetReadyToInit\n \n \nMethod\n.\n\n\nhelicsCoreSetReadyToInit\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nSet the core to ready for init\n\n\nthis function is used for cores that have filters but no federates so there needs to be a direct signal to the core to trigger the federation initialization\n\n\nArguments\n\n\n\n\ncore\n: the core object to enable init values for\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateBroker\n \n \nMethod\n.\n\n\nhelicsCreateBroker\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \ninitString\n::\nString\n)\n \n-\n \nHELICS\n.\nBroker\n\n\n\n\n\n\nCreate a broker object\n\n\nArguments\n\n\n\n\ntype\n: the type of the broker to create\n\n\nname\n: the name of the broker , may be a nullptr or empty string to have a name automatically assigned\n\n\ninitString\n: an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" if this is a subbroker or the number of federates or the address\n\n\n\n\nReturns\n\n\n\n\na \nBroker\n object, will be NULL if there was an error indicated in the err object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateBrokerFromArgs\n \n \nMethod\n.\n\n\nhelicsCreateBrokerFromArgs\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \nargc\n::\nInt64\n,\n \nargv\n::\nArray\n{\nString\n,\n1\n})\n \n-\n \nHELICS\n.\nBroker\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCombinationFederate\n \n \nMethod\n.\n\n\nhelicsCreateCombinationFederate\n(\nfedName\n::\nString\n,\n \nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n-\n \nHELICS\n.\nCombinationFederate\n\n\n\n\n\n\nCreate a \nCombinationFederate\n from a \nFederateInfo\n object\n\n\nCombinationFederate\n are both \nValueFederate\n and \nMessageFederate\n, objects can be used in all functions that take a \nFederate\n, \nMessageFederate\n or \nValueFederate\n object as an argument\n\n\nArguments\n\n\n\n\nfedName\n: a string with the name of the federate, can be NULL or an empty string to pull the default name from fi\n\n\nfi\n: the \nFederateInfo\n object that contains details on the federate\n\n\n\n\nReturns\n\n\n\n\nan opaque \nValueFederate\n, nullptr if the object creation failed\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCombinationFederateFromConfig\n \n \nMethod\n.\n\n\nhelicsCreateCombinationFederateFromConfig\n(\nconfigFile\n::\nString\n)\n \n-\n \nHELICS\n.\nCombinationFederate\n\n\n\n\n\n\nCreate a \nCombinationFederate\n from a JSON file or JSON string\n\n\nCombinationFederate\n are both \nValueFederate\n and \nMessageFederate\n, objects can be used in all functions that take a \nFederate\n, \nMessageFederate\n or \nValueFederate\n object as an argument\n\n\nArguments\n\n\n\n\nconfigFile\n:  a JSON file or a JSON string or TOML file that contains setup and configuration information\n\n\n\n\nReturns\n\n\n\n\nan opaque \nCombinationFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCore\n \n \nMethod\n.\n\n\nhelicsCreateCore\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \ninitString\n::\nString\n)\n \n-\n \nHELICS\n.\nCore\n\n\n\n\n\n\nCreate a core object\n\n\nArguments\n\n\n\n\ntype\n: the type of the core to create\n\n\nname\n: the name of the core , may be a nullptr or empty string to have a name automatically assigned\n\n\ninitString\n: an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" or the number of federates or the address\n\n\n\n\nReturns\n\n\n\n\na \nCore\n object if the core is invalid err will contain some indication\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCoreFromArgs\n \n \nMethod\n.\n\n\nhelicsCreateCoreFromArgs\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \nargc\n::\nInt64\n,\n \nargv\n::\nArray\n{\nString\n,\n1\n})\n \n-\n \nHELICS\n.\nCore\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateFederateInfo\n \n \nMethod\n.\n\n\nhelicsCreateFederateInfo\n()\n \n-\n \nHELICS\n.\nFederateInfo\n\n\n\n\n\n\nCreate a \nFederateInfo\n object for specifying federate information when constructing a federate\n\n\nReturns\n\n\n\n\na \nFederateInfo\n object which is a reference to the created object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateMessageFederate\n \n \nMethod\n.\n\n\nhelicsCreateMessageFederate\n(\nfedName\n::\nString\n,\n \nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n-\n \nHELICS\n.\nMessageFederate\n\n\n\n\n\n\nCreate a \nMessageFederate\n from a \nFederateInfo\n object\n\n\nMessageFederate\n objects can be used in all functions that take a \nMessageFederate\n or \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nfedName\n: the name of the federate to create\n\n\nfi\n: the \nFederateInfo\n object that contains details on the federate\n\n\n\n\nReturns\n\n\n\n\nan opaque \nMessageFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateMessageFederateFromConfig\n \n \nMethod\n.\n\n\nhelicsCreateMessageFederateFromConfig\n(\nconfigFile\n::\nString\n)\n \n-\n \nHELICS\n.\nMessageFederate\n\n\n\n\n\n\nCreate a \nMessageFederate\n from a JSON file or JSON string or TOML file\n\n\nMessageFederate\n objects can be used in all functions that take a \nMessageFederate\n or \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nconfigFile\n:  a Config(JSON,TOML) file or a JSON string that contains setup and configuration information\n\n\n\n\nReturns\n\n\n\n\nan opaque \nMessageFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateQuery\n \n \nMethod\n.\n\n\nhelicsCreateQuery\n(\ntarget\n::\nString\n,\n \nquery\n::\nString\n)\n \n-\n \nHELICS\n.\nQuery\n\n\n\n\n\n\nCreate a \nQuery\n\n\na \nQuery\n consists of a target and query string\n\n\nArguments\n\n\n\n\ntarget\n: the name of the target to query\n\n\nquery\n: the query string to make of the target\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateValueFederate\n \n \nMethod\n.\n\n\nhelicsCreateValueFederate\n(\nfedName\n::\nString\n,\n \nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n-\n \nHELICS\n.\nValueFederate\n\n\n\n\n\n\nCreate a value federate from a \nFederateInfo\n object\n\n\nFederate\n objects can be used in all functions that take a \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nfedName\n: the name of the federate to create, can NULL or an empty string to use the default name from fi or an assigned name\n\n\nfi\n: the \nFederateInfo\n object that contains details on the federate\n\n\n\n\nReturns\n\n\n\n\nan opaque value \nFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateValueFederateFromConfig\n \n \nMethod\n.\n\n\nhelicsCreateValueFederateFromConfig\n(\nconfigFile\n::\nString\n)\n \n-\n \nHELICS\n.\nValueFederate\n\n\n\n\n\n\nCreate a value federate from a JSON file, JSON string, or TOML file\n\n\nFederate\n objects can be used in all functions that take a \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nconfigFile\n:  a JSON file or a JSON string or TOML file that contains setup and configuration information\n\n\n\n\nReturns\n\n\n\n\nan opaque value \nFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetDefaultDestination\n \n \nMethod\n.\n\n\nhelicsEndpointGetDefaultDestination\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetInfo\n \n \nMethod\n.\n\n\nhelicsEndpointGetInfo\n(\n_end\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetMessage\n \n \nMethod\n.\n\n\nhelicsEndpointGetMessage\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nHELICS\n.\nMessage\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetName\n \n \nMethod\n.\n\n\nhelicsEndpointGetName\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetOption\n \n \nMethod\n.\n\n\nhelicsEndpointGetOption\n(\n_end\n::\nHELICS\n.\nEndpoint\n,\n \noption\n::\nInt64\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetType\n \n \nMethod\n.\n\n\nhelicsEndpointGetType\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointHasMessage\n \n \nMethod\n.\n\n\nhelicsEndpointHasMessage\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointPendingMessages\n \n \nMethod\n.\n\n\nhelicsEndpointPendingMessages\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendEventRaw\n \n \nMethod\n.\n\n\nhelicsEndpointSendEventRaw\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \ndest\n::\nString\n,\n \ndata\n::\nString\n,\n \ntime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendMessage\n \n \nMethod\n.\n\n\nhelicsEndpointSendMessage\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \nmessage\n::\nHELICS\n.\nMessage\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendMessageRaw\n \n \nMethod\n.\n\n\nhelicsEndpointSendMessageRaw\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \ndest\n::\nString\n,\n \ndata\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSetDefaultDestination\n \n \nMethod\n.\n\n\nhelicsEndpointSetDefaultDestination\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \ndest\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSetInfo\n \n \nMethod\n.\n\n\nhelicsEndpointSetInfo\n(\n_end\n::\nHELICS\n.\nEndpoint\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSetOption\n \n \nMethod\n.\n\n\nhelicsEndpointSetOption\n(\n_end\n::\nHELICS\n.\nEndpoint\n,\n \noption\n::\nInt64\n,\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSubscribe\n \n \nMethod\n.\n\n\nhelicsEndpointSubscribe\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \nkey\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsErrorClear\n \n \nMethod\n.\n\n\nhelicsErrorClear\n(\nerr\n::\nHELICS\n.\nLib\n.\nhelics_error\n)\n\n\n\n\n\n\nClear an error object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsErrorInitialize\n \n \nMethod\n.\n\n\nhelicsErrorInitialize\n()\n \n-\n \nHELICS\n.\nLib\n.\nhelics_error\n\n\n\n\n\n\nReturn an initialized error object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateClone\n \n \nMethod\n.\n\n\nhelicsFederateClone\n(\nfed\n::\nT\n:\nHELICS\n.\nFederate\n)\n \n-\n \nUnion\n{\nCombinationFederate\n,\n \nMessageFederate\n,\n \nValueFederate\n}\n\n\n\n\n\n\nCreate a new reference to an existing federate\n\n\nthis will create a new \nFederate\n object that references the existing federate it must be freed as well\n\n\nArguments\n\n\n\n\nfed\n: an existing \nFederate\n\n\n\n\nReturns\n\n\n\n\na new reference to the same federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateDestroy\n \n \nMethod\n.\n\n\nhelicsFederateDestroy\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nDisconnect and free a broker\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingMode\n \n \nMethod\n.\n\n\nhelicsFederateEnterExecutingMode\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nRequest that the federate enter the Execution mode\n\n\nthis call is blocking until granted entry by the core object for an asynchronous alternative call \nhelicsFederateEnterExecutingModeAsync\n on return from this call the federate will be at time 0.\n\n\nArguments\n\n\n\n\nfed\n: a federate to change modes\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeAsync\n \n \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nRequest that the federate enter the Execution mode\n\n\nthis call is non-blocking and will return immediately. Call \nhelicsFederateEnterExecutingModeComplete\n to finish the call sequence.\n\n\nArguments\n\n\n\n\nfed\n: the federate object to complete the call\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeComplete\n \n \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nComplete the call to \nhelicsFederateEnterExecutingModeAsync\n\n\nArguments\n\n\n\n\nfed\n: the federate object to complete the call\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeIterative\n \n \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeIterative\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \niterate\n::\nUnion\n{\nInt64\n,\n \nhelics_iteration_request\n})\n \n-\n \nHELICS\n.\nLib\n.\nhelics_iteration_result\n\n\n\n\n\n\nRequest an iterative time\n\n\nthis call allows for finer grain control of the iterative process then \nhelicsFederateRequestTime\n it takes a time and iteration request and return a time and iteration status.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\niterate\n: the requested iteration mode\n\n\n\n\nReturns\n\n\n\n\nan iteration structure with field containing the time and iteration status\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeIterativeAsync\n \n \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeIterativeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \niterate\n::\nUnion\n{\nInt64\n,\n \nhelics_iteration_request\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeIterativeComplete\n \n \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeIterativeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nHELICS\n.\nLib\n.\nhelics_iteration_result\n\n\n\n\n\n\nComplete the asynchronous iterative call into ExecutionModel\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nan iteration object containing the iteration time and iteration_status\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterInitializingMode\n \n \nMethod\n.\n\n\nhelicsFederateEnterInitializingMode\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nEnter the initialization state of a federate\n\n\nthe initialization state allows initial values to be set and received if the iteration is requested on entry to the execution state. This is a blocking call and will block until the core allows it to proceed.\n\n\nArguments\n\n\n\n\nfed\n: the federate to operate on\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterInitializingModeAsync\n \n \nMethod\n.\n\n\nhelicsFederateEnterInitializingModeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nNon blocking alternative to \nhelicsFederateEnterInitializingMode\n. The function \nhelicsFederateFinalize\n must be called to finish the operation\n\n\nArguments\n\n\n\n\nfed\n: the federate to operate on\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterInitializingModeComplete\n \n \nMethod\n.\n\n\nhelicsFederateEnterInitializingModeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nFinalize the entry to initialize mode that was initiated with \nhelicsFederateEnterInitializingModeAsync\n\n\nArguments\n\n\n\n\nfed\n: the federate desiring to complete the initialization step function\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFinalize\n \n \nMethod\n.\n\n\nhelicsFederateFinalize\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nFinalize the federate this function halts all communication in the federate and disconnects it from the core\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFinalizeAsync\n \n \nMethod\n.\n\n\nhelicsFederateFinalizeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nFinalize the federate in an async call\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFinalizeComplete\n \n \nMethod\n.\n\n\nhelicsFederateFinalizeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nComplete the asynchronous finalize call\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFree\n \n \nMethod\n.\n\n\nhelicsFederateFree\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nRelease the memory associated withe a federate\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetCoreObject\n \n \nMethod\n.\n\n\nhelicsFederateGetCoreObject\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nHELICS\n.\nCore\n\n\n\n\n\n\nGet the core object associated with a federate\n\n\nArguments\n\n\n\n\nfed\n: a federate object\n\n\n\n\nReturns\n\n\n\n\na core object, nullptr if invalid\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetCurrentTime\n \n \nMethod\n.\n\n\nhelicsFederateGetCurrentTime\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nFloat64\n\n\n\n\n\n\nGet the current time of the federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n to query\n\n\n\n\nReturns\n\n\n\n\nthe current time of the federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetEndpoint\n \n \nMethod\n.\n\n\nhelicsFederateGetEndpoint\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n)\n \n-\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetEndpointByIndex\n \n \nMethod\n.\n\n\nhelicsFederateGetEndpointByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n-\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetEndpointCount\n \n \nMethod\n.\n\n\nhelicsFederateGetEndpointCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFilter\n \n \nMethod\n.\n\n\nhelicsFederateGetFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFilterByIndex\n \n \nMethod\n.\n\n\nhelicsFederateGetFilterByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFilterCount\n \n \nMethod\n.\n\n\nhelicsFederateGetFilterCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFlagOption\n \n \nMethod\n.\n\n\nhelicsFederateGetFlagOption\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nflag\n::\nInt64\n)\n \n-\n \nBool\n\n\n\n\n\n\nGet a flag value for a federate\n\n\nArguments\n\n\n\n\nfed\n: the federate to get the flag for\n\n\nflag\n: the flag to query\n\n\n\n\nReturns\n\n\n\n\nthe value of the flag\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetInput\n \n \nMethod\n.\n\n\nhelicsFederateGetInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetInputByIndex\n \n \nMethod\n.\n\n\nhelicsFederateGetInputByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetInputCount\n \n \nMethod\n.\n\n\nhelicsFederateGetInputCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetIntegerProperty\n \n \nMethod\n.\n\n\nhelicsFederateGetIntegerProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nintProperty\n::\nUnion\n{\nInt64\n,\n \nhelics_handle_options\n})\n \n-\n \nInt32\n\n\n\n\n\n\nSet the logging level for the federate\n\n\ndebug and trace only do anything if they were enabled in the compilation\n\n\nArguments\n\n\n\n\nfed\n: the federate to get the flag for\n\n\nintProperty\n: a code for the property to set \nHELICS_HANDLE_OPTIONS\n\n\n\n\nReturns\n\n\n\n\nthe value of the property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetMessage\n \n \nMethod\n.\n\n\nhelicsFederateGetMessage\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nHELICS\n.\nMessage\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetName\n \n \nMethod\n.\n\n\nhelicsFederateGetName\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nString\n\n\n\n\n\n\nGet the name of the federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n to query\n\n\n\n\nReturns\n\n\n\n\na string with the name\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetPublication\n \n \nMethod\n.\n\n\nhelicsFederateGetPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetPublicationByIndex\n \n \nMethod\n.\n\n\nhelicsFederateGetPublicationByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n-\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetPublicationCount\n \n \nMethod\n.\n\n\nhelicsFederateGetPublicationCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetState\n \n \nMethod\n.\n\n\nhelicsFederateGetState\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nHELICS\n.\nLib\n.\nhelics_federate_state\n\n\n\n\n\n\nGet the current state of a federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n to query\n\n\n\n\nReturns\n\n\n\n\nstate the resulting state if void return helics_ok\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetSubscription\n \n \nMethod\n.\n\n\nhelicsFederateGetSubscription\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetTimeProperty\n \n \nMethod\n.\n\n\nhelicsFederateGetTimeProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ntimeProperty\n::\nUnion\n{\nInt64\n,\n \nhelics_properties\n})\n \n-\n \nFloat64\n\n\n\n\n\n\nGet the current value of a time based property in a federate\n\n\nArguments\n\n\n\n\nfed\n: the federate query\n\n\ntimeProperty\n: the property to query\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateHasMessage\n \n \nMethod\n.\n\n\nhelicsFederateHasMessage\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoClone\n \n \nMethod\n.\n\n\nhelicsFederateInfoClone\n(\nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n-\n \nHELICS\n.\nFederateInfo\n\n\n\n\n\n\nCreate a \nFederateInfo\n object from an existing one and clone the information\n\n\nArguments\n\n\n\n\nfi\n: a \nFederateInfo\n object to duplicate\n\n\n\n\nReturns\n\n\n\n\na helics\nfederate\ninfo object which is a reference to the created object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoFree\n \n \nMethod\n.\n\n\nhelicsFederateInfoFree\n(\nfi\n::\nHELICS\n.\nFederateInfo\n)\n\n\n\n\n\n\nDelete the memory associated with a \nFederateInfo\n object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoLoadFromArgs\n \n \nMethod\n.\n\n\nhelicsFederateInfoLoadFromArgs\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nargc\n::\nInt64\n,\n \nargv\n::\nArray\n{\nString\n,\n1\n})\n\n\n\n\n\n\nLoad a \nFederateInfo\n from command line arguments\n\n\nArguments\n\n\n\n\nfi\n: a \nFederateInfo\n object\n\n\nargc\n: the number of command line arguments\n\n\nargv\n: an array of strings from the command line\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetBroker\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetBroker\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nSet the name or connection information for a broker\n\n\nthis is only used if the core is automatically created, the broker information will be transferred to the core for connection\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nbroker\n: a string which defined the connection information for a broker either a name or an address\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetBrokerPort\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetBrokerPort\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nbrokerPort\n::\nInt64\n)\n\n\n\n\n\n\nSet the port to use for the broker\n\n\nthis is only used if the core is automatically created, the broker information will be transferred to the core for connection this will only be useful for network broker connections\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nbrokerPort\n: the integer port number to use for connection with a broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreInitString\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetCoreInitString\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncoreInit\n::\nString\n)\n\n\n\n\n\n\nSet the initialization string for the core usually in the form of command line arguments\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncoreInit\n: a string with the core initialization strings\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreName\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetCoreName\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncorename\n::\nString\n)\n\n\n\n\n\n\nSet the name of the core to link to for a federate\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncorename\n: the identifier for a core to link to\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreType\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetCoreType\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncoretype\n::\nUnion\n{\nInt64\n,\n \nhelics_core_type\n})\n\n\n\n\n\n\nSet the core type by integer code\n\n\nvalid values available by definitions in api-data.h\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncoretype\n: an numerical code for a core type see /ref helics\ncore\ntype\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreTypeFromString\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetCoreTypeFromString\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncoretype\n::\nString\n)\n\n\n\n\n\n\nSet the core type from a string\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncoretype\n: a string naming a core type\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetFlagOption\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetFlagOption\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nflag\n::\nUnion\n{\nInt64\n,\n \nhelics_federate_flags\n},\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nSet a flag in the info structure\n\n\nvalid flags are available \nHELICS_FEDERATE_FLAGS\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nflag\n: a numerical index for a flag\n\n\nvalue\n: the desired value of the flag \ntrue\n or \nfalse\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetIntegerProperty\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetIntegerProperty\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nintProperty\n::\nUnion\n{\nInt64\n,\n \nhelics_properties\n},\n \npropertyValue\n::\nInt64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetLocalPort\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetLocalPort\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nlocalPort\n::\nInt64\n)\n\n\n\n\n\n\nSet the local port to use\n\n\nthis is only used if the core is automatically created, the port information will be transferred to the core for connection\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nlocalPort\n: a string with the port information to use as the local server port can be a number or \"auto\" or \"os_local\"\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetSeparator\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetSeparator\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nseparator\n::\nChar\n)\n\n\n\n\n\n\nSet the separator character in the info structure\n\n\nthe separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nseparator\n: the character to use as a separator\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetTimeProperty\n \n \nMethod\n.\n\n\nhelicsFederateInfoSetTimeProperty\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ntimeProperty\n::\nUnion\n{\nInt64\n,\n \nhelics_properties\n},\n \npropertyValue\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateIsAsyncOperationCompleted\n \n \nMethod\n.\n\n\nhelicsFederateIsAsyncOperationCompleted\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if the current Asynchronous operation has completed\n\n\nArguments\n\n\n\n\nfed\n: the federate to operate on\n\n\n\n\nReturns\n\n\n\n\nfalse\n if not completed, \ntrue\n if completed\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateIsValid\n \n \nMethod\n.\n\n\nhelicsFederateIsValid\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if a federate_object is valid\n\n\nReturns\n\n\n\n\ntrue\n if the federate is a valid active federate, \nfalse\n otherwise\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederatePendingMessages\n \n \nMethod\n.\n\n\nhelicsFederatePendingMessages\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterCloningFilter\n \n \nMethod\n.\n\n\nhelicsFederateRegisterCloningFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ndeliveryEndpoint\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterEndpoint\n \n \nMethod\n.\n\n\nhelicsFederateRegisterEndpoint\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n,\n \nkind\n::\nString\n)\n \n-\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterFilter\n \n \nMethod\n.\n\n\nhelicsFederateRegisterFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_filter_type\n},\n \nname\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalCloningFilter\n \n \nMethod\n.\n\n\nhelicsFederateRegisterGlobalCloningFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ndeliveryEndpoint\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalEndpoint\n \n \nMethod\n.\n\n\nhelicsFederateRegisterGlobalEndpoint\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n,\n \nkind\n::\nString\n)\n \n-\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalFilter\n \n \nMethod\n.\n\n\nhelicsFederateRegisterGlobalFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_filter_type\n},\n \nname\n::\nString\n)\n \n-\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalInput\n \n \nFunction\n.\n\n\nhelicsFederateRegisterGlobalInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n})\n \n-\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterGlobalInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalPublication\n \n \nFunction\n.\n\n\nhelicsFederateRegisterGlobalPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n})\n \n-\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterGlobalPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalTypeInput\n \n \nFunction\n.\n\n\nhelicsFederateRegisterGlobalTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterGlobalTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalTypePublication\n \n \nFunction\n.\n\n\nhelicsFederateRegisterGlobalTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterGlobalTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterInput\n \n \nFunction\n.\n\n\nhelicsFederateRegisterInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n})\n \n-\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterInterfaces\n \n \nMethod\n.\n\n\nhelicsFederateRegisterInterfaces\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nfile\n::\nString\n)\n\n\n\n\n\n\nLoad interfaces from a file\n\n\nArguments\n\n\n\n\nfed\n: the federate to which to load interfaces\n\n\nfile\n: the name of a file to load the interfaces from either JSON, or TOML\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterPublication\n \n \nFunction\n.\n\n\nhelicsFederateRegisterPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n})\n \n-\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterSubscription\n \n \nFunction\n.\n\n\nhelicsFederateRegisterSubscription\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterSubscription\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterTypeInput\n \n \nFunction\n.\n\n\nhelicsFederateRegisterTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterTypePublication\n \n \nFunction\n.\n\n\nhelicsFederateRegisterTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n-\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestNextStep\n \n \nMethod\n.\n\n\nhelicsFederateRequestNextStep\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nFloat64\n\n\n\n\n\n\nRequest the next time step for federate execution\n\n\nfeds should have setup the period or minDelta for this to work well but it will request the next time step which is the current time plus the minimum time step.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTime\n \n \nMethod\n.\n\n\nhelicsFederateRequestTime\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n \n-\n \nFloat64\n\n\n\n\n\n\nRequest the next time for federate execution\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next requested time\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate   invalid\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeAsync\n \n \nMethod\n.\n\n\nhelicsFederateRequestTimeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nRequest the next time for federate execution in an asynchronous call Call \nhelicsFederateRequestTimeComplete\n to finish the call\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next requested time\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeComplete\n \n \nMethod\n.\n\n\nhelicsFederateRequestTimeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nFloat64\n\n\n\n\n\n\nComplete an asynchronous requestTime call\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeIterative\n \n \nMethod\n.\n\n\nhelicsFederateRequestTimeIterative\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n},\n \niterate\n::\nUnion\n{\nInt64\n,\n \nhelics_iteration_request\n})\n\n\n\n\n\n\nRequest an iterative time\n\n\nthis call allows for finer grain control of the iterative process then \nhelicsFederateRequestTime\n it takes a time and iteration request and return a time and iteration status.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next desired time\n\n\niterate\n: the requested iteration mode\n\n\n\n\nReturns\n\n\n\n\nthe granted time\n\n\nthe iteration specification of the result\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeIterativeAsync\n \n \nMethod\n.\n\n\nhelicsFederateRequestTimeIterativeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n},\n \niterate\n::\nUnion\n{\nInt64\n,\n \nhelics_iteration_request\n})\n\n\n\n\n\n\nRequest an iterative time through an asynchronous call\n\n\nthis call allows for finer grain control of the iterative process then \nhelicsFederateRequestTime\n it takes a time an iteration request and returns a time and iteration status call \nhelicsFederateRequestTimeIterativeComplete\n to finish the process.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next desired time\n\n\niterate\n: the requested iteration mode\n\n\n\n\nReturns\n\n\n\n\na void object with a return code of the result\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeIterativeComplete\n \n \nMethod\n.\n\n\nhelicsFederateRequestTimeIterativeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nComplete an iterative time request asynchronous call\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nthe granted time\n\n\noutIterate\n  the iteration specification of the result\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetFlagOption\n \n \nMethod\n.\n\n\nhelicsFederateSetFlagOption\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nflag\n::\nInt64\n,\n \nflagValue\n::\nBool\n)\n\n\n\n\n\n\nSet a flag for the federate\n\n\nArguments\n\n\n\n\nfed\n: the federate to alter a flag for\n\n\nflag\n: the flag to change\n\n\nflagValue\n: the new value of the flag 0 for false !=0 for true\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetGlobal\n \n \nMethod\n.\n\n\nhelicsFederateSetGlobal\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nvalueName\n::\nString\n,\n \nvalue\n::\nString\n)\n\n\n\n\n\n\nSet a federation global value through a federate\n\n\nthis overwrites any previous value for this name\n\n\nArguments\n\n\n\n\nfed\n: the federate to set the global through\n\n\nvalueName\n: the name of the global to set\n\n\nvalue\n: the value of the global\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetIntegerProperty\n \n \nMethod\n.\n\n\nhelicsFederateSetIntegerProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nintProperty\n::\nUnion\n{\nInt64\n,\n \nhelics_properties\n},\n \npropertyVal\n::\nInt64\n)\n\n\n\n\n\n\nSet an integer based property of a federate\n\n\nArguments\n\n\n\n\nfed\n: the federate to change the property for\n\n\nintProperty\n: the property to set\n\n\npropertyVal\n: the value of the property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetSeparator\n \n \nMethod\n.\n\n\nhelicsFederateSetSeparator\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nseparator\n::\nChar\n)\n\n\n\n\n\n\nSet the separator character in a federate\n\n\nthe separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName.\n\n\nArguments\n\n\n\n\nfed\n: the \nFederateInfo\n object to alter\n\n\nseparator\n: the character to use as a separator\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetTimeProperty\n \n \nMethod\n.\n\n\nhelicsFederateSetTimeProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ntimeProperty\n::\nUnion\n{\nInt64\n,\n \nhelics_properties\n},\n \ntime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nSet a time based property for a federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n set the property for\n\n\ntimeProperty\n: a integer code for a time property\n\n\ntime\n: the requested value of the property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterAddDeliveryEndpoint\n \n \nMethod\n.\n\n\nhelicsFilterAddDeliveryEndpoint\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ndeliveryEndpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterAddDestinationTarget\n \n \nMethod\n.\n\n\nhelicsFilterAddDestinationTarget\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ndest\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterAddSourceTarget\n \n \nMethod\n.\n\n\nhelicsFilterAddSourceTarget\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \nsource\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterGetInfo\n \n \nMethod\n.\n\n\nhelicsFilterGetInfo\n(\nfilt\n::\nHELICS\n.\nFilter\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterGetName\n \n \nMethod\n.\n\n\nhelicsFilterGetName\n(\nfilt\n::\nHELICS\n.\nFilter\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterGetOption\n \n \nMethod\n.\n\n\nhelicsFilterGetOption\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \noption\n::\nInt64\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterRemoveDeliveryEndpoint\n \n \nMethod\n.\n\n\nhelicsFilterRemoveDeliveryEndpoint\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ndeliveryEndpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterRemoveTarget\n \n \nMethod\n.\n\n\nhelicsFilterRemoveTarget\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSet\n \n \nMethod\n.\n\n\nhelicsFilterSet\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \nprop\n::\nString\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSetInfo\n \n \nMethod\n.\n\n\nhelicsFilterSetInfo\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSetOption\n \n \nMethod\n.\n\n\nhelicsFilterSetOption\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \noption\n::\nInt64\n,\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSetString\n \n \nMethod\n.\n\n\nhelicsFilterSetString\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \nprop\n::\nString\n,\n \nval\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetFederateByName\n \n \nMethod\n.\n\n\nhelicsGetFederateByName\n(\nfedName\n::\nString\n)\n \n-\n \nHELICS\n.\nCombinationFederate\n\n\n\n\n\n\nGet an existing \nFederate\n from a core by name\n\n\nthe federate must have been created by one of the other functions and at least one of the objects referencing the created     federate must still be active in the process\n\n\nArguments\n\n\n\n\nfedName\n: the name of the federate to retrieve\n\n\n\n\nReturns\n\n\n\n\nNULL if no fed is available by that name otherwise a \nFederate\n with that name\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetOptionIndex\n \n \nMethod\n.\n\n\nhelicsGetOptionIndex\n(\nval\n::\nString\n)\n \n-\n \nInt64\n\n\n\n\n\n\nGet an option index for use in \nhelicsPublicationSetOption\n, \nhelicsInputSetOption\n, \nhelicsEndpointSetOption\n, \nhelicsFilterSetOption\n, and the corresponding get functions\n\n\nArguments\n\n\n\n\nval\n: a string with the option name\n\n\n\n\nReturns\n\n\n\n\nan int with the option index (-1) if not a valid property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetPropertyIndex\n \n \nMethod\n.\n\n\nhelicsGetPropertyIndex\n(\nval\n::\nString\n)\n \n-\n \nInt64\n\n\n\n\n\n\nGet a property index for use in \nhelicsFederateInfoSetFlagOption\n, \nhelicsFederateInfoSetTimeProperty\n, \nhelicsFederateInfoSetIntegerProperty\n\n\nArguments\n\n\n\n\nval\n: a string with the property name\n\n\n\n\nReturns\n\n\n\n\nan int with the property code (-1) if not a valid property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetVersion\n \n \nMethod\n.\n\n\nhelicsGetVersion\n()\n \n-\n \nString\n\n\n\n\n\n\nGet a version string for HELICS\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputAddTarget\n \n \nMethod\n.\n\n\nhelicsInputAddTarget\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetBoolean\n \n \nMethod\n.\n\n\nhelicsInputGetBoolean\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetChar\n \n \nMethod\n.\n\n\nhelicsInputGetChar\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nChar\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetComplex\n \n \nMethod\n.\n\n\nhelicsInputGetComplex\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nComplex\n{\nFloat64\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetComplexObject\n \n \nMethod\n.\n\n\nhelicsInputGetComplexObject\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nComplex\n{\nFloat64\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetDouble\n \n \nMethod\n.\n\n\nhelicsInputGetDouble\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nFloat64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetInfo\n \n \nMethod\n.\n\n\nhelicsInputGetInfo\n(\ninp\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetInteger\n \n \nMethod\n.\n\n\nhelicsInputGetInteger\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetKey\n \n \nMethod\n.\n\n\nhelicsInputGetKey\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetNamedPoint\n \n \nMethod\n.\n\n\nhelicsInputGetNamedPoint\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nTuple\n{\nString\n,\nFloat64\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetOption\n \n \nMethod\n.\n\n\nhelicsInputGetOption\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \noption\n::\nInt64\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetPublicationType\n \n \nMethod\n.\n\n\nhelicsInputGetPublicationType\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetRawValue\n \n \nMethod\n.\n\n\nhelicsInputGetRawValue\n(\nipt\n::\nT\n,\n \ndata\n::\nT\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetRawValueSize\n \n \nMethod\n.\n\n\nhelicsInputGetRawValueSize\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetString\n \n \nMethod\n.\n\n\nhelicsInputGetString\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetStringSize\n \n \nMethod\n.\n\n\nhelicsInputGetStringSize\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetTime\n \n \nMethod\n.\n\n\nhelicsInputGetTime\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nFloat64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetType\n \n \nMethod\n.\n\n\nhelicsInputGetType\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetUnits\n \n \nMethod\n.\n\n\nhelicsInputGetUnits\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetVector\n \n \nMethod\n.\n\n\nhelicsInputGetVector\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nArray\n{\nFloat64\n,\n1\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetVectorSize\n \n \nMethod\n.\n\n\nhelicsInputGetVectorSize\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputIsUpdated\n \n \nMethod\n.\n\n\nhelicsInputIsUpdated\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputLastUpdateTime\n \n \nMethod\n.\n\n\nhelicsInputLastUpdateTime\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nFloat64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultBoolean\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultBoolean\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultChar\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultChar\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nChar\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultComplex\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultComplex\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nc\n::\nComplex\n{\nFloat64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultDouble\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultDouble\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultInteger\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultInteger\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nInt64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultNamedPoint\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultNamedPoint\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nstr\n::\nString\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultRaw\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultRaw\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \ndata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultString\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultString\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nstr\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultTime\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultTime\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultVector\n \n \nMethod\n.\n\n\nhelicsInputSetDefaultVector\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nvectorInput\n::\nArray\n{\nFloat64\n,\n1\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetInfo\n \n \nMethod\n.\n\n\nhelicsInputSetInfo\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetOption\n \n \nMethod\n.\n\n\nhelicsInputSetOption\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \noption\n::\nInt64\n,\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsIsCoreTypeAvailable\n \n \nMethod\n.\n\n\nhelicsIsCoreTypeAvailable\n(\nkind\n::\nString\n)\n \n-\n \nBool\n\n\n\n\n\n\nReturns true if core/broker type specified is available in current compilation.\n\n\nArguments\n\n\n\n\ntype\n: a string representing a core type\n\n\n\n\nReturns\n\n\n\n\na \nBool\n\n\n\n\npossible options include \"test\",\"zmq\",\"udp\",\"ipc\",\"interprocess\",\"tcp\",\"default\", \"mpi\"\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationAddTarget\n \n \nMethod\n.\n\n\nhelicsPublicationAddTarget\n(\npub\n::\nHELICS\n.\nPublication\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetInfo\n \n \nMethod\n.\n\n\nhelicsPublicationGetInfo\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetKey\n \n \nMethod\n.\n\n\nhelicsPublicationGetKey\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetOption\n \n \nMethod\n.\n\n\nhelicsPublicationGetOption\n(\npub\n::\nHELICS\n.\nPublication\n,\n \noption\n::\nInt64\n)\n \n-\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetType\n \n \nMethod\n.\n\n\nhelicsPublicationGetType\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetUnits\n \n \nMethod\n.\n\n\nhelicsPublicationGetUnits\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n-\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishBoolean\n \n \nMethod\n.\n\n\nhelicsPublicationPublishBoolean\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishChar\n \n \nMethod\n.\n\n\nhelicsPublicationPublishChar\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nChar\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishComplex\n \n \nMethod\n.\n\n\nhelicsPublicationPublishComplex\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nc\n::\nComplex\n{\nFloat64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishDouble\n \n \nMethod\n.\n\n\nhelicsPublicationPublishDouble\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishInteger\n \n \nMethod\n.\n\n\nhelicsPublicationPublishInteger\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nInt64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishNamedPoint\n \n \nMethod\n.\n\n\nhelicsPublicationPublishNamedPoint\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nstr\n::\nString\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishRaw\n \n \nMethod\n.\n\n\nhelicsPublicationPublishRaw\n(\npub\n::\nHELICS\n.\nPublication\n,\n \ndata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishString\n \n \nMethod\n.\n\n\nhelicsPublicationPublishString\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nstr\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishTime\n \n \nMethod\n.\n\n\nhelicsPublicationPublishTime\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishVector\n \n \nMethod\n.\n\n\nhelicsPublicationPublishVector\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nvectorInput\n::\nArray\n{\nFloat64\n,\n1\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationSetInfo\n \n \nMethod\n.\n\n\nhelicsPublicationSetInfo\n(\npub\n::\nHELICS\n.\nPublication\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationSetOption\n \n \nMethod\n.\n\n\nhelicsPublicationSetOption\n(\npub\n::\nHELICS\n.\nPublication\n,\n \noption\n::\nInt64\n,\n \nval\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryBrokerExecute\n \n \nMethod\n.\n\n\nhelicsQueryBrokerExecute\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \nbroker\n::\nHELICS\n.\nBroker\n)\n \n-\n \nString\n\n\n\n\n\n\nExecute a \nQuery\n directly on a broker\n\n\nthe call will block until the \nQuery\n finishes which may require communication or other delays\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\nbroker\n: the broker to send the \nQuery\n to\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if fed or \nQuery\n is an invalid object, the return string will be \"#invalid\" if the \nQuery\n itself was invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryCoreExecute\n \n \nMethod\n.\n\n\nhelicsQueryCoreExecute\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \ncore\n::\nHELICS\n.\nCore\n)\n \n-\n \nString\n\n\n\n\n\n\nExecute a \nQuery\n directly on a core\n\n\nthe call will block until the \nQuery\n finishes which may require communication or other delays\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\ncore\n: the core to send the \nQuery\n to\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if fed or \nQuery\n is an invalid object, the return string will be \"#invalid\" if the \nQuery\n itself was invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryExecute\n \n \nMethod\n.\n\n\nhelicsQueryExecute\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \nfed\n::\nHELICS\n.\nFederate\n)\n \n-\n \nString\n\n\n\n\n\n\nExecute a query\n\n\nthe call will block until the \nQuery\n finishes which may require communication or other delays\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\nfed\n: a federate to send the \nQuery\n through\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if fed or \nQuery\n is an invalid object, the return string will be \"#invalid\" if the \nQuery\n itself was invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryExecuteAsync\n \n \nMethod\n.\n\n\nhelicsQueryExecuteAsync\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nExecute a \nQuery\n in a non-blocking call\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\nfed\n: a federate to send the \nQuery\n through\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryExecuteComplete\n \n \nMethod\n.\n\n\nhelicsQueryExecuteComplete\n(\nquery\n::\nHELICS\n.\nQuery\n)\n \n-\n \nString\n\n\n\n\n\n\nComplete the return from a \nQuery\n called with \nhelicsQueryExecuteAsync\n\n\nthe function will block until the \nQuery\n completes \nhelicsQueryIsCompleted\n can be called to determine if a \nQuery\n has completed or not.\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to complete execution of\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if \nQuery\n is an invalid object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryFree\n \n \nMethod\n.\n\n\nhelicsQueryFree\n(\nquery\n::\nHELICS\n.\nQuery\n)\n\n\n\n\n\n\nFree the memory associated with a \nQuery\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryIsCompleted\n \n \nMethod\n.\n\n\nhelicsQueryIsCompleted\n(\nquery\n::\nHELICS\n.\nQuery\n)\n \n-\n \nBool\n\n\n\n\n\n\nCheck if an asynchronously executed \nQuery\n has completed\n\n\nthis function should usually be called after a QueryExecuteAsync function has been called.\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to check if completed\n\n\n\n\nReturns\n\n\n\n\nwill return \ntrue\n if an asynchronous \nQuery\n has complete or a regular \nQuery\n call was made with a result and \nfalse\n if an asynchronous \nQuery\n has not completed or is invalid\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsSubscriptionGetKey\n \n \nMethod\n.\n\n\nhelicsSubscriptionGetKey\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n-\n \nString\n\n\n\n\n\n\nsource", 
            "title": "API"
        }, 
        {
            "location": "/api/#api", 
            "text": "#  HELICS.Broker     Type .  Summary  struct  HELICS.Broker   :  HELICS.CWrapper  source  #  HELICS.CWrapper     Type .  Summary  abstract type HELICS.CWrapper  source  #  HELICS.CombinationFederate     Type .  Summary  struct  HELICS.CombinationFederate   :  HELICS.Federate  source  #  HELICS.Core     Type .  Summary  struct  HELICS.Core   :  HELICS.CWrapper  source  #  HELICS.Endpoint     Type .  Summary  struct  HELICS.Endpoint   :  HELICS.CWrapper  source  #  HELICS.Federate     Type .  Summary  abstract type HELICS.Federate  : HELICS.CWrapper  Subtypes   HELICS.CombinationFederate  HELICS.MessageFederate  HELICS.ValueFederate   Supertype Hierarchy  HELICS.Federate  : HELICS.CWrapper  : Any  source  #  HELICS.FederateInfo     Type .  Summary  struct  HELICS.FederateInfo   :  HELICS.CWrapper  source  #  HELICS.Filter     Type .  Summary  struct  HELICS.Filter   :  HELICS.CWrapper  source  #  HELICS.HELICS_CORE_TYPE     Type .   HELICS_CORE_TYPE_DEFAULT : 0  HELICS_CORE_TYPE_ZMQ : 1  HELICS_CORE_TYPE_MPI : 2  HELICS_CORE_TYPE_TEST : 3  HELICS_CORE_TYPE_INTERPROCESS : 4  HELICS_CORE_TYPE_IPC : 5  HELICS_CORE_TYPE_TCP : 6  HELICS_CORE_TYPE_UDP : 7  HELICS_CORE_TYPE_ZMQ_TEST : 10  HELICS_CORE_TYPE_NNG : 9  HELICS_CORE_TYPE_TCP_SS : 11  HELICS_CORE_TYPE_HTTP : 12   source  #  HELICS.HELICS_DATA_TYPE     Type .   HELICS_DATA_TYPE_STRING : 0  HELICS_DATA_TYPE_DOUBLE : 1  HELICS_DATA_TYPE_INT : 2  HELICS_DATA_TYPE_COMPLEX : 3  HELICS_DATA_TYPE_VECTOR : 4  HELICS_DATA_TYPE_COMPLEX_VECTOR : 5  HELICS_DATA_TYPE_NAMED_POINT : 6  HELICS_DATA_TYPE_BOOLEAN : 7  HELICS_DATA_TYPE_TIME : 8  HELICS_DATA_TYPE_RAW : 25  HELICS_DATA_TYPE_ANY : 25262   source  #  HELICS.HELICS_ERROR_TYPES     Type .   HELICS_OK : 0  HELICS_ERROR_REGISTRATION_FAILURE : -1  HELICS_ERROR_CONNECTION_FAILURE : -2  HELICS_ERROR_INVALID_OBJECT : -3  HELICS_ERROR_INVALID_ARGUMENT : -4  HELICS_ERROR_DISCARD : -5  HELICS_ERROR_SYSTEM_FAILURE : -6  HELICS_WARNING : -8  HELICS_ERROR_INVALID_STATE_TRANSITION : -9  HELICS_ERROR_INVALID_FUNCTION_CALL : -10  HELICS_ERROR_EXECUTION_FAILURE : -14  HELICS_ERROR_OTHER : -101  OTHER_ERROR_TYPE : -203   source  #  HELICS.HELICS_FEDERATE_FLAGS     Type .   HELICS_FLAG_OBSERVER : 0  HELICS_FLAG_UNINTERRUPTIBLE : 1  HELICS_FLAG_INTERRUPTIBLE : 2  HELICS_FLAG_SOURCE_ONLY : 4  HELICS_FLAG_ONLY_TRANSMIT_ON_CHANGE : 6  HELICS_FLAG_ONLY_UPDATE_ON_CHANGE : 8  HELICS_FLAG_WAIT_FOR_CURRENT_TIME_UPDATE : 10  HELICS_FLAG_ROLLBACK : 12  HELICS_FLAG_FORWARD_COMPUTE : 14  HELICS_FLAG_REALTIME : 16  HELICS_FLAG_SINGLE_THREAD_FEDERATE : 27  HELICS_FLAG_DELAY_INIT_ENTRY : 45  HELICS_FLAG_ENABLE_INIT_ENTRY : 47  HELICS_FLAG_IGNORE_TIME_MISMATCH_WARNINGS : 67   source  #  HELICS.HELICS_FEDERATE_STATE     Type .   HELICS_STATE_STARTUP : 0  HELICS_STATE_INITIALIZATION : 1  HELICS_STATE_EXECUTION : 2  HELICS_STATE_FINALIZE : 3  HELICS_STATE_ERROR : 4  HELICS_STATE_PENDING_INIT : 5  HELICS_STATE_PENDING_EXEC : 6  HELICS_STATE_PENDING_TIME : 7  HELICS_STATE_PENDING_ITERATIVE_TIME : 8  HELICS_STATE_PENDING_FINALIZE : 9   source  #  HELICS.HELICS_FILTER_TYPE     Type .   HELICS_FILTER_TYPE_CUSTOM : 0  HELICS_FILTER_TYPE_DELAY : 1  HELICS_FILTER_TYPE_RANDOM_DELAY : 2  HELICS_FILTER_TYPE_RANDOM_DROP : 3  HELICS_FILTER_TYPE_REROUTE : 4  HELICS_FILTER_TYPE_CLONE : 5  HELICS_FILTER_TYPE_FIREWALL : 6   source  #  HELICS.HELICS_HANDLE_OPTIONS     Type .   HELICS_HANDLE_OPTION_CONNECTION_REQUIRED : 397  HELICS_HANDLE_OPTION_CONNECTION_OPTIONAL : 402  HELICS_HANDLE_OPTION_SINGLE_CONNECTION_ONLY : 407  HELICS_HANDLE_OPTION_MULTIPLE_CONNECTIONS_ALLOWED : 409  HELICS_HANDLE_OPTION_BUFFER_DATA : 411  HELICS_HANDLE_OPTION_STRICT_TYPE_CHECKING : 414  HELICS_HANDLE_OPTION_ONLY_TRANSMIT_ON_CHANGE : 6  HELICS_HANDLE_OPTION_ONLY_UPDATE_ON_CHANGE : 8  HELICS_HANDLE_OPTION_IGNORE_INTERRUPTS : 475   source  #  HELICS.HELICS_ITERATION_REQUEST     Type .   HELICS_ITERATION_REQUEST_NO_ITERATION : 0  HELICS_ITERATION_REQUEST_FORCE_ITERATION : 1  HELICS_ITERATION_REQUEST_ITERATE_IF_NEEDED : 2   source  #  HELICS.HELICS_ITERATION_RESULT     Type .   HELICS_ITERATION_RESULT_NEXT_STEP : 0  HELICS_ITERATION_RESULT_ERROR : 1  HELICS_ITERATION_RESULT_HALTED : 2  HELICS_ITERATION_RESULT_ITERATING : 3   source  #  HELICS.HELICS_LOG_LEVELS     Type .   HELICS_LOG_LEVEL_NO_PRINT : -1  HELICS_LOG_LEVEL_ERROR : 0  HELICS_LOG_LEVEL_WARNING : 1  HELICS_LOG_LEVEL_SUMMARY : 2  HELICS_LOG_LEVEL_CONNECTIONS : 3  HELICS_LOG_LEVEL_INTERFACES : 4  HELICS_LOG_LEVEL_TIMING : 5  HELICS_LOG_LEVEL_DATA : 6  HELICS_LOG_LEVEL_TRACE : 7   source  #  HELICS.HELICS_PROPERTIES     Type .   HELICS_PROPERTY_TIME_DELTA : 137  HELICS_PROPERTY_TIME_PERIOD : 140  HELICS_PROPERTY_TIME_OFFSET : 141  HELICS_PROPERTY_TIME_RT_LAG : 143  HELICS_PROPERTY_TIME_RT_LEAD : 144  HELICS_PROPERTY_TIME_RT_TOLERANCE : 145  HELICS_PROPERTY_TIME_INPUT_DELAY : 148  HELICS_PROPERTY_TIME_OUTPUT_DELAY : 150  HELICS_PROPERTY_INT_MAX_ITERATIONS : 259  HELICS_PROPERTY_INT_LOG_LEVEL : 271   source  #  HELICS.Message     Type .  Summary  struct HELICS.Message  Fields  time :: Float64  data :: String  length :: Int64  messageID :: Int32  flags :: Int16  original_source :: String  source :: String  dest :: String  original_dest :: String   Supertype Hierarchy  HELICS.Message  : Any  source  #  HELICS.MessageFederate     Type .  Summary  struct  HELICS.MessageFederate   :  HELICS.Federate  source  #  HELICS.Publication     Type .  Summary  struct  HELICS.Publication   :  HELICS.CWrapper  source  #  HELICS.Query     Type .  Summary  struct  HELICS.Query   :  HELICS.CWrapper  source  #  HELICS.Subscription     Type .  Summary  struct  HELICS.Subscription   :  HELICS.CWrapper  source  #  HELICS.ValueFederate     Type .  Summary  struct  HELICS.ValueFederate   :  HELICS.Federate  source  #  HELICS.helicsBrokerAddDestinationFilterToEndpoint     Method .  helicsBrokerAddDestinationFilterToEndpoint ( broker :: HELICS . Broker ,   filter :: String ,   endpoint :: String )   source  #  HELICS.helicsBrokerAddSourceFilterToEndpoint     Method .  helicsBrokerAddSourceFilterToEndpoint ( broker :: HELICS . Broker ,   filter :: String ,   endpoint :: String )   source  #  HELICS.helicsBrokerClone     Method .  helicsBrokerClone ( broker :: HELICS . Broker )   -   HELICS . Broker   Create a new reference to an existing broker  this will create a new broker object that references the existing broker it must be freed as well  Arguments   broker : an existing  Broker   Returns   a new reference to the same broker   source  #  HELICS.helicsBrokerDataLink     Method .  helicsBrokerDataLink ( broker :: HELICS . Broker ,   source :: String ,   target :: String )   Link a named publication and named input using a broker  Arguments   broker : the  Broker  to generate the connection from  source : the name of the publication (cannot be NULL)  target : the name of the target to send the publication data (cannot be NULL)   source  #  HELICS.helicsBrokerDestroy     Method .  helicsBrokerDestroy ( broker :: HELICS . Broker )   Disconnect and free a broker  source  #  HELICS.helicsBrokerDisconnect     Method .  helicsBrokerDisconnect ( broker :: HELICS . Broker )   Disconnect a broker  Arguments   broker : the broker to disconnect   source  #  HELICS.helicsBrokerFree     Method .  helicsBrokerFree ( broker :: HELICS . Broker )   Release the memory associated with a broker  source  #  HELICS.helicsBrokerGetAddress     Method .  helicsBrokerGetAddress ( broker :: HELICS . Broker )   -   String   Get the network address associated with a broker  Arguments   broker : the broker to query   Returns   a string with the network address of the broker   source  #  HELICS.helicsBrokerGetIdentifier     Method .  helicsBrokerGetIdentifier ( broker :: HELICS . Broker )   -   String   Get an identifier for the broker  Arguments   broker : the broker to query   Returns   a string containing the identifier for the broker   source  #  HELICS.helicsBrokerIsConnected     Method .  helicsBrokerIsConnected ( broker :: HELICS . Broker )   -   Bool   Check if a broker is connected. A connected broker implies is attached to cores or cores could reach out to communicate. return 0 if not connected , something else if it is connected.  source  #  HELICS.helicsBrokerIsValid     Method .  helicsBrokerIsValid ( broker :: HELICS . Broker )   -   Bool   Check if a broker object is a valid object  Arguments   broker : the  Broker  object to test   source  #  HELICS.helicsBrokerSetGlobal     Method .  helicsBrokerSetGlobal ( broker :: HELICS . Broker ,   valueName :: String ,   value :: String )   Set a federation global value  this overwrites any previous value for this name  Arguments   broker : the broker to set the global through  valueName : the name of the global to set  value : the value of the global   source  #  HELICS.helicsBrokerWaitForDisconnect     Method .  helicsBrokerWaitForDisconnect ( broker :: HELICS . Broker ,   msToWait :: Int64 )   -   Bool   Wait for the broker to disconnect  Arguments   broker : the broker to wait for  msToWait : the time out in millisecond ( 0 for infinite timeout)   Returns   true  if the disconnect was successful,  false  if there was a timeout   source  #  HELICS.helicsCleanupLibrary     Method .  helicsCleanupLibrary ()   Function to do some housekeeping work  this runs some cleanup routines and tries to close out any residual thread that haven't been shutdown yet.  source  #  HELICS.helicsCloseLibrary     Method .  helicsCloseLibrary ()   Call when done using the helics library,  this function will ensure the threads are closed properly if possible     this should be the last call before exiting,  source  #  HELICS.helicsCoreAddDestinationFilterToEndpoint     Method .  helicsCoreAddDestinationFilterToEndpoint ( core :: HELICS . Core ,   filter :: String ,   endpoint :: String )   source  #  HELICS.helicsCoreAddSourceFilterToEndpoint     Method .  helicsCoreAddSourceFilterToEndpoint ( core :: HELICS . Core ,   filter :: String ,   endpoint :: String )   Link a named filter to a source endpoint  Arguments   core : the core to generate the connection from  filter : the name of the filter (cannot be NULL)  endpoint : the name of the endpoint to filter the data from (cannot be NULL)   source  #  HELICS.helicsCoreClone     Method .  helicsCoreClone ( core :: HELICS . Core )   -   HELICS . Core   Create a new reference to an existing core  this will create a new broker object that references the existing broker it must be freed as well  Arguments   core : an existing  Core   Returns   a new reference to the same  Core   source  #  HELICS.helicsCoreDataLink     Method .  helicsCoreDataLink ( core :: HELICS . Core ,   source :: String ,   target :: String )   Link a named publication and named input using a core  Arguments   core : the core to generate the connection from  source : the name of the publication (cannot be NULL)  target : the named of the target to send the publication data (cannot be NULL)   source  #  HELICS.helicsCoreDestroy     Method .  helicsCoreDestroy ( core :: HELICS . Core )   Disconnect and free a core  source  #  HELICS.helicsCoreDisconnect     Method .  helicsCoreDisconnect ( core :: HELICS . Core )   Get an identifier for the core  Arguments   core : the core to query   Returns   a void enumeration indicating any error condition   source  #  HELICS.helicsCoreFree     Method .  helicsCoreFree ( core :: HELICS . Core )   Release the memory associated with a core  source  #  HELICS.helicsCoreGetIdentifier     Method .  helicsCoreGetIdentifier ( core :: HELICS . Core )   -   String   Get an identifier for the core  Arguments   core : the core to query   Returns   a string with the identifier of the core   source  #  HELICS.helicsCoreIsConnected     Method .  helicsCoreIsConnected ( core :: HELICS . Core )   -   Bool   Check if a core is connected. A connected core implies is attached to federate or federates could be attached to it.  Returns   false  if not connected,  true  if it is connected   source  #  HELICS.helicsCoreIsValid     Method .  helicsCoreIsValid ( core :: HELICS . Core )   -   Bool   Check if a core object is a valid object  Arguments   core : the  Core  object to test   source  #  HELICS.helicsCoreRegisterCloningFilter     Method .  helicsCoreRegisterCloningFilter ( core :: HELICS . Core ,   deliveryEndpoint :: String )   -   HELICS . Filter   source  #  HELICS.helicsCoreRegisterFilter     Method .  helicsCoreRegisterFilter ( core :: HELICS . Core ,   kind :: Union { Int64 ,   helics_filter_type },   name :: String )   -   HELICS . Filter   source  #  HELICS.helicsCoreSetGlobal     Method .  helicsCoreSetGlobal ( core :: HELICS . Core ,   valueName :: String ,   value :: String )   Set a global value in a core  this overwrites any previous value for this name  Arguments   core : the core to set the global through  valueName : the name of the global to set  value : the value of the global   source  #  HELICS.helicsCoreSetReadyToInit     Method .  helicsCoreSetReadyToInit ( core :: HELICS . Core )   Set the core to ready for init  this function is used for cores that have filters but no federates so there needs to be a direct signal to the core to trigger the federation initialization  Arguments   core : the core object to enable init values for   source  #  HELICS.helicsCreateBroker     Method .  helicsCreateBroker ( kind :: String ,   name :: String ,   initString :: String )   -   HELICS . Broker   Create a broker object  Arguments   type : the type of the broker to create  name : the name of the broker , may be a nullptr or empty string to have a name automatically assigned  initString : an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" if this is a subbroker or the number of federates or the address   Returns   a  Broker  object, will be NULL if there was an error indicated in the err object   source  #  HELICS.helicsCreateBrokerFromArgs     Method .  helicsCreateBrokerFromArgs ( kind :: String ,   name :: String ,   argc :: Int64 ,   argv :: Array { String , 1 })   -   HELICS . Broker   source  #  HELICS.helicsCreateCombinationFederate     Method .  helicsCreateCombinationFederate ( fedName :: String ,   fi :: HELICS . FederateInfo )   -   HELICS . CombinationFederate   Create a  CombinationFederate  from a  FederateInfo  object  CombinationFederate  are both  ValueFederate  and  MessageFederate , objects can be used in all functions that take a  Federate ,  MessageFederate  or  ValueFederate  object as an argument  Arguments   fedName : a string with the name of the federate, can be NULL or an empty string to pull the default name from fi  fi : the  FederateInfo  object that contains details on the federate   Returns   an opaque  ValueFederate , nullptr if the object creation failed   source  #  HELICS.helicsCreateCombinationFederateFromConfig     Method .  helicsCreateCombinationFederateFromConfig ( configFile :: String )   -   HELICS . CombinationFederate   Create a  CombinationFederate  from a JSON file or JSON string  CombinationFederate  are both  ValueFederate  and  MessageFederate , objects can be used in all functions that take a  Federate ,  MessageFederate  or  ValueFederate  object as an argument  Arguments   configFile :  a JSON file or a JSON string or TOML file that contains setup and configuration information   Returns   an opaque  CombinationFederate   source  #  HELICS.helicsCreateCore     Method .  helicsCreateCore ( kind :: String ,   name :: String ,   initString :: String )   -   HELICS . Core   Create a core object  Arguments   type : the type of the core to create  name : the name of the core , may be a nullptr or empty string to have a name automatically assigned  initString : an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" or the number of federates or the address   Returns   a  Core  object if the core is invalid err will contain some indication   source  #  HELICS.helicsCreateCoreFromArgs     Method .  helicsCreateCoreFromArgs ( kind :: String ,   name :: String ,   argc :: Int64 ,   argv :: Array { String , 1 })   -   HELICS . Core   source  #  HELICS.helicsCreateFederateInfo     Method .  helicsCreateFederateInfo ()   -   HELICS . FederateInfo   Create a  FederateInfo  object for specifying federate information when constructing a federate  Returns   a  FederateInfo  object which is a reference to the created object   source  #  HELICS.helicsCreateMessageFederate     Method .  helicsCreateMessageFederate ( fedName :: String ,   fi :: HELICS . FederateInfo )   -   HELICS . MessageFederate   Create a  MessageFederate  from a  FederateInfo  object  MessageFederate  objects can be used in all functions that take a  MessageFederate  or  Federate  object as an argument  Arguments   fedName : the name of the federate to create  fi : the  FederateInfo  object that contains details on the federate   Returns   an opaque  MessageFederate   source  #  HELICS.helicsCreateMessageFederateFromConfig     Method .  helicsCreateMessageFederateFromConfig ( configFile :: String )   -   HELICS . MessageFederate   Create a  MessageFederate  from a JSON file or JSON string or TOML file  MessageFederate  objects can be used in all functions that take a  MessageFederate  or  Federate  object as an argument  Arguments   configFile :  a Config(JSON,TOML) file or a JSON string that contains setup and configuration information   Returns   an opaque  MessageFederate   source  #  HELICS.helicsCreateQuery     Method .  helicsCreateQuery ( target :: String ,   query :: String )   -   HELICS . Query   Create a  Query  a  Query  consists of a target and query string  Arguments   target : the name of the target to query  query : the query string to make of the target   source  #  HELICS.helicsCreateValueFederate     Method .  helicsCreateValueFederate ( fedName :: String ,   fi :: HELICS . FederateInfo )   -   HELICS . ValueFederate   Create a value federate from a  FederateInfo  object  Federate  objects can be used in all functions that take a  Federate  object as an argument  Arguments   fedName : the name of the federate to create, can NULL or an empty string to use the default name from fi or an assigned name  fi : the  FederateInfo  object that contains details on the federate   Returns   an opaque value  Federate   source  #  HELICS.helicsCreateValueFederateFromConfig     Method .  helicsCreateValueFederateFromConfig ( configFile :: String )   -   HELICS . ValueFederate   Create a value federate from a JSON file, JSON string, or TOML file  Federate  objects can be used in all functions that take a  Federate  object as an argument  Arguments   configFile :  a JSON file or a JSON string or TOML file that contains setup and configuration information   Returns   an opaque value  Federate   source  #  HELICS.helicsEndpointGetDefaultDestination     Method .  helicsEndpointGetDefaultDestination ( endpoint :: HELICS . Endpoint )   -   String   source  #  HELICS.helicsEndpointGetInfo     Method .  helicsEndpointGetInfo ( _end :: HELICS . Endpoint )   -   String   source  #  HELICS.helicsEndpointGetMessage     Method .  helicsEndpointGetMessage ( endpoint :: HELICS . Endpoint )   -   HELICS . Message   source  #  HELICS.helicsEndpointGetName     Method .  helicsEndpointGetName ( endpoint :: HELICS . Endpoint )   -   String   source  #  HELICS.helicsEndpointGetOption     Method .  helicsEndpointGetOption ( _end :: HELICS . Endpoint ,   option :: Int64 )   -   Bool   source  #  HELICS.helicsEndpointGetType     Method .  helicsEndpointGetType ( endpoint :: HELICS . Endpoint )   -   String   source  #  HELICS.helicsEndpointHasMessage     Method .  helicsEndpointHasMessage ( endpoint :: HELICS . Endpoint )   -   Bool   source  #  HELICS.helicsEndpointPendingMessages     Method .  helicsEndpointPendingMessages ( endpoint :: HELICS . Endpoint )   -   Int64   source  #  HELICS.helicsEndpointSendEventRaw     Method .  helicsEndpointSendEventRaw ( endpoint :: HELICS . Endpoint ,   dest :: String ,   data :: String ,   time :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsEndpointSendMessage     Method .  helicsEndpointSendMessage ( endpoint :: HELICS . Endpoint ,   message :: HELICS . Message )   source  #  HELICS.helicsEndpointSendMessageRaw     Method .  helicsEndpointSendMessageRaw ( endpoint :: HELICS . Endpoint ,   dest :: String ,   data :: String )   source  #  HELICS.helicsEndpointSetDefaultDestination     Method .  helicsEndpointSetDefaultDestination ( endpoint :: HELICS . Endpoint ,   dest :: String )   source  #  HELICS.helicsEndpointSetInfo     Method .  helicsEndpointSetInfo ( _end :: HELICS . Endpoint ,   info :: String )   source  #  HELICS.helicsEndpointSetOption     Method .  helicsEndpointSetOption ( _end :: HELICS . Endpoint ,   option :: Int64 ,   value :: Bool )   source  #  HELICS.helicsEndpointSubscribe     Method .  helicsEndpointSubscribe ( endpoint :: HELICS . Endpoint ,   key :: String )   source  #  HELICS.helicsErrorClear     Method .  helicsErrorClear ( err :: HELICS . Lib . helics_error )   Clear an error object  source  #  HELICS.helicsErrorInitialize     Method .  helicsErrorInitialize ()   -   HELICS . Lib . helics_error   Return an initialized error object  source  #  HELICS.helicsFederateClone     Method .  helicsFederateClone ( fed :: T : HELICS . Federate )   -   Union { CombinationFederate ,   MessageFederate ,   ValueFederate }   Create a new reference to an existing federate  this will create a new  Federate  object that references the existing federate it must be freed as well  Arguments   fed : an existing  Federate   Returns   a new reference to the same federate   source  #  HELICS.helicsFederateDestroy     Method .  helicsFederateDestroy ( fed :: HELICS . Federate )   Disconnect and free a broker  source  #  HELICS.helicsFederateEnterExecutingMode     Method .  helicsFederateEnterExecutingMode ( fed :: HELICS . Federate )   Request that the federate enter the Execution mode  this call is blocking until granted entry by the core object for an asynchronous alternative call  helicsFederateEnterExecutingModeAsync  on return from this call the federate will be at time 0.  Arguments   fed : a federate to change modes   source  #  HELICS.helicsFederateEnterExecutingModeAsync     Method .  helicsFederateEnterExecutingModeAsync ( fed :: HELICS . Federate )   Request that the federate enter the Execution mode  this call is non-blocking and will return immediately. Call  helicsFederateEnterExecutingModeComplete  to finish the call sequence.  Arguments   fed : the federate object to complete the call   source  #  HELICS.helicsFederateEnterExecutingModeComplete     Method .  helicsFederateEnterExecutingModeComplete ( fed :: HELICS . Federate )   Complete the call to  helicsFederateEnterExecutingModeAsync  Arguments   fed : the federate object to complete the call   source  #  HELICS.helicsFederateEnterExecutingModeIterative     Method .  helicsFederateEnterExecutingModeIterative ( fed :: HELICS . Federate ,   iterate :: Union { Int64 ,   helics_iteration_request })   -   HELICS . Lib . helics_iteration_result   Request an iterative time  this call allows for finer grain control of the iterative process then  helicsFederateRequestTime  it takes a time and iteration request and return a time and iteration status.  Arguments   fed : the federate to make the request of  iterate : the requested iteration mode   Returns   an iteration structure with field containing the time and iteration status   source  #  HELICS.helicsFederateEnterExecutingModeIterativeAsync     Method .  helicsFederateEnterExecutingModeIterativeAsync ( fed :: HELICS . Federate ,   iterate :: Union { Int64 ,   helics_iteration_request })   source  #  HELICS.helicsFederateEnterExecutingModeIterativeComplete     Method .  helicsFederateEnterExecutingModeIterativeComplete ( fed :: HELICS . Federate )   -   HELICS . Lib . helics_iteration_result   Complete the asynchronous iterative call into ExecutionModel  Arguments   fed : the federate to make the request of   Returns   an iteration object containing the iteration time and iteration_status   source  #  HELICS.helicsFederateEnterInitializingMode     Method .  helicsFederateEnterInitializingMode ( fed :: HELICS . Federate )   Enter the initialization state of a federate  the initialization state allows initial values to be set and received if the iteration is requested on entry to the execution state. This is a blocking call and will block until the core allows it to proceed.  Arguments   fed : the federate to operate on   source  #  HELICS.helicsFederateEnterInitializingModeAsync     Method .  helicsFederateEnterInitializingModeAsync ( fed :: HELICS . Federate )   Non blocking alternative to  helicsFederateEnterInitializingMode . The function  helicsFederateFinalize  must be called to finish the operation  Arguments   fed : the federate to operate on   source  #  HELICS.helicsFederateEnterInitializingModeComplete     Method .  helicsFederateEnterInitializingModeComplete ( fed :: HELICS . Federate )   Finalize the entry to initialize mode that was initiated with  helicsFederateEnterInitializingModeAsync  Arguments   fed : the federate desiring to complete the initialization step function   source  #  HELICS.helicsFederateFinalize     Method .  helicsFederateFinalize ( fed :: HELICS . Federate )   Finalize the federate this function halts all communication in the federate and disconnects it from the core  source  #  HELICS.helicsFederateFinalizeAsync     Method .  helicsFederateFinalizeAsync ( fed :: HELICS . Federate )   Finalize the federate in an async call  source  #  HELICS.helicsFederateFinalizeComplete     Method .  helicsFederateFinalizeComplete ( fed :: HELICS . Federate )   Complete the asynchronous finalize call  source  #  HELICS.helicsFederateFree     Method .  helicsFederateFree ( fed :: HELICS . Federate )   Release the memory associated withe a federate  source  #  HELICS.helicsFederateGetCoreObject     Method .  helicsFederateGetCoreObject ( fed :: HELICS . Federate )   -   HELICS . Core   Get the core object associated with a federate  Arguments   fed : a federate object   Returns   a core object, nullptr if invalid   source  #  HELICS.helicsFederateGetCurrentTime     Method .  helicsFederateGetCurrentTime ( fed :: HELICS . Federate )   -   Float64   Get the current time of the federate  Arguments   fed : the  Federate  to query   Returns   the current time of the federate   source  #  HELICS.helicsFederateGetEndpoint     Method .  helicsFederateGetEndpoint ( fed :: HELICS . Federate ,   name :: String )   -   HELICS . Endpoint   source  #  HELICS.helicsFederateGetEndpointByIndex     Method .  helicsFederateGetEndpointByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   -   HELICS . Endpoint   source  #  HELICS.helicsFederateGetEndpointCount     Method .  helicsFederateGetEndpointCount ( fed :: HELICS . Federate )   -   Int64   source  #  HELICS.helicsFederateGetFilter     Method .  helicsFederateGetFilter ( fed :: HELICS . Federate ,   name :: String )   -   HELICS . Filter   source  #  HELICS.helicsFederateGetFilterByIndex     Method .  helicsFederateGetFilterByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   -   HELICS . Filter   source  #  HELICS.helicsFederateGetFilterCount     Method .  helicsFederateGetFilterCount ( fed :: HELICS . Federate )   -   Int64   source  #  HELICS.helicsFederateGetFlagOption     Method .  helicsFederateGetFlagOption ( fed :: HELICS . Federate ,   flag :: Int64 )   -   Bool   Get a flag value for a federate  Arguments   fed : the federate to get the flag for  flag : the flag to query   Returns   the value of the flag   source  #  HELICS.helicsFederateGetInput     Method .  helicsFederateGetInput ( fed :: HELICS . Federate ,   key :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateGetInputByIndex     Method .  helicsFederateGetInputByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   -   HELICS . Subscription   source  #  HELICS.helicsFederateGetInputCount     Method .  helicsFederateGetInputCount ( fed :: HELICS . Federate )   -   Int64   source  #  HELICS.helicsFederateGetIntegerProperty     Method .  helicsFederateGetIntegerProperty ( fed :: HELICS . Federate ,   intProperty :: Union { Int64 ,   helics_handle_options })   -   Int32   Set the logging level for the federate  debug and trace only do anything if they were enabled in the compilation  Arguments   fed : the federate to get the flag for  intProperty : a code for the property to set  HELICS_HANDLE_OPTIONS   Returns   the value of the property   source  #  HELICS.helicsFederateGetMessage     Method .  helicsFederateGetMessage ( fed :: HELICS . Federate )   -   HELICS . Message   source  #  HELICS.helicsFederateGetName     Method .  helicsFederateGetName ( fed :: HELICS . Federate )   -   String   Get the name of the federate  Arguments   fed : the  Federate  to query   Returns   a string with the name   source  #  HELICS.helicsFederateGetPublication     Method .  helicsFederateGetPublication ( fed :: HELICS . Federate ,   key :: String )   -   HELICS . Publication   source  #  HELICS.helicsFederateGetPublicationByIndex     Method .  helicsFederateGetPublicationByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   -   HELICS . Publication   source  #  HELICS.helicsFederateGetPublicationCount     Method .  helicsFederateGetPublicationCount ( fed :: HELICS . Federate )   -   Int64   source  #  HELICS.helicsFederateGetState     Method .  helicsFederateGetState ( fed :: HELICS . Federate )   -   HELICS . Lib . helics_federate_state   Get the current state of a federate  Arguments   fed : the  Federate  to query   Returns   state the resulting state if void return helics_ok   source  #  HELICS.helicsFederateGetSubscription     Method .  helicsFederateGetSubscription ( fed :: HELICS . Federate ,   key :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateGetTimeProperty     Method .  helicsFederateGetTimeProperty ( fed :: HELICS . Federate ,   timeProperty :: Union { Int64 ,   helics_properties })   -   Float64   Get the current value of a time based property in a federate  Arguments   fed : the federate query  timeProperty : the property to query   source  #  HELICS.helicsFederateHasMessage     Method .  helicsFederateHasMessage ( fed :: HELICS . Federate )   -   Bool   source  #  HELICS.helicsFederateInfoClone     Method .  helicsFederateInfoClone ( fi :: HELICS . FederateInfo )   -   HELICS . FederateInfo   Create a  FederateInfo  object from an existing one and clone the information  Arguments   fi : a  FederateInfo  object to duplicate   Returns   a helics federate info object which is a reference to the created object   source  #  HELICS.helicsFederateInfoFree     Method .  helicsFederateInfoFree ( fi :: HELICS . FederateInfo )   Delete the memory associated with a  FederateInfo  object  source  #  HELICS.helicsFederateInfoLoadFromArgs     Method .  helicsFederateInfoLoadFromArgs ( fi :: HELICS . FederateInfo ,   argc :: Int64 ,   argv :: Array { String , 1 })   Load a  FederateInfo  from command line arguments  Arguments   fi : a  FederateInfo  object  argc : the number of command line arguments  argv : an array of strings from the command line   source  #  HELICS.helicsFederateInfoSetBroker     Method .  helicsFederateInfoSetBroker ( fi :: HELICS . FederateInfo ,   broker :: HELICS . Broker )   Set the name or connection information for a broker  this is only used if the core is automatically created, the broker information will be transferred to the core for connection  Arguments   fi : the  FederateInfo  object to alter  broker : a string which defined the connection information for a broker either a name or an address   source  #  HELICS.helicsFederateInfoSetBrokerPort     Method .  helicsFederateInfoSetBrokerPort ( fi :: HELICS . FederateInfo ,   brokerPort :: Int64 )   Set the port to use for the broker  this is only used if the core is automatically created, the broker information will be transferred to the core for connection this will only be useful for network broker connections  Arguments   fi : the  FederateInfo  object to alter  brokerPort : the integer port number to use for connection with a broker   source  #  HELICS.helicsFederateInfoSetCoreInitString     Method .  helicsFederateInfoSetCoreInitString ( fi :: HELICS . FederateInfo ,   coreInit :: String )   Set the initialization string for the core usually in the form of command line arguments  Arguments   fi : the  FederateInfo  object to alter  coreInit : a string with the core initialization strings   source  #  HELICS.helicsFederateInfoSetCoreName     Method .  helicsFederateInfoSetCoreName ( fi :: HELICS . FederateInfo ,   corename :: String )   Set the name of the core to link to for a federate  Arguments   fi : the  FederateInfo  object to alter  corename : the identifier for a core to link to   source  #  HELICS.helicsFederateInfoSetCoreType     Method .  helicsFederateInfoSetCoreType ( fi :: HELICS . FederateInfo ,   coretype :: Union { Int64 ,   helics_core_type })   Set the core type by integer code  valid values available by definitions in api-data.h  Arguments   fi : the  FederateInfo  object to alter  coretype : an numerical code for a core type see /ref helics core type   source  #  HELICS.helicsFederateInfoSetCoreTypeFromString     Method .  helicsFederateInfoSetCoreTypeFromString ( fi :: HELICS . FederateInfo ,   coretype :: String )   Set the core type from a string  Arguments   fi : the  FederateInfo  object to alter  coretype : a string naming a core type   source  #  HELICS.helicsFederateInfoSetFlagOption     Method .  helicsFederateInfoSetFlagOption ( fi :: HELICS . FederateInfo ,   flag :: Union { Int64 ,   helics_federate_flags },   value :: Bool )   Set a flag in the info structure  valid flags are available  HELICS_FEDERATE_FLAGS  Arguments   fi : the  FederateInfo  object to alter  flag : a numerical index for a flag  value : the desired value of the flag  true  or  false   source  #  HELICS.helicsFederateInfoSetIntegerProperty     Method .  helicsFederateInfoSetIntegerProperty ( fi :: HELICS . FederateInfo ,   intProperty :: Union { Int64 ,   helics_properties },   propertyValue :: Int64 )   source  #  HELICS.helicsFederateInfoSetLocalPort     Method .  helicsFederateInfoSetLocalPort ( fi :: HELICS . FederateInfo ,   localPort :: Int64 )   Set the local port to use  this is only used if the core is automatically created, the port information will be transferred to the core for connection  Arguments   fi : the  FederateInfo  object to alter  localPort : a string with the port information to use as the local server port can be a number or \"auto\" or \"os_local\"   source  #  HELICS.helicsFederateInfoSetSeparator     Method .  helicsFederateInfoSetSeparator ( fi :: HELICS . FederateInfo ,   separator :: Char )   Set the separator character in the info structure  the separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName  Arguments   fi : the  FederateInfo  object to alter  separator : the character to use as a separator   source  #  HELICS.helicsFederateInfoSetTimeProperty     Method .  helicsFederateInfoSetTimeProperty ( fi :: HELICS . FederateInfo ,   timeProperty :: Union { Int64 ,   helics_properties },   propertyValue :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsFederateIsAsyncOperationCompleted     Method .  helicsFederateIsAsyncOperationCompleted ( fed :: HELICS . Federate )   -   Bool   Check if the current Asynchronous operation has completed  Arguments   fed : the federate to operate on   Returns   false  if not completed,  true  if completed   source  #  HELICS.helicsFederateIsValid     Method .  helicsFederateIsValid ( fed :: HELICS . Federate )   -   Bool   Check if a federate_object is valid  Returns   true  if the federate is a valid active federate,  false  otherwise   source  #  HELICS.helicsFederatePendingMessages     Method .  helicsFederatePendingMessages ( fed :: HELICS . Federate )   -   Int64   source  #  HELICS.helicsFederateRegisterCloningFilter     Method .  helicsFederateRegisterCloningFilter ( fed :: HELICS . Federate ,   deliveryEndpoint :: String )   -   HELICS . Filter   source  #  HELICS.helicsFederateRegisterEndpoint     Method .  helicsFederateRegisterEndpoint ( fed :: HELICS . Federate ,   name :: String ,   kind :: String )   -   HELICS . Endpoint   source  #  HELICS.helicsFederateRegisterFilter     Method .  helicsFederateRegisterFilter ( fed :: HELICS . Federate ,   kind :: Union { Int64 ,   helics_filter_type },   name :: String )   -   HELICS . Filter   source  #  HELICS.helicsFederateRegisterGlobalCloningFilter     Method .  helicsFederateRegisterGlobalCloningFilter ( fed :: HELICS . Federate ,   deliveryEndpoint :: String )   -   HELICS . Filter   source  #  HELICS.helicsFederateRegisterGlobalEndpoint     Method .  helicsFederateRegisterGlobalEndpoint ( fed :: HELICS . Federate ,   name :: String ,   kind :: String )   -   HELICS . Endpoint   source  #  HELICS.helicsFederateRegisterGlobalFilter     Method .  helicsFederateRegisterGlobalFilter ( fed :: HELICS . Federate ,   kind :: Union { Int64 ,   helics_filter_type },   name :: String )   -   HELICS . Filter   source  #  HELICS.helicsFederateRegisterGlobalInput     Function .  helicsFederateRegisterGlobalInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type })   -   HELICS . Subscription  helicsFederateRegisterGlobalInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type },   units :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterGlobalPublication     Function .  helicsFederateRegisterGlobalPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type })   -   HELICS . Publication  helicsFederateRegisterGlobalPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type },   units :: String )   -   HELICS . Publication   source  #  HELICS.helicsFederateRegisterGlobalTypeInput     Function .  helicsFederateRegisterGlobalTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   -   HELICS . Subscription  helicsFederateRegisterGlobalTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterGlobalTypePublication     Function .  helicsFederateRegisterGlobalTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   -   HELICS . Publication  helicsFederateRegisterGlobalTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   -   HELICS . Publication   source  #  HELICS.helicsFederateRegisterInput     Function .  helicsFederateRegisterInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type })   -   HELICS . Subscription  helicsFederateRegisterInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type },   units :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterInterfaces     Method .  helicsFederateRegisterInterfaces ( fed :: HELICS . Federate ,   file :: String )   Load interfaces from a file  Arguments   fed : the federate to which to load interfaces  file : the name of a file to load the interfaces from either JSON, or TOML   source  #  HELICS.helicsFederateRegisterPublication     Function .  helicsFederateRegisterPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type })   -   HELICS . Publication  helicsFederateRegisterPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   helics_data_type },   units :: String )   -   HELICS . Publication   source  #  HELICS.helicsFederateRegisterSubscription     Function .  helicsFederateRegisterSubscription ( fed :: HELICS . Federate ,   key :: String )   -   HELICS . Subscription  helicsFederateRegisterSubscription ( fed :: HELICS . Federate ,   key :: String ,   units :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterTypeInput     Function .  helicsFederateRegisterTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   -   HELICS . Subscription  helicsFederateRegisterTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   -   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterTypePublication     Function .  helicsFederateRegisterTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   -   HELICS . Publication  helicsFederateRegisterTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   -   HELICS . Publication   source  #  HELICS.helicsFederateRequestNextStep     Method .  helicsFederateRequestNextStep ( fed :: HELICS . Federate )   -   Float64   Request the next time step for federate execution  feds should have setup the period or minDelta for this to work well but it will request the next time step which is the current time plus the minimum time step.  Arguments   fed : the federate to make the request of   Returns   the time granted to the federate   source  #  HELICS.helicsFederateRequestTime     Method .  helicsFederateRequestTime ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 })   -   Float64   Request the next time for federate execution  Arguments   fed : the federate to make the request of  requestTime : the next requested time   Returns   the time granted to the federate   invalid   source  #  HELICS.helicsFederateRequestTimeAsync     Method .  helicsFederateRequestTimeAsync ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 })   Request the next time for federate execution in an asynchronous call Call  helicsFederateRequestTimeComplete  to finish the call  Arguments   fed : the federate to make the request of  requestTime : the next requested time   source  #  HELICS.helicsFederateRequestTimeComplete     Method .  helicsFederateRequestTimeComplete ( fed :: HELICS . Federate )   -   Float64   Complete an asynchronous requestTime call  Arguments   fed : the federate to make the request of   Returns   the time granted to the federate   source  #  HELICS.helicsFederateRequestTimeIterative     Method .  helicsFederateRequestTimeIterative ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 },   iterate :: Union { Int64 ,   helics_iteration_request })   Request an iterative time  this call allows for finer grain control of the iterative process then  helicsFederateRequestTime  it takes a time and iteration request and return a time and iteration status.  Arguments   fed : the federate to make the request of  requestTime : the next desired time  iterate : the requested iteration mode   Returns   the granted time  the iteration specification of the result   source  #  HELICS.helicsFederateRequestTimeIterativeAsync     Method .  helicsFederateRequestTimeIterativeAsync ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 },   iterate :: Union { Int64 ,   helics_iteration_request })   Request an iterative time through an asynchronous call  this call allows for finer grain control of the iterative process then  helicsFederateRequestTime  it takes a time an iteration request and returns a time and iteration status call  helicsFederateRequestTimeIterativeComplete  to finish the process.  Arguments   fed : the federate to make the request of  requestTime : the next desired time  iterate : the requested iteration mode   Returns   a void object with a return code of the result   source  #  HELICS.helicsFederateRequestTimeIterativeComplete     Method .  helicsFederateRequestTimeIterativeComplete ( fed :: HELICS . Federate )   Complete an iterative time request asynchronous call  Arguments   fed : the federate to make the request of   Returns   the granted time  outIterate   the iteration specification of the result   source  #  HELICS.helicsFederateSetFlagOption     Method .  helicsFederateSetFlagOption ( fed :: HELICS . Federate ,   flag :: Int64 ,   flagValue :: Bool )   Set a flag for the federate  Arguments   fed : the federate to alter a flag for  flag : the flag to change  flagValue : the new value of the flag 0 for false !=0 for true   source  #  HELICS.helicsFederateSetGlobal     Method .  helicsFederateSetGlobal ( fed :: HELICS . Federate ,   valueName :: String ,   value :: String )   Set a federation global value through a federate  this overwrites any previous value for this name  Arguments   fed : the federate to set the global through  valueName : the name of the global to set  value : the value of the global   source  #  HELICS.helicsFederateSetIntegerProperty     Method .  helicsFederateSetIntegerProperty ( fed :: HELICS . Federate ,   intProperty :: Union { Int64 ,   helics_properties },   propertyVal :: Int64 )   Set an integer based property of a federate  Arguments   fed : the federate to change the property for  intProperty : the property to set  propertyVal : the value of the property   source  #  HELICS.helicsFederateSetSeparator     Method .  helicsFederateSetSeparator ( fed :: HELICS . Federate ,   separator :: Char )   Set the separator character in a federate  the separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName.  Arguments   fed : the  FederateInfo  object to alter  separator : the character to use as a separator   source  #  HELICS.helicsFederateSetTimeProperty     Method .  helicsFederateSetTimeProperty ( fed :: HELICS . Federate ,   timeProperty :: Union { Int64 ,   helics_properties },   time :: Union { Float64 ,   Int64 })   Set a time based property for a federate  Arguments   fed : the  Federate  set the property for  timeProperty : a integer code for a time property  time : the requested value of the property   source  #  HELICS.helicsFilterAddDeliveryEndpoint     Method .  helicsFilterAddDeliveryEndpoint ( filt :: HELICS . Filter ,   deliveryEndpoint :: String )   source  #  HELICS.helicsFilterAddDestinationTarget     Method .  helicsFilterAddDestinationTarget ( filt :: HELICS . Filter ,   dest :: String )   source  #  HELICS.helicsFilterAddSourceTarget     Method .  helicsFilterAddSourceTarget ( filt :: HELICS . Filter ,   source :: String )   source  #  HELICS.helicsFilterGetInfo     Method .  helicsFilterGetInfo ( filt :: HELICS . Filter )   -   String   source  #  HELICS.helicsFilterGetName     Method .  helicsFilterGetName ( filt :: HELICS . Filter )   -   String   source  #  HELICS.helicsFilterGetOption     Method .  helicsFilterGetOption ( filt :: HELICS . Filter ,   option :: Int64 )   -   Bool   source  #  HELICS.helicsFilterRemoveDeliveryEndpoint     Method .  helicsFilterRemoveDeliveryEndpoint ( filt :: HELICS . Filter ,   deliveryEndpoint :: String )   source  #  HELICS.helicsFilterRemoveTarget     Method .  helicsFilterRemoveTarget ( filt :: HELICS . Filter ,   target :: String )   source  #  HELICS.helicsFilterSet     Method .  helicsFilterSet ( filt :: HELICS . Filter ,   prop :: String ,   val :: Float64 )   source  #  HELICS.helicsFilterSetInfo     Method .  helicsFilterSetInfo ( filt :: HELICS . Filter ,   info :: String )   source  #  HELICS.helicsFilterSetOption     Method .  helicsFilterSetOption ( filt :: HELICS . Filter ,   option :: Int64 ,   value :: Bool )   source  #  HELICS.helicsFilterSetString     Method .  helicsFilterSetString ( filt :: HELICS . Filter ,   prop :: String ,   val :: String )   source  #  HELICS.helicsGetFederateByName     Method .  helicsGetFederateByName ( fedName :: String )   -   HELICS . CombinationFederate   Get an existing  Federate  from a core by name  the federate must have been created by one of the other functions and at least one of the objects referencing the created     federate must still be active in the process  Arguments   fedName : the name of the federate to retrieve   Returns   NULL if no fed is available by that name otherwise a  Federate  with that name   source  #  HELICS.helicsGetOptionIndex     Method .  helicsGetOptionIndex ( val :: String )   -   Int64   Get an option index for use in  helicsPublicationSetOption ,  helicsInputSetOption ,  helicsEndpointSetOption ,  helicsFilterSetOption , and the corresponding get functions  Arguments   val : a string with the option name   Returns   an int with the option index (-1) if not a valid property   source  #  HELICS.helicsGetPropertyIndex     Method .  helicsGetPropertyIndex ( val :: String )   -   Int64   Get a property index for use in  helicsFederateInfoSetFlagOption ,  helicsFederateInfoSetTimeProperty ,  helicsFederateInfoSetIntegerProperty  Arguments   val : a string with the property name   Returns   an int with the property code (-1) if not a valid property   source  #  HELICS.helicsGetVersion     Method .  helicsGetVersion ()   -   String   Get a version string for HELICS  source  #  HELICS.helicsInputAddTarget     Method .  helicsInputAddTarget ( ipt :: HELICS . Subscription ,   target :: String )   source  #  HELICS.helicsInputGetBoolean     Method .  helicsInputGetBoolean ( ipt :: HELICS . Subscription )   -   Bool   source  #  HELICS.helicsInputGetChar     Method .  helicsInputGetChar ( ipt :: HELICS . Subscription )   -   Char   source  #  HELICS.helicsInputGetComplex     Method .  helicsInputGetComplex ( ipt :: HELICS . Subscription )   -   Complex { Float64 }   source  #  HELICS.helicsInputGetComplexObject     Method .  helicsInputGetComplexObject ( ipt :: HELICS . Subscription )   -   Complex { Float64 }   source  #  HELICS.helicsInputGetDouble     Method .  helicsInputGetDouble ( ipt :: HELICS . Subscription )   -   Float64   source  #  HELICS.helicsInputGetInfo     Method .  helicsInputGetInfo ( inp :: HELICS . Subscription )   -   String   source  #  HELICS.helicsInputGetInteger     Method .  helicsInputGetInteger ( ipt :: HELICS . Subscription )   -   Int64   source  #  HELICS.helicsInputGetKey     Method .  helicsInputGetKey ( ipt :: HELICS . Subscription )   -   String   source  #  HELICS.helicsInputGetNamedPoint     Method .  helicsInputGetNamedPoint ( ipt :: HELICS . Subscription )   -   Tuple { String , Float64 }   source  #  HELICS.helicsInputGetOption     Method .  helicsInputGetOption ( inp :: HELICS . Subscription ,   option :: Int64 )   -   Bool   source  #  HELICS.helicsInputGetPublicationType     Method .  helicsInputGetPublicationType ( ipt :: HELICS . Subscription )   -   String   source  #  HELICS.helicsInputGetRawValue     Method .  helicsInputGetRawValue ( ipt :: T ,   data :: T )   source  #  HELICS.helicsInputGetRawValueSize     Method .  helicsInputGetRawValueSize ( ipt :: HELICS . Subscription )   -   Int64   source  #  HELICS.helicsInputGetString     Method .  helicsInputGetString ( ipt :: HELICS . Subscription )   -   String   source  #  HELICS.helicsInputGetStringSize     Method .  helicsInputGetStringSize ( ipt :: HELICS . Subscription )   -   Int64   source  #  HELICS.helicsInputGetTime     Method .  helicsInputGetTime ( ipt :: HELICS . Subscription )   -   Float64   source  #  HELICS.helicsInputGetType     Method .  helicsInputGetType ( ipt :: HELICS . Subscription )   -   String   source  #  HELICS.helicsInputGetUnits     Method .  helicsInputGetUnits ( ipt :: HELICS . Subscription )   -   String   source  #  HELICS.helicsInputGetVector     Method .  helicsInputGetVector ( ipt :: HELICS . Subscription )   -   Array { Float64 , 1 }   source  #  HELICS.helicsInputGetVectorSize     Method .  helicsInputGetVectorSize ( ipt :: HELICS . Subscription )   -   Int64   source  #  HELICS.helicsInputIsUpdated     Method .  helicsInputIsUpdated ( ipt :: HELICS . Subscription )   -   Bool   source  #  HELICS.helicsInputLastUpdateTime     Method .  helicsInputLastUpdateTime ( ipt :: HELICS . Subscription )   -   Float64   source  #  HELICS.helicsInputSetDefaultBoolean     Method .  helicsInputSetDefaultBoolean ( ipt :: HELICS . Subscription ,   val :: Bool )   source  #  HELICS.helicsInputSetDefaultChar     Method .  helicsInputSetDefaultChar ( ipt :: HELICS . Subscription ,   val :: Char )   source  #  HELICS.helicsInputSetDefaultComplex     Method .  helicsInputSetDefaultComplex ( ipt :: HELICS . Subscription ,   c :: Complex { Float64 })   source  #  HELICS.helicsInputSetDefaultDouble     Method .  helicsInputSetDefaultDouble ( ipt :: HELICS . Subscription ,   val :: Float64 )   source  #  HELICS.helicsInputSetDefaultInteger     Method .  helicsInputSetDefaultInteger ( ipt :: HELICS . Subscription ,   val :: Int64 )   source  #  HELICS.helicsInputSetDefaultNamedPoint     Method .  helicsInputSetDefaultNamedPoint ( ipt :: HELICS . Subscription ,   str :: String ,   val :: Float64 )   source  #  HELICS.helicsInputSetDefaultRaw     Method .  helicsInputSetDefaultRaw ( ipt :: HELICS . Subscription ,   data :: Any )   source  #  HELICS.helicsInputSetDefaultString     Method .  helicsInputSetDefaultString ( ipt :: HELICS . Subscription ,   str :: String )   source  #  HELICS.helicsInputSetDefaultTime     Method .  helicsInputSetDefaultTime ( ipt :: HELICS . Subscription ,   val :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsInputSetDefaultVector     Method .  helicsInputSetDefaultVector ( ipt :: HELICS . Subscription ,   vectorInput :: Array { Float64 , 1 })   source  #  HELICS.helicsInputSetInfo     Method .  helicsInputSetInfo ( inp :: HELICS . Subscription ,   info :: String )   source  #  HELICS.helicsInputSetOption     Method .  helicsInputSetOption ( inp :: HELICS . Subscription ,   option :: Int64 ,   value :: Bool )   source  #  HELICS.helicsIsCoreTypeAvailable     Method .  helicsIsCoreTypeAvailable ( kind :: String )   -   Bool   Returns true if core/broker type specified is available in current compilation.  Arguments   type : a string representing a core type   Returns   a  Bool   possible options include \"test\",\"zmq\",\"udp\",\"ipc\",\"interprocess\",\"tcp\",\"default\", \"mpi\"  source  #  HELICS.helicsPublicationAddTarget     Method .  helicsPublicationAddTarget ( pub :: HELICS . Publication ,   target :: String )   source  #  HELICS.helicsPublicationGetInfo     Method .  helicsPublicationGetInfo ( pub :: HELICS . Publication )   -   String   source  #  HELICS.helicsPublicationGetKey     Method .  helicsPublicationGetKey ( pub :: HELICS . Publication )   -   String   source  #  HELICS.helicsPublicationGetOption     Method .  helicsPublicationGetOption ( pub :: HELICS . Publication ,   option :: Int64 )   -   Bool   source  #  HELICS.helicsPublicationGetType     Method .  helicsPublicationGetType ( pub :: HELICS . Publication )   -   String   source  #  HELICS.helicsPublicationGetUnits     Method .  helicsPublicationGetUnits ( pub :: HELICS . Publication )   -   String   source  #  HELICS.helicsPublicationPublishBoolean     Method .  helicsPublicationPublishBoolean ( pub :: HELICS . Publication ,   val :: Bool )   source  #  HELICS.helicsPublicationPublishChar     Method .  helicsPublicationPublishChar ( pub :: HELICS . Publication ,   val :: Char )   source  #  HELICS.helicsPublicationPublishComplex     Method .  helicsPublicationPublishComplex ( pub :: HELICS . Publication ,   c :: Complex { Float64 })   source  #  HELICS.helicsPublicationPublishDouble     Method .  helicsPublicationPublishDouble ( pub :: HELICS . Publication ,   val :: Float64 )   source  #  HELICS.helicsPublicationPublishInteger     Method .  helicsPublicationPublishInteger ( pub :: HELICS . Publication ,   val :: Int64 )   source  #  HELICS.helicsPublicationPublishNamedPoint     Method .  helicsPublicationPublishNamedPoint ( pub :: HELICS . Publication ,   str :: String ,   val :: Float64 )   source  #  HELICS.helicsPublicationPublishRaw     Method .  helicsPublicationPublishRaw ( pub :: HELICS . Publication ,   data :: Any )   source  #  HELICS.helicsPublicationPublishString     Method .  helicsPublicationPublishString ( pub :: HELICS . Publication ,   str :: String )   source  #  HELICS.helicsPublicationPublishTime     Method .  helicsPublicationPublishTime ( pub :: HELICS . Publication ,   val :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsPublicationPublishVector     Method .  helicsPublicationPublishVector ( pub :: HELICS . Publication ,   vectorInput :: Array { Float64 , 1 })   source  #  HELICS.helicsPublicationSetInfo     Method .  helicsPublicationSetInfo ( pub :: HELICS . Publication ,   info :: String )   source  #  HELICS.helicsPublicationSetOption     Method .  helicsPublicationSetOption ( pub :: HELICS . Publication ,   option :: Int64 ,   val :: Bool )   source  #  HELICS.helicsQueryBrokerExecute     Method .  helicsQueryBrokerExecute ( query :: HELICS . Query ,   broker :: HELICS . Broker )   -   String   Execute a  Query  directly on a broker  the call will block until the  Query  finishes which may require communication or other delays  Arguments   query : the  Query  to use in the query  broker : the broker to send the  Query  to   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if fed or  Query  is an invalid object, the return string will be \"#invalid\" if the  Query  itself was invalid  source  #  HELICS.helicsQueryCoreExecute     Method .  helicsQueryCoreExecute ( query :: HELICS . Query ,   core :: HELICS . Core )   -   String   Execute a  Query  directly on a core  the call will block until the  Query  finishes which may require communication or other delays  Arguments   query : the  Query  to use in the query  core : the core to send the  Query  to   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if fed or  Query  is an invalid object, the return string will be \"#invalid\" if the  Query  itself was invalid  source  #  HELICS.helicsQueryExecute     Method .  helicsQueryExecute ( query :: HELICS . Query ,   fed :: HELICS . Federate )   -   String   Execute a query  the call will block until the  Query  finishes which may require communication or other delays  Arguments   query : the  Query  to use in the query  fed : a federate to send the  Query  through   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if fed or  Query  is an invalid object, the return string will be \"#invalid\" if the  Query  itself was invalid  source  #  HELICS.helicsQueryExecuteAsync     Method .  helicsQueryExecuteAsync ( query :: HELICS . Query ,   fed :: HELICS . Federate )   Execute a  Query  in a non-blocking call  Arguments   query : the  Query  to use in the query  fed : a federate to send the  Query  through   source  #  HELICS.helicsQueryExecuteComplete     Method .  helicsQueryExecuteComplete ( query :: HELICS . Query )   -   String   Complete the return from a  Query  called with  helicsQueryExecuteAsync  the function will block until the  Query  completes  helicsQueryIsCompleted  can be called to determine if a  Query  has completed or not.  Arguments   query : the  Query  to complete execution of   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if  Query  is an invalid object  source  #  HELICS.helicsQueryFree     Method .  helicsQueryFree ( query :: HELICS . Query )   Free the memory associated with a  Query  source  #  HELICS.helicsQueryIsCompleted     Method .  helicsQueryIsCompleted ( query :: HELICS . Query )   -   Bool   Check if an asynchronously executed  Query  has completed  this function should usually be called after a QueryExecuteAsync function has been called.  Arguments   query : the  Query  to check if completed   Returns   will return  true  if an asynchronous  Query  has complete or a regular  Query  call was made with a result and  false  if an asynchronous  Query  has not completed or is invalid   source  #  HELICS.helicsSubscriptionGetKey     Method .  helicsSubscriptionGetKey ( ipt :: HELICS . Subscription )   -   String   source", 
            "title": "API"
        }
    ]
}
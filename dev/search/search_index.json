{
    "docs": [
        {
            "location": "/",
            "text": "HELICS.jl\n\n\n \n \n \n \n \n\n\nHELICS.jl\n is a cross-platform Julia wrapper around the \nHELICS\n library.\n\n\nThis package is now available for Windows, Mac, and Linux.\n\n\n\n\nDocumentation\n\n\nThe documentation for the development latest of this package is \nhere\n.\n\n\n\n\nInstallation\n\n\nUse the Julia package manager to install HELICS.jl\n\n\njulia\n>\n \n]\n\n\n(\nv1\n.\n1\n)\n>\n \nadd\n \nHELICS\n\n\n\n\n\n\nOpen the package manager REPL (using \n]\n)\n\n\nTo install the latest development version, use the following from within Julia:\n\n\n(\nv1\n.\n1\n)\n \npkg\n>\n \nadd\n \nHELICS\n#master\n\n\n\n\n\n\nThis package includes HELICS as a library. You do not have to install HELICS separately.\n\n\nNote that this should work on 64-bit Windows, Mac and Linux systems.\n\n\nIf you wish to develop \nHELICS.jl\n you may want to use the following:\n\n\n(\nv1\n.\n1\n)\n \npkg\n>\n \ndev\n \nHELICS\n\n\n\n\n\n\nYou can also get a specific version,\n\n\n(\nv1\n.\n1\n)\n \npkg\n>\n \nadd\n \nHELICS\n#33c98625\n\n\n\n\n\n\nor specific branch,\n\n\n(\nv1\n.\n1\n)\n \npkg\n>\n \nadd\n \nHELICS\n#kd/some-new-feature\n\n\n\n\n\n\nif these features haven't been merged to \nmaster\n yet.\n\n\n\n\nTroubleshooting\n\n\nThis package interfaces with HELICS, so a good understanding of HELICS will help troubleshooting. There are plenty of useful resources located \nhere\n.\n\n\nIf you are having issues using this Julia interface, feel free to open an issue on GitHub \nhere\n.\n\n\n\n\nAcknowledgements\n\n\nThis work was initially developed as an extension to work done as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (\nNREL\n).\n\n\n\n\nRelease\n\n\nHELICS.jl is distributed under the terms of the BSD-3 clause license. All new contributions must be made under this license. \nLICENSE\n\n\nSPDX-License-Identifier: BSD-3-Clause",
            "title": "Home"
        },
        {
            "location": "/#helicsjl",
            "text": "HELICS.jl  is a cross-platform Julia wrapper around the  HELICS  library.  This package is now available for Windows, Mac, and Linux.",
            "title": "HELICS.jl"
        },
        {
            "location": "/#documentation",
            "text": "The documentation for the development latest of this package is  here .",
            "title": "Documentation"
        },
        {
            "location": "/#installation",
            "text": "Use the Julia package manager to install HELICS.jl  julia >   ]  ( v1 . 1 ) >   add   HELICS   Open the package manager REPL (using  ] )  To install the latest development version, use the following from within Julia:  ( v1 . 1 )   pkg >   add   HELICS #master   This package includes HELICS as a library. You do not have to install HELICS separately.  Note that this should work on 64-bit Windows, Mac and Linux systems.  If you wish to develop  HELICS.jl  you may want to use the following:  ( v1 . 1 )   pkg >   dev   HELICS   You can also get a specific version,  ( v1 . 1 )   pkg >   add   HELICS #33c98625   or specific branch,  ( v1 . 1 )   pkg >   add   HELICS #kd/some-new-feature   if these features haven't been merged to  master  yet.",
            "title": "Installation"
        },
        {
            "location": "/#troubleshooting",
            "text": "This package interfaces with HELICS, so a good understanding of HELICS will help troubleshooting. There are plenty of useful resources located  here .  If you are having issues using this Julia interface, feel free to open an issue on GitHub  here .",
            "title": "Troubleshooting"
        },
        {
            "location": "/#acknowledgements",
            "text": "This work was initially developed as an extension to work done as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory ( NREL ).",
            "title": "Acknowledgements"
        },
        {
            "location": "/#release",
            "text": "HELICS.jl is distributed under the terms of the BSD-3 clause license. All new contributions must be made under this license.  LICENSE  SPDX-License-Identifier: BSD-3-Clause",
            "title": "Release"
        },
        {
            "location": "/terminology/",
            "text": "Terminology\n\n\nIllustration of a simple federation consisting of two federates.\n\n\n    +--------------------+               +--------------------+\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n    Federate - \n1\n    \n|\n               \n|\n    Federate - \n2\n    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n                    \n|\n               \n|\n                    \n|\n\n    \n|\n       +-----------------+     +-----------------+       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       \n|\n helicsSharedLib \n|\n     \n|\n helicsSharedLib \n|\n       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       \n|\n                 \n|\n     \n|\n                 \n|\n       \n|\n\n    \n|\n       +---------------x-+     +-x---------------+       \n|\n\n    \n|\n                    \n|\n  ^         ^  \n|\n                    \n|\n\n    +--------------------+  \n|\n         \n|\n  +--------------------+\n                            \n|\n         \n|\n\n                            v         v\n                         +--x---------x--+\n                         \n|\n               \n|\n\n                         \n|\n               \n|\n\n                         \n|\n helics-broker \n|\n\n                         \n|\n               \n|\n\n                         \n|\n               \n|\n\n                         +---------------+\n\n\n\n\n\nA federation, also called a co-simulation consists of multiple federates, or components, agents or actors. These federates exchange data at given points in time. HELICS manages time in a distributed fashion based on how the federation is configured during initialization. If you have a Julia program, and you wish to exchange data with another HELICS federate, you can create a \nFederate\n by calling the \nHELICS.helicsCreateCombinationFederate\n function. This federate must be provided with some information in order to set it up correctly. A \nFederateInfo\n object must be first created in order to set up a \nFederate\n. This \nFederateInfo\n object contains information about what type of communication core is used in HELICS (e.g. \nzmq\n, \nmpi\n, \ntcp\n, \nudp\n), the name of the \nFederate\n, where the \nBroker\n is located, etc. All \nFederate\ns must connect to a \nBroker\n. A \nBroker\n is a separate process that can run on the same machine or a remote machine. You can start a \nBroker\n by running \nHELICS.helicsCreateBroker\n, or running \nhelics_broker -f ${NUMBER_OF_FEDERATES}\n from the command line. Both creating a \nFederateInfo\n and \nBroker\n object can take some initialization options in the form of a \ninitstring\n. See the \nexamples\n folder for more information.\n\n\nAfter creating a \nFederate\n, you will want to create \nPublication\ns and \nSubscription\ns. The strings you choose for these publications and subscriptions must be unique, and they act like topics in a federation. You can send data in the form of values from a \nPublication\n to a \nSubscription\n. Additionally, you can register \nEndpoint\ns as well, which allow you to send \nMessage\ns. \nMessage\ns can be filtered on by any \nFederate\n and can be used to model complex communication interactions.\n\n\nYou can use functions like \nHELICS.helicsPublicationPublishDouble\n to send values at the \"current time\", and use functions like \nHELICS.helicsSubscriptionGetKey\n or \nHELICS.helicsInputGetDouble\n to receive values at the \"current time\". You can use functions like \nHELICS.helicsEndpointSendMessage\n to send messages at the \"current time\", and use functions like \nHELICS.helicsEndpointGetMessage\n functions to receive messages that arrived before the \"current time\".\n\n\nYou can request to move to a time by using the \nHELICS.helicsFederateRequestTime\n function. This function returns a time back that you can safely move to. The time granted will always be less than or equal to the requested time. If you wish to move to the requested time, you may use a while loop until that the granted time is equal to the requested time.\n\n\nfor\n \nt\n \nin\n \n1\n:\n100\n\n\n    \nrequested_time\n \n=\n \nt\n\n\n    \nwhile\n \ngranted_time\n \n<\n \nrequested_time\n\n\n        \ngranted_time\n \n=\n \nhelicsFederateRequestTime\n(\nrequested_time\n)\n\n\n    \nend\n\n\n\n    \n# granted_time here will be equal to requested time\n\n    \n# Send or Receive data here\n\n\n\nend\n\n\n\n\n\n\nHELICS.helicsFederateRequestTime\n is a blocking call. There are other asynchronous request time functions available that allow you to do work while you wait for others to move forward in simulation time.\n\n\nhelicsSharedLib\n is a shared library that is included in the Julia package. This C/C++ shared library interfaces with the broker in other to communicate with other federates.",
            "title": "Terminology"
        },
        {
            "location": "/terminology/#terminology",
            "text": "Illustration of a simple federation consisting of two federates.      +--------------------+               +--------------------+\n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |     Federate -  1      |                 |     Federate -  2      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |                      |                 |                      | \n     |        +-----------------+     +-----------------+        | \n     |         |                   |       |                   |         | \n     |         |                   |       |                   |         | \n     |         |  helicsSharedLib  |       |  helicsSharedLib  |         | \n     |         |                   |       |                   |         | \n     |         |                   |       |                   |         | \n     |        +---------------x-+     +-x---------------+        | \n     |                      |   ^         ^   |                      | \n    +--------------------+   |           |   +--------------------+\n                             |           | \n                            v         v\n                         +--x---------x--+\n                          |                 | \n                          |                 | \n                          |  helics-broker  | \n                          |                 | \n                          |                 | \n                         +---------------+  A federation, also called a co-simulation consists of multiple federates, or components, agents or actors. These federates exchange data at given points in time. HELICS manages time in a distributed fashion based on how the federation is configured during initialization. If you have a Julia program, and you wish to exchange data with another HELICS federate, you can create a  Federate  by calling the  HELICS.helicsCreateCombinationFederate  function. This federate must be provided with some information in order to set it up correctly. A  FederateInfo  object must be first created in order to set up a  Federate . This  FederateInfo  object contains information about what type of communication core is used in HELICS (e.g.  zmq ,  mpi ,  tcp ,  udp ), the name of the  Federate , where the  Broker  is located, etc. All  Federate s must connect to a  Broker . A  Broker  is a separate process that can run on the same machine or a remote machine. You can start a  Broker  by running  HELICS.helicsCreateBroker , or running  helics_broker -f ${NUMBER_OF_FEDERATES}  from the command line. Both creating a  FederateInfo  and  Broker  object can take some initialization options in the form of a  initstring . See the  examples  folder for more information.  After creating a  Federate , you will want to create  Publication s and  Subscription s. The strings you choose for these publications and subscriptions must be unique, and they act like topics in a federation. You can send data in the form of values from a  Publication  to a  Subscription . Additionally, you can register  Endpoint s as well, which allow you to send  Message s.  Message s can be filtered on by any  Federate  and can be used to model complex communication interactions.  You can use functions like  HELICS.helicsPublicationPublishDouble  to send values at the \"current time\", and use functions like  HELICS.helicsSubscriptionGetKey  or  HELICS.helicsInputGetDouble  to receive values at the \"current time\". You can use functions like  HELICS.helicsEndpointSendMessage  to send messages at the \"current time\", and use functions like  HELICS.helicsEndpointGetMessage  functions to receive messages that arrived before the \"current time\".  You can request to move to a time by using the  HELICS.helicsFederateRequestTime  function. This function returns a time back that you can safely move to. The time granted will always be less than or equal to the requested time. If you wish to move to the requested time, you may use a while loop until that the granted time is equal to the requested time.  for   t   in   1 : 100 \n\n     requested_time   =   t       while   granted_time   <   requested_time           granted_time   =   helicsFederateRequestTime ( requested_time )       end  \n     # granted_time here will be equal to requested time \n     # Send or Receive data here  end   HELICS.helicsFederateRequestTime  is a blocking call. There are other asynchronous request time functions available that allow you to do work while you wait for others to move forward in simulation time.  helicsSharedLib  is a shared library that is included in the Julia package. This C/C++ shared library interfaces with the broker in other to communicate with other federates.",
            "title": "Terminology"
        },
        {
            "location": "/api/",
            "text": "API\n\n\n#\n\n\nHELICS.Broker\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Broker\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.CWrapper\n \u2014 \nType\n.\n\n\nSummary\n\n\nabstract type HELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.CombinationFederate\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.CombinationFederate\n <: \nHELICS.Federate\n\n\nsource\n\n\n#\n\n\nHELICS.Core\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Core\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Endpoint\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Endpoint\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Federate\n \u2014 \nType\n.\n\n\nSummary\n\n\nabstract type HELICS.Federate <: HELICS.CWrapper\n\n\nSubtypes\n\n\n\n\nHELICS.CombinationFederate\n\n\nHELICS.MessageFederate\n\n\nHELICS.ValueFederate\n\n\n\n\nSupertype Hierarchy\n\n\nHELICS.Federate <: HELICS.CWrapper <: Any\n\n\nsource\n\n\n#\n\n\nHELICS.FederateInfo\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.FederateInfo\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Filter\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Filter\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_CORE_TYPE\n \u2014 \nType\n.\n\n\n\n\nHELICS_CORE_TYPE_DEFAULT\n: 0\n\n\nHELICS_CORE_TYPE_ZMQ\n: 1\n\n\nHELICS_CORE_TYPE_MPI\n: 2\n\n\nHELICS_CORE_TYPE_TEST\n: 3\n\n\nHELICS_CORE_TYPE_INTERPROCESS\n: 4\n\n\nHELICS_CORE_TYPE_IPC\n: 5\n\n\nHELICS_CORE_TYPE_TCP\n: 6\n\n\nHELICS_CORE_TYPE_UDP\n: 7\n\n\nHELICS_CORE_TYPE_ZMQ_TEST\n: 10\n\n\nHELICS_CORE_TYPE_NNG\n: 9\n\n\nHELICS_CORE_TYPE_TCP_SS\n: 11\n\n\nHELICS_CORE_TYPE_HTTP\n: 12\n\n\nHELICS_CORE_TYPE_WEBSOCKET\n: 14\n\n\nHELICS_CORE_TYPE_INPROC\n: 18\n\n\nHELICS_CORE_TYPE_NULL\n: 66\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_DATA_TYPE\n \u2014 \nType\n.\n\n\n\n\nHELICS_DATA_TYPE_STRING\n: 0\n\n\nHELICS_DATA_TYPE_DOUBLE\n: 1\n\n\nHELICS_DATA_TYPE_INT\n: 2\n\n\nHELICS_DATA_TYPE_COMPLEX\n: 3\n\n\nHELICS_DATA_TYPE_VECTOR\n: 4\n\n\nHELICS_DATA_TYPE_COMPLEX_VECTOR\n: 5\n\n\nHELICS_DATA_TYPE_NAMED_POINT\n: 6\n\n\nHELICS_DATA_TYPE_BOOLEAN\n: 7\n\n\nHELICS_DATA_TYPE_TIME\n: 8\n\n\nHELICS_DATA_TYPE_RAW\n: 25\n\n\nHELICS_DATA_TYPE_ANY\n: 25262\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_ERROR_TYPES\n \u2014 \nType\n.\n\n\n\n\nHELICS_OK\n: 0\n\n\nHELICS_ERROR_REGISTRATION_FAILURE\n: -1\n\n\nHELICS_ERROR_CONNECTION_FAILURE\n: -2\n\n\nHELICS_ERROR_INVALID_OBJECT\n: -3\n\n\nHELICS_ERROR_INVALID_ARGUMENT\n: -4\n\n\nHELICS_ERROR_DISCARD\n: -5\n\n\nHELICS_ERROR_SYSTEM_FAILURE\n: -6\n\n\nHELICS_WARNING\n: -8\n\n\nHELICS_ERROR_INVALID_STATE_TRANSITION\n: -9\n\n\nHELICS_ERROR_INVALID_FUNCTION_CALL\n: -10\n\n\nHELICS_ERROR_EXECUTION_FAILURE\n: -14\n\n\nHELICS_ERROR_INSUFFICIENT_SPACE\n: -18\n\n\nHELICS_ERROR_OTHER\n: -101\n\n\nHELICS_ERROR_FATAL\n: -404\n\n\nHELICS_ERROR_EXTERNAL_TYPE\n: -203\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_FEDERATE_FLAGS\n \u2014 \nType\n.\n\n\n\n\nHELICS_FLAG_OBSERVER\n: 0\n\n\nHELICS_FLAG_UNINTERRUPTIBLE\n: 1\n\n\nHELICS_FLAG_INTERRUPTIBLE\n: 2\n\n\nHELICS_FLAG_SOURCE_ONLY\n: 4\n\n\nHELICS_FLAG_ONLY_TRANSMIT_ON_CHANGE\n: 6\n\n\nHELICS_FLAG_ONLY_UPDATE_ON_CHANGE\n: 8\n\n\nHELICS_FLAG_WAIT_FOR_CURRENT_TIME_UPDATE\n: 10\n\n\nHELICS_FLAG_RESTRICTIVE_TIME_POLICY\n: 11\n\n\nHELICS_FLAG_ROLLBACK\n: 12\n\n\nHELICS_FLAG_FORWARD_COMPUTE\n: 14\n\n\nHELICS_FLAG_REALTIME\n: 16\n\n\nHELICS_FLAG_SINGLE_THREAD_FEDERATE\n: 27\n\n\nHELICS_FLAG_SLOW_RESPONDING\n: 29\n\n\nHELICS_FLAG_DELAY_INIT_ENTRY\n: 45\n\n\nHELICS_FLAG_ENABLE_INIT_ENTRY\n: 47\n\n\nHELICS_FLAG_IGNORE_TIME_MISMATCH_WARNINGS\n: 67\n\n\nHELICS_FLAG_TERMINATE_ON_ERROR\n: 72\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_FEDERATE_STATE\n \u2014 \nType\n.\n\n\n\n\nHELICS_STATE_STARTUP\n: 0\n\n\nHELICS_STATE_INITIALIZATION\n: 1\n\n\nHELICS_STATE_EXECUTION\n: 2\n\n\nHELICS_STATE_FINALIZE\n: 3\n\n\nHELICS_STATE_ERROR\n: 4\n\n\nHELICS_STATE_PENDING_INIT\n: 5\n\n\nHELICS_STATE_PENDING_EXEC\n: 6\n\n\nHELICS_STATE_PENDING_TIME\n: 7\n\n\nHELICS_STATE_PENDING_ITERATIVE_TIME\n: 8\n\n\nHELICS_STATE_PENDING_FINALIZE\n: 9\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_FILTER_TYPE\n \u2014 \nType\n.\n\n\n\n\nHELICS_FILTER_TYPE_CUSTOM\n: 0\n\n\nHELICS_FILTER_TYPE_DELAY\n: 1\n\n\nHELICS_FILTER_TYPE_RANDOM_DELAY\n: 2\n\n\nHELICS_FILTER_TYPE_RANDOM_DROP\n: 3\n\n\nHELICS_FILTER_TYPE_REROUTE\n: 4\n\n\nHELICS_FILTER_TYPE_CLONE\n: 5\n\n\nHELICS_FILTER_TYPE_FIREWALL\n: 6\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_HANDLE_OPTIONS\n \u2014 \nType\n.\n\n\n\n\nHELICS_HANDLE_OPTION_CONNECTION_REQUIRED\n: 397\n\n\nHELICS_HANDLE_OPTION_CONNECTION_OPTIONAL\n: 402\n\n\nHELICS_HANDLE_OPTION_SINGLE_CONNECTION_ONLY\n: 407\n\n\nHELICS_HANDLE_OPTION_MULTIPLE_CONNECTIONS_ALLOWED\n: 409\n\n\nHELICS_HANDLE_OPTION_BUFFER_DATA\n: 411\n\n\nHELICS_HANDLE_OPTION_STRICT_TYPE_CHECKING\n: 414\n\n\nHELICS_HANDLE_OPTION_IGNORE_UNIT_MISMATCH\n: 447\n\n\nHELICS_HANDLE_OPTION_ONLY_TRANSMIT_ON_CHANGE\n: 6\n\n\nHELICS_HANDLE_OPTION_ONLY_UPDATE_ON_CHANGE\n: 8\n\n\nHELICS_HANDLE_OPTION_IGNORE_INTERRUPTS\n: 475\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_ITERATION_REQUEST\n \u2014 \nType\n.\n\n\n\n\nHELICS_ITERATION_REQUEST_NO_ITERATION\n: 0\n\n\nHELICS_ITERATION_REQUEST_FORCE_ITERATION\n: 1\n\n\nHELICS_ITERATION_REQUEST_ITERATE_IF_NEEDED\n: 2\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_ITERATION_RESULT\n \u2014 \nType\n.\n\n\n\n\nHELICS_ITERATION_RESULT_NEXT_STEP\n: 0\n\n\nHELICS_ITERATION_RESULT_ERROR\n: 1\n\n\nHELICS_ITERATION_RESULT_HALTED\n: 2\n\n\nHELICS_ITERATION_RESULT_ITERATING\n: 3\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_LOG_LEVELS\n \u2014 \nType\n.\n\n\n\n\nHELICS_LOG_LEVEL_NO_PRINT\n: -1\n\n\nHELICS_LOG_LEVEL_ERROR\n: 0\n\n\nHELICS_LOG_LEVEL_WARNING\n: 1\n\n\nHELICS_LOG_LEVEL_SUMMARY\n: 2\n\n\nHELICS_LOG_LEVEL_CONNECTIONS\n: 3\n\n\nHELICS_LOG_LEVEL_INTERFACES\n: 4\n\n\nHELICS_LOG_LEVEL_TIMING\n: 5\n\n\nHELICS_LOG_LEVEL_DATA\n: 6\n\n\nHELICS_LOG_LEVEL_TRACE\n: 7\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.HELICS_PROPERTIES\n \u2014 \nType\n.\n\n\n\n\nHELICS_PROPERTY_TIME_DELTA\n: 137\n\n\nHELICS_PROPERTY_TIME_PERIOD\n: 140\n\n\nHELICS_PROPERTY_TIME_OFFSET\n: 141\n\n\nHELICS_PROPERTY_TIME_RT_LAG\n: 143\n\n\nHELICS_PROPERTY_TIME_RT_LEAD\n: 144\n\n\nHELICS_PROPERTY_TIME_RT_TOLERANCE\n: 145\n\n\nHELICS_PROPERTY_TIME_INPUT_DELAY\n: 148\n\n\nHELICS_PROPERTY_TIME_OUTPUT_DELAY\n: 150\n\n\nHELICS_PROPERTY_INT_MAX_ITERATIONS\n: 259\n\n\nHELICS_PROPERTY_INT_LOG_LEVEL\n: 271\n\n\nHELICS_PROPERTY_INT_FILE_LOG_LEVEL\n: 272\n\n\nHELICS_PROPERTY_INT_CONSOLE_LOG_LEVEL\n: 274\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.Message\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Message\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.MessageFederate\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.MessageFederate\n <: \nHELICS.Federate\n\n\nsource\n\n\n#\n\n\nHELICS.Publication\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Publication\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Query\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Query\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.Subscription\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.Subscription\n <: \nHELICS.CWrapper\n\n\nsource\n\n\n#\n\n\nHELICS.ValueFederate\n \u2014 \nType\n.\n\n\nSummary\n\n\nstruct \nHELICS.ValueFederate\n <: \nHELICS.Federate\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerAddDestinationFilterToEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsBrokerAddDestinationFilterToEndpoint\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerAddSourceFilterToEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsBrokerAddSourceFilterToEndpoint\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerClone\n \u2014 \nMethod\n.\n\n\nhelicsBrokerClone\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n->\n \nHELICS\n.\nBroker\n\n\n\n\n\n\nCreate a new reference to an existing broker\n\n\nthis will create a new broker object that references the existing broker it must be freed as well\n\n\nArguments\n\n\n\n\nbroker\n: an existing \nBroker\n\n\n\n\nReturns\n\n\n\n\na new reference to the same broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerDataLink\n \u2014 \nMethod\n.\n\n\nhelicsBrokerDataLink\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nsource\n::\nString\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nLink a named publication and named input using a broker\n\n\nArguments\n\n\n\n\nbroker\n: the \nBroker\n to generate the connection from\n\n\nsource\n: the name of the publication (cannot be NULL)\n\n\ntarget\n: the name of the target to send the publication data (cannot be NULL)\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerDestroy\n \u2014 \nMethod\n.\n\n\nhelicsBrokerDestroy\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nDisconnect and free a broker\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerDisconnect\n \u2014 \nMethod\n.\n\n\nhelicsBrokerDisconnect\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nDisconnect a broker\n\n\nArguments\n\n\n\n\nbroker\n: the broker to disconnect\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerFree\n \u2014 \nMethod\n.\n\n\nhelicsBrokerFree\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nRelease the memory associated with a broker\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerGetAddress\n \u2014 \nMethod\n.\n\n\nhelicsBrokerGetAddress\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the network address associated with a broker\n\n\nArguments\n\n\n\n\nbroker\n: the broker to query\n\n\n\n\nReturns\n\n\n\n\na string with the network address of the broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerGetIdentifier\n \u2014 \nMethod\n.\n\n\nhelicsBrokerGetIdentifier\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n->\n \nString\n\n\n\n\n\n\nGet an identifier for the broker\n\n\nArguments\n\n\n\n\nbroker\n: the broker to query\n\n\n\n\nReturns\n\n\n\n\na string containing the identifier for the broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerIsConnected\n \u2014 \nMethod\n.\n\n\nhelicsBrokerIsConnected\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a broker is connected. A connected broker implies is attached to cores or cores could reach out to communicate. return 0 if not connected , something else if it is connected.\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerIsValid\n \u2014 \nMethod\n.\n\n\nhelicsBrokerIsValid\n(\nbroker\n::\nHELICS\n.\nBroker\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a broker object is a valid object\n\n\nArguments\n\n\n\n\nbroker\n: the \nBroker\n object to test\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerMakeConnections\n \u2014 \nMethod\n.\n\n\nhelicsBrokerMakeConnections\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nfile\n::\nString\n)\n\n\n\n\n\n\nLoad a file containing connection information\n\n\nArguments\n\n\n\n\nbroker\n: The broker to generate the connections from\n\n\nfile\n: A JSON or TOML file containing connection information\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerSetGlobal\n \u2014 \nMethod\n.\n\n\nhelicsBrokerSetGlobal\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nvalueName\n::\nString\n,\n \nvalue\n::\nString\n)\n\n\n\n\n\n\nSet a federation global value\n\n\nthis overwrites any previous value for this name\n\n\nArguments\n\n\n\n\nbroker\n: the broker to set the global through\n\n\nvalueName\n: the name of the global to set\n\n\nvalue\n: the value of the global\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerSetLogFile\n \u2014 \nMethod\n.\n\n\nhelicsBrokerSetLogFile\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nlogFileName\n::\nString\n)\n\n\n\n\n\n\nSet a the log file on a broker\n\n\nArguments\n\n\n\n\nbroker\n: The broker to set the global through\n\n\nlogFileName\n: The name of the file to log to\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerSetLoggingCallback\n \u2014 \nMethod\n.\n\n\nhelicsBrokerSetLoggingCallback\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nlogger\n::\nPtr\n{\nNothing\n},\n \nuserdata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsBrokerWaitForDisconnect\n \u2014 \nMethod\n.\n\n\nhelicsBrokerWaitForDisconnect\n(\nbroker\n::\nHELICS\n.\nBroker\n,\n \nmsToWait\n::\nInt64\n)\n \n->\n \nBool\n\n\n\n\n\n\nWait for the broker to disconnect\n\n\nArguments\n\n\n\n\nbroker\n: the broker to wait for\n\n\nmsToWait\n: the time out in millisecond (<0 for infinite timeout)\n\n\n\n\nReturns\n\n\n\n\ntrue\n if the disconnect was successful, \nfalse\n if there was a timeout\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCleanupLibrary\n \u2014 \nMethod\n.\n\n\nhelicsCleanupLibrary\n()\n\n\n\n\n\n\nFunction to do some housekeeping work\n\n\nthis runs some cleanup routines and tries to close out any residual thread that haven't been shutdown yet.\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCloseLibrary\n \u2014 \nMethod\n.\n\n\nhelicsCloseLibrary\n()\n\n\n\n\n\n\nCall when done using the helics library,  this function will ensure the threads are closed properly if possible     this should be the last call before exiting,\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreAddDestinationFilterToEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsCoreAddDestinationFilterToEndpoint\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreAddSourceFilterToEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsCoreAddSourceFilterToEndpoint\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nfilter\n::\nString\n,\n \nendpoint\n::\nString\n)\n\n\n\n\n\n\nLink a named filter to a source endpoint\n\n\nArguments\n\n\n\n\ncore\n: the core to generate the connection from\n\n\nfilter\n: the name of the filter (cannot be NULL)\n\n\nendpoint\n: the name of the endpoint to filter the data from (cannot be NULL)\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreClone\n \u2014 \nMethod\n.\n\n\nhelicsCoreClone\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n->\n \nHELICS\n.\nCore\n\n\n\n\n\n\nCreate a new reference to an existing core\n\n\nthis will create a new broker object that references the existing broker it must be freed as well\n\n\nArguments\n\n\n\n\ncore\n: an existing \nCore\n\n\n\n\nReturns\n\n\n\n\na new reference to the same \nCore\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreDataLink\n \u2014 \nMethod\n.\n\n\nhelicsCoreDataLink\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nsource\n::\nString\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nLink a named publication and named input using a core\n\n\nArguments\n\n\n\n\ncore\n: the core to generate the connection from\n\n\nsource\n: the name of the publication (cannot be NULL)\n\n\ntarget\n: the named of the target to send the publication data (cannot be NULL)\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreDestroy\n \u2014 \nMethod\n.\n\n\nhelicsCoreDestroy\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nDisconnect and free a core\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreDisconnect\n \u2014 \nMethod\n.\n\n\nhelicsCoreDisconnect\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nGet an identifier for the core\n\n\nArguments\n\n\n\n\ncore\n: the core to query\n\n\n\n\nReturns\n\n\n\n\na void enumeration indicating any error condition\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreFree\n \u2014 \nMethod\n.\n\n\nhelicsCoreFree\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nRelease the memory associated with a core\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreGetAddress\n \u2014 \nMethod\n.\n\n\nhelicsCoreGetAddress\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the network address associated with a core\n\n\nArguments\n\n\n\n\ncore\n: The core to query\n\n\n\n\nReturns\n\n\n\n\na string with the network address of the broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreGetIdentifier\n \u2014 \nMethod\n.\n\n\nhelicsCoreGetIdentifier\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n->\n \nString\n\n\n\n\n\n\nGet an identifier for the core\n\n\nArguments\n\n\n\n\ncore\n: the core to query\n\n\n\n\nReturns\n\n\n\n\na string with the identifier of the core\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreIsConnected\n \u2014 \nMethod\n.\n\n\nhelicsCoreIsConnected\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a core is connected. A connected core implies is attached to federate or federates could be attached to it.\n\n\nReturns\n\n\n\n\nfalse\n if not connected, \ntrue\n if it is connected\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreIsValid\n \u2014 \nMethod\n.\n\n\nhelicsCoreIsValid\n(\ncore\n::\nHELICS\n.\nCore\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a core object is a valid object\n\n\nArguments\n\n\n\n\ncore\n: the \nCore\n object to test\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreMakeConnections\n \u2014 \nMethod\n.\n\n\nhelicsCoreMakeConnections\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nfile\n::\nString\n)\n\n\n\n\n\n\nLoad a file containing connection information\n\n\nArguments\n\n\n\n\ncore\n: The core to generate the connections from\n\n\nfile\n: A JSON or TOML file containing connection information\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreRegisterCloningFilter\n \u2014 \nMethod\n.\n\n\nhelicsCoreRegisterCloningFilter\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreRegisterFilter\n \u2014 \nMethod\n.\n\n\nhelicsCoreRegisterFilter\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_filter_type\n},\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreSetGlobal\n \u2014 \nMethod\n.\n\n\nhelicsCoreSetGlobal\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nvalueName\n::\nString\n,\n \nvalue\n::\nString\n)\n\n\n\n\n\n\nSet a global value in a core\n\n\nthis overwrites any previous value for this name\n\n\nArguments\n\n\n\n\ncore\n: the core to set the global through\n\n\nvalueName\n: the name of the global to set\n\n\nvalue\n: the value of the global\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreSetLogFile\n \u2014 \nMethod\n.\n\n\nhelicsCoreSetLogFile\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nlogFileName\n::\nString\n)\n\n\n\n\n\n\nSet a the log file on a core\n\n\nArguments\n\n\n\n\ncore\n: The core to set the global through\n\n\nlogFileName\n: The name of the file to log to\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreSetLoggingCallback\n \u2014 \nMethod\n.\n\n\nhelicsCoreSetLoggingCallback\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nlogger\n::\nPtr\n{\nNothing\n},\n \nuserdata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreSetReadyToInit\n \u2014 \nMethod\n.\n\n\nhelicsCoreSetReadyToInit\n(\ncore\n::\nHELICS\n.\nCore\n)\n\n\n\n\n\n\nSet the core to ready for init\n\n\nthis function is used for cores that have filters but no federates so there needs to be a direct signal to the core to trigger the federation initialization\n\n\nArguments\n\n\n\n\ncore\n: the core object to enable init values for\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCoreWaitForDisconnect\n \u2014 \nMethod\n.\n\n\nhelicsCoreWaitForDisconnect\n(\ncore\n::\nHELICS\n.\nCore\n,\n \nmsWait\n::\nInt64\n)\n \n->\n \nInt32\n\n\n\n\n\n\nWait for the core to disconnect\n\n\nArguments\n\n\n\n\ncore\n: The core to wait for\n\n\nmsToWait\n: The time out in millisecond (<0 for infinite timeout)\n\n\n\n\nReturns\n\n\ntrue\n if the disconnect was successful, \nfalse\n if there was a timeout\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateBroker\n \u2014 \nMethod\n.\n\n\nhelicsCreateBroker\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \ninitString\n::\nString\n)\n \n->\n \nHELICS\n.\nBroker\n\n\n\n\n\n\nCreate a broker object\n\n\nArguments\n\n\n\n\ntype\n: the type of the broker to create\n\n\nname\n: the name of the broker , may be a nullptr or empty string to have a name automatically assigned\n\n\ninitString\n: an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" if this is a subbroker or the number of federates or the address\n\n\n\n\nReturns\n\n\n\n\na \nBroker\n object, will be NULL if there was an error indicated in the err object\n\n\n\n\nsource\n\n\n<a id='HELICS.helicsCreateBrokerFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}' href='#HELICS.helicsCreateBrokerFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}'>#\n\n\nHELICS.helicsCreateBrokerFromArgs\n \u2014 \nMethod\n.\n\n\nhelicsCreateBrokerFromArgs\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \nargc\n::\nInt64\n,\n \nargv\n::\nArray\n{\n#s45,1} where #s45<:AbstractString) -> HELICS.Broker\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCombinationFederate\n \u2014 \nMethod\n.\n\n\nhelicsCreateCombinationFederate\n(\nfedName\n::\nString\n,\n \nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n->\n \nHELICS\n.\nCombinationFederate\n\n\n\n\n\n\nCreate a \nCombinationFederate\n from a \nFederateInfo\n object\n\n\nCombinationFederate\n are both \nValueFederate\n and \nMessageFederate\n, objects can be used in all functions that take a \nFederate\n, \nMessageFederate\n or \nValueFederate\n object as an argument\n\n\nArguments\n\n\n\n\nfedName\n: a string with the name of the federate, can be NULL or an empty string to pull the default name from fi\n\n\nfi\n: the \nFederateInfo\n object that contains details on the federate\n\n\n\n\nReturns\n\n\n\n\nan opaque \nValueFederate\n, nullptr if the object creation failed\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCombinationFederateFromConfig\n \u2014 \nMethod\n.\n\n\nhelicsCreateCombinationFederateFromConfig\n(\nconfigFile\n::\nString\n)\n \n->\n \nHELICS\n.\nCombinationFederate\n\n\n\n\n\n\nCreate a \nCombinationFederate\n from a JSON file or JSON string\n\n\nCombinationFederate\n are both \nValueFederate\n and \nMessageFederate\n, objects can be used in all functions that take a \nFederate\n, \nMessageFederate\n or \nValueFederate\n object as an argument\n\n\nArguments\n\n\n\n\nconfigFile\n:  a JSON file or a JSON string or TOML file that contains setup and configuration information\n\n\n\n\nReturns\n\n\n\n\nan opaque \nCombinationFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateCore\n \u2014 \nMethod\n.\n\n\nhelicsCreateCore\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \ninitString\n::\nString\n)\n \n->\n \nHELICS\n.\nCore\n\n\n\n\n\n\nCreate a core object\n\n\nArguments\n\n\n\n\ntype\n: the type of the core to create\n\n\nname\n: the name of the core , may be a nullptr or empty string to have a name automatically assigned\n\n\ninitString\n: an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" or the number of federates or the address\n\n\n\n\nReturns\n\n\n\n\na \nCore\n object if the core is invalid err will contain some indication\n\n\n\n\nsource\n\n\n<a id='HELICS.helicsCreateCoreFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}' href='#HELICS.helicsCreateCoreFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}'>#\n\n\nHELICS.helicsCreateCoreFromArgs\n \u2014 \nMethod\n.\n\n\nhelicsCreateCoreFromArgs\n(\nkind\n::\nString\n,\n \nname\n::\nString\n,\n \nargc\n::\nInt64\n,\n \nargv\n::\nArray\n{\n#s45,1} where #s45<:AbstractString) -> HELICS.Core\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateFederateInfo\n \u2014 \nMethod\n.\n\n\nhelicsCreateFederateInfo\n()\n \n->\n \nHELICS\n.\nFederateInfo\n\n\n\n\n\n\nCreate a \nFederateInfo\n object for specifying federate information when constructing a federate\n\n\nReturns\n\n\n\n\na \nFederateInfo\n object which is a reference to the created object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateMessageFederate\n \u2014 \nMethod\n.\n\n\nhelicsCreateMessageFederate\n(\nfedName\n::\nString\n,\n \nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n->\n \nHELICS\n.\nMessageFederate\n\n\n\n\n\n\nCreate a \nMessageFederate\n from a \nFederateInfo\n object\n\n\nMessageFederate\n objects can be used in all functions that take a \nMessageFederate\n or \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nfedName\n: the name of the federate to create\n\n\nfi\n: the \nFederateInfo\n object that contains details on the federate\n\n\n\n\nReturns\n\n\n\n\nan opaque \nMessageFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateMessageFederateFromConfig\n \u2014 \nMethod\n.\n\n\nhelicsCreateMessageFederateFromConfig\n(\nconfigFile\n::\nString\n)\n \n->\n \nHELICS\n.\nMessageFederate\n\n\n\n\n\n\nCreate a \nMessageFederate\n from a JSON file or JSON string or TOML file\n\n\nMessageFederate\n objects can be used in all functions that take a \nMessageFederate\n or \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nconfigFile\n:  a Config(JSON,TOML) file or a JSON string that contains setup and configuration information\n\n\n\n\nReturns\n\n\n\n\nan opaque \nMessageFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateQuery\n \u2014 \nMethod\n.\n\n\nhelicsCreateQuery\n(\ntarget\n::\nString\n,\n \nquery\n::\nString\n)\n \n->\n \nHELICS\n.\nQuery\n\n\n\n\n\n\nCreate a \nQuery\n\n\na \nQuery\n consists of a target and query string\n\n\nArguments\n\n\n\n\ntarget\n: the name of the target to query\n\n\nquery\n: the query string to make of the target\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateValueFederate\n \u2014 \nMethod\n.\n\n\nhelicsCreateValueFederate\n(\nfedName\n::\nString\n,\n \nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n->\n \nHELICS\n.\nValueFederate\n\n\n\n\n\n\nCreate a value federate from a \nFederateInfo\n object\n\n\nFederate\n objects can be used in all functions that take a \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nfedName\n: the name of the federate to create, can NULL or an empty string to use the default name from fi or an assigned name\n\n\nfi\n: the \nFederateInfo\n object that contains details on the federate\n\n\n\n\nReturns\n\n\n\n\nan opaque value \nFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsCreateValueFederateFromConfig\n \u2014 \nMethod\n.\n\n\nhelicsCreateValueFederateFromConfig\n(\nconfigFile\n::\nString\n)\n \n->\n \nHELICS\n.\nValueFederate\n\n\n\n\n\n\nCreate a value federate from a JSON file, JSON string, or TOML file\n\n\nFederate\n objects can be used in all functions that take a \nFederate\n object as an argument\n\n\nArguments\n\n\n\n\nconfigFile\n:  a JSON file or a JSON string or TOML file that contains setup and configuration information\n\n\n\n\nReturns\n\n\n\n\nan opaque value \nFederate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointClearMessages\n \u2014 \nMethod\n.\n\n\nhelicsEndpointClearMessages\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n\n\n\n\n\n\nClear all message from an endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint object to operate on\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetDefaultDestination\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetDefaultDestination\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the default destination for an endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to set the destination for\n\n\n\n\nReturns\n\n\n\n\na string with the default destination\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetInfo\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetInfo\n(\n_end\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the data in the info field of an filter\n\n\nArguments\n\n\n\n\nend\n: The filter to query\n\n\n\n\nReturns\n\n\n\n\na string with the info field string\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetMessage\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetMessage\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nHELICS\n.\nLib\n.\nhelics_message\n\n\n\n\n\n\nReceive a packet from a particular endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The identifier for the endpoint\n\n\n\n\nReturns\n\n\n\n\na message object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetMessageObject\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetMessageObject\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nHELICS\n.\nMessage\n\n\n\n\n\n\nReceive a packet from a particular endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The identifier for the endpoint\n\n\n\n\nReturns\n\n\n\n\na message object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetName\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetName\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nString\n\n\n\n\n\n\nget the name of an endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint object in question\n\n\n\n\nReturns\n\n\n\n\nthe name of the endpoint\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetOption\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetOption\n(\n_end\n::\nHELICS\n.\nEndpoint\n,\n \noption\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_handle_options\n})\n \n->\n \nBool\n\n\n\n\n\n\nGet a handle option on an endpoint\n\n\n\n\nend\n: The endpoint to modify\n\n\noption\n: Integer code for the option to set \nHELICS_HANDLE_OPTIONS\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointGetType\n \u2014 \nMethod\n.\n\n\nhelicsEndpointGetType\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the type specified for an endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint object in question\n\n\n\n\nReturns\n\n\n\n\nthe defined type of the endpoint\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointHasMessage\n \u2014 \nMethod\n.\n\n\nhelicsEndpointHasMessage\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a given endpoint has any unread messages\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to check\n\n\n\n\nReturns\n\n\n\n\ntrue\n if the endpoint has a message, \nfalse\n otherwise\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointPendingMessages\n \u2014 \nMethod\n.\n\n\nhelicsEndpointPendingMessages\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n)\n \n->\n \nInt64\n\n\n\n\n\n\nReturns the number of pending receives for all endpoints of particular federate.\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to query\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendEventRaw\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSendEventRaw\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \ndest\n::\nString\n,\n \ndata\n::\nString\n,\n \ntime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nSend a message at a specific time to the specified destination\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to send the data from\n\n\ndest\n: The target destination (nullptr to use the default destination)\n\n\ndata\n: The data to send\n\n\ninputDataLength\n: The length of the data to send\n\n\ntime\n: The time the message should be sent\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendMessage\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSendMessage\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \nmessage\n::\nHELICS\n.\nMessage\n)\n\n\n\n\n\n\nSend a message object from a specific endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to send the data from\n\n\nmessage\n: The actual message to send\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendMessageObject\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSendMessageObject\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \nmessage\n::\nHELICS\n.\nMessage\n)\n\n\n\n\n\n\nSend a message object from a specific endpoint\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to send the data from\n\n\nmessage\n: The actual message to send\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSendMessageRaw\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSendMessageRaw\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \ndest\n::\nString\n,\n \ndata\n::\nString\n)\n\n\n\n\n\n\nSend a message to the specified destination\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to send the data from\n\n\ndest\n: The target destination (nullptr to use the default destination)\n\n\ndata\n: The data to send\n\n\ninputDataLength\n: The length of the data to send\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSetDefaultDestination\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSetDefaultDestination\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \ndest\n::\nString\n)\n\n\n\n\n\n\nSet the default destination for an endpoint if no other endpoint is given\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to set the destination for\n\n\ndest\n: A string naming the desired default endpoint\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSetInfo\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSetInfo\n(\n_end\n::\nHELICS\n.\nEndpoint\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nSet the data in the info field for an filter\n\n\nArguments\n\n\n\n\nend\n: The endpoint to query\n\n\ninfo\n: The string to set\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSetOption\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSetOption\n(\n_end\n::\nHELICS\n.\nEndpoint\n,\n \noption\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_handle_options\n},\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nSet a handle option on an endpoint\n\n\n\n\nend\n: The endpoint to modify\n\n\noption\n: Integer code for the option to set \nHELICS_HANDLE_OPTIONS\n\n\nvalue\n: The value to set the option\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsEndpointSubscribe\n \u2014 \nMethod\n.\n\n\nhelicsEndpointSubscribe\n(\nendpoint\n::\nHELICS\n.\nEndpoint\n,\n \nkey\n::\nString\n)\n\n\n\n\n\n\nSubscribe an endpoint to a publication\n\n\nArguments\n\n\n\n\nendpoint\n: The endpoint to use\n\n\nkey\n: The name of the publication\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsErrorClear\n \u2014 \nMethod\n.\n\n\nhelicsErrorClear\n(\nerr\n::\nHELICS\n.\nLib\n.\nhelics_error\n)\n\n\n\n\n\n\nClear an error object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsErrorInitialize\n \u2014 \nMethod\n.\n\n\nhelicsErrorInitialize\n()\n \n->\n \nHELICS\n.\nLib\n.\nhelics_error\n\n\n\n\n\n\nReturn an initialized error object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateAddDependency\n \u2014 \nMethod\n.\n\n\nhelicsFederateAddDependency\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nfedName\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateClearMessages\n \u2014 \nMethod\n.\n\n\nhelicsFederateClearMessages\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nClear all stored messages from a federate\n\n\nthis clears messages retrieved through helicsFederateGetMessage or helicsFederateGetMessageObject\n\n\nArguments\n\n\n\n\nfed\n: The federate to clear the message for\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateClearUpdates\n \u2014 \nMethod\n.\n\n\nhelicsFederateClearUpdates\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nsource\n\n\n<a id='HELICS.helicsFederateClone-Union{Tuple{T}, Tuple{T}} where T<:HELICS.Federate' href='#HELICS.helicsFederateClone-Union{Tuple{T}, Tuple{T}} where T<:HELICS.Federate'>#\n\n\nHELICS.helicsFederateClone\n \u2014 \nMethod\n.\n\n\nhelicsFederateClone\n(\nfed\n::\nT\n<:\nHELICS\n.\nFederate\n)\n \n->\n \nUnion\n{\nHELICS\n.\nCombinationFederate\n,\n \nHELICS\n.\nMessageFederate\n,\n \nHELICS\n.\nValueFederate\n}\n\n\n\n\n\n\nCreate a new reference to an existing federate\n\n\nthis will create a new \nFederate\n object that references the existing federate it must be freed as well\n\n\nArguments\n\n\n\n\nfed\n: an existing \nFederate\n\n\n\n\nReturns\n\n\n\n\na new reference to the same federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateDestroy\n \u2014 \nMethod\n.\n\n\nhelicsFederateDestroy\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nDisconnect and free a broker\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingMode\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterExecutingMode\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nRequest that the federate enter the Execution mode\n\n\nthis call is blocking until granted entry by the core object for an asynchronous alternative call \nhelicsFederateEnterExecutingModeAsync\n on return from this call the federate will be at time 0.\n\n\nArguments\n\n\n\n\nfed\n: a federate to change modes\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeAsync\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nRequest that the federate enter the Execution mode\n\n\nthis call is non-blocking and will return immediately. Call \nhelicsFederateEnterExecutingModeComplete\n to finish the call sequence.\n\n\nArguments\n\n\n\n\nfed\n: the federate object to complete the call\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeComplete\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nComplete the call to \nhelicsFederateEnterExecutingModeAsync\n\n\nArguments\n\n\n\n\nfed\n: the federate object to complete the call\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeIterative\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeIterative\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \niterate\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_iteration_request\n})\n \n->\n \nHELICS\n.\nLib\n.\nhelics_iteration_result\n\n\n\n\n\n\nRequest an iterative time\n\n\nthis call allows for finer grain control of the iterative process then \nhelicsFederateRequestTime\n it takes a time and iteration request and return a time and iteration status.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\niterate\n: the requested iteration mode\n\n\n\n\nReturns\n\n\n\n\nan iteration structure with field containing the time and iteration status\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeIterativeAsync\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeIterativeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \niterate\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_iteration_request\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterExecutingModeIterativeComplete\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterExecutingModeIterativeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nHELICS\n.\nLib\n.\nhelics_iteration_result\n\n\n\n\n\n\nComplete the asynchronous iterative call into ExecutionModel\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nan iteration object containing the iteration time and iteration_status\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterInitializingMode\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterInitializingMode\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nEnter the initialization state of a federate\n\n\nthe initialization state allows initial values to be set and received if the iteration is requested on entry to the execution state. This is a blocking call and will block until the core allows it to proceed.\n\n\nArguments\n\n\n\n\nfed\n: the federate to operate on\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterInitializingModeAsync\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterInitializingModeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nNon blocking alternative to \nhelicsFederateEnterInitializingMode\n. The function \nhelicsFederateFinalize\n must be called to finish the operation\n\n\nArguments\n\n\n\n\nfed\n: the federate to operate on\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateEnterInitializingModeComplete\n \u2014 \nMethod\n.\n\n\nhelicsFederateEnterInitializingModeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nFinalize the entry to initialize mode that was initiated with \nhelicsFederateEnterInitializingModeAsync\n\n\nArguments\n\n\n\n\nfed\n: the federate desiring to complete the initialization step function\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFinalize\n \u2014 \nMethod\n.\n\n\nhelicsFederateFinalize\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nFinalize the federate this function halts all communication in the federate and disconnects it from the core\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFinalizeAsync\n \u2014 \nMethod\n.\n\n\nhelicsFederateFinalizeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nFinalize the federate in an async call\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFinalizeComplete\n \u2014 \nMethod\n.\n\n\nhelicsFederateFinalizeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nComplete the asynchronous finalize call\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateFree\n \u2014 \nMethod\n.\n\n\nhelicsFederateFree\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nRelease the memory associated withe a federate\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetCoreObject\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetCoreObject\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nHELICS\n.\nCore\n\n\n\n\n\n\nGet the core object associated with a federate\n\n\nArguments\n\n\n\n\nfed\n: a federate object\n\n\n\n\nReturns\n\n\n\n\na core object, nullptr if invalid\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetCurrentTime\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetCurrentTime\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nGet the current time of the federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n to query\n\n\n\n\nReturns\n\n\n\n\nthe current time of the federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetEndpoint\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nGet an endpoint object from a name\n\n\nArguments\n\n\n\n\nfed\n: The message federate object to use to get the endpoint\n\n\nname\n: The name of the endpoint\n\n\nerr\n: The error object to complete if there is an error\n\n\n\n\nReturns\n\n\n\n\na \nhelics_endpoint\n object, the object will not\n\n\n\n\nbe valid and err will contain an error code if no endpoint with the specified name exists\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetEndpointByIndex\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetEndpointByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n->\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nGet an endpoint by its index typically already created via registerInterfaces file or something of that nature\n\n\nArguments\n\n\n\n\nfed\n: The federate object in which to create a publication\n\n\nindex\n: The index of the publication to get\n\n\n\n\nReturns\n\n\n\n\na helics_endpoint, which will be NULL if an invalid index\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetEndpointCount\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetEndpointCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nInt64\n\n\n\n\n\n\nGet the number of endpoints in a federate\n\n\nArguments\n\n\n\n\nfed\n: The message federate to query\n\n\n\n\nReturns\n\n\n\n\n(-1) if fed was not a valid federate otherwise returns the number of endpoints\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFilter\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFilterByIndex\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetFilterByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFilterCount\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetFilterCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetFlagOption\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetFlagOption\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nflag\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_federate_flags\n})\n \n->\n \nBool\n\n\n\n\n\n\nGet a flag value for a federate\n\n\nArguments\n\n\n\n\nfed\n: the federate to get the flag for\n\n\nflag\n: the flag to query\n\n\n\n\nReturns\n\n\n\n\nthe value of the flag\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetInput\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetInputByIndex\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetInputByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetInputCount\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetInputCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetIntegerProperty\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetIntegerProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nintProperty\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_handle_options\n})\n \n->\n \nInt64\n\n\n\n\n\n\nSet the logging level for the federate\n\n\ndebug and trace only do anything if they were enabled in the compilation\n\n\nArguments\n\n\n\n\nfed\n: the federate to get the flag for\n\n\nintProperty\n: a code for the property to set \nHELICS_HANDLE_OPTIONS\n\n\n\n\nReturns\n\n\n\n\nthe value of the property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetMessage\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nHELICS\n.\nLib\n.\nhelics_message\n\n\n\n\n\n\nReceive a communication message for any endpoint in the federate\n\n\nthe return order will be in order of endpoint creation. So all messages that are available for the first endpoint, then all for the second, and so on within a single endpoint the messages are ordered by time, then \nsource_id\n, then order of arrival\n\n\nReturns\n\n\n\n\na \nunique_ptr\n to a \nLib.helics_message\n object containing the message data\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetMessageObject\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetMessageObject\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nHELICS\n.\nMessage\n\n\n\n\n\n\nReceive a communication message for any endpoint in the federate\n\n\nthe return order will be in order of endpoint creation. So all messages that are available for the first endpoint, then all for the second, and so on within a single endpoint the messages are ordered by time, then \nsource_id\n, then order of arrival\n\n\nReturns\n\n\n\n\na \nMessage\n which references the\n\n\n\n\ndata in the message\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetName\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetName\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the name of the federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n to query\n\n\n\n\nReturns\n\n\n\n\na string with the name\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetPublication\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetPublicationByIndex\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetPublicationByIndex\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nindex\n::\nInt64\n)\n \n->\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetPublicationCount\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetPublicationCount\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetState\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetState\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nHELICS\n.\nLib\n.\nhelics_federate_state\n\n\n\n\n\n\nGet the current state of a federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n to query\n\n\n\n\nReturns\n\n\n\n\nstate the resulting state if void return helics_ok\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetSubscription\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetSubscription\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGetTimeProperty\n \u2014 \nMethod\n.\n\n\nhelicsFederateGetTimeProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ntimeProperty\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_properties\n})\n \n->\n \nFloat64\n\n\n\n\n\n\nGet the current value of a time based property in a federate\n\n\nArguments\n\n\n\n\nfed\n: the federate query\n\n\ntimeProperty\n: the property to query\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateGlobalError\n \u2014 \nMethod\n.\n\n\nhelicsFederateGlobalError\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nerror_code\n::\nInteger\n,\n \nerror_string\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateHasMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateHasMessage\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if the federate has any outstanding messages\n\n\nArguments\n\n\n\n\nfed\n: The federate to check if it has\n\n\n\n\nReturns\n\n\n\n\ntrue\n if the federate has a message waiting \nfalse\n otherwise\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoClone\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoClone\n(\nfi\n::\nHELICS\n.\nFederateInfo\n)\n \n->\n \nHELICS\n.\nFederateInfo\n\n\n\n\n\n\nCreate a \nFederateInfo\n object from an existing one and clone the information\n\n\nArguments\n\n\n\n\nfi\n: a \nFederateInfo\n object to duplicate\n\n\n\n\nReturns\n\n\n\n\na helics\nfederate\ninfo object which is a reference to the created object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoFree\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoFree\n(\nfi\n::\nHELICS\n.\nFederateInfo\n)\n\n\n\n\n\n\nDelete the memory associated with a \nFederateInfo\n object\n\n\nsource\n\n\n<a id='HELICS.helicsFederateInfoLoadFromArgs-Tuple{HELICS.FederateInfo,Int64,Array{#s45,1} where #s45<:AbstractString}' href='#HELICS.helicsFederateInfoLoadFromArgs-Tuple{HELICS.FederateInfo,Int64,Array{#s45,1} where #s45<:AbstractString}'>#\n\n\nHELICS.helicsFederateInfoLoadFromArgs\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoLoadFromArgs\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nargc\n::\nInt64\n,\n \nargv\n::\nArray\n{\n#s45,1} where #s45<:AbstractString)\n\n\n\n\n\n\nLoad a \nFederateInfo\n from command line arguments\n\n\nArguments\n\n\n\n\nfi\n: a \nFederateInfo\n object\n\n\nargc\n: the number of command line arguments\n\n\nargv\n: an array of strings from the command line\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetBroker\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetBroker\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nbroker\n::\nHELICS\n.\nBroker\n)\n\n\n\n\n\n\nSet the name or connection information for a broker\n\n\nthis is only used if the core is automatically created, the broker information will be transferred to the core for connection\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nbroker\n: a string which defined the connection information for a broker either a name or an address\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetBrokerInitString\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetBrokerInitString\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nbrokerInit\n::\nString\n)\n\n\n\n\n\n\nSet the initialization string that a core will pass to a generated broker usually in the form of command line arguments\n\n\nArguments\n\n\n\n\nfi\n: The federate info object to alter\n\n\nbrokerInit\n: A string with command line arguments for a generated broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetBrokerKey\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetBrokerKey\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nbrokerKey\n::\nString\n)\n\n\n\n\n\n\nSet the key for a broker connection\n\n\nthis is only used if the core is automatically created, the broker information will be transferred to the core for connection\n\n\nArguments\n\n\n\n\nfi\n: The federate info object to alter\n\n\nbrokerkey\n: A string containing a key for the broker to connect\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetBrokerPort\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetBrokerPort\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nbrokerPort\n::\nInt64\n)\n\n\n\n\n\n\nSet the port to use for the broker\n\n\nthis is only used if the core is automatically created, the broker information will be transferred to the core for connection this will only be useful for network broker connections\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nbrokerPort\n: the integer port number to use for connection with a broker\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreInitString\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetCoreInitString\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncoreInit\n::\nString\n)\n\n\n\n\n\n\nSet the initialization string for the core usually in the form of command line arguments\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncoreInit\n: a string with the core initialization strings\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreName\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetCoreName\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncorename\n::\nString\n)\n\n\n\n\n\n\nSet the name of the core to link to for a federate\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncorename\n: the identifier for a core to link to\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreType\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetCoreType\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncoretype\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_core_type\n})\n\n\n\n\n\n\nSet the core type by integer code\n\n\nvalid values available by definitions in api-data.h\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncoretype\n: an numerical code for a core type see /ref helics\ncore\ntype\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetCoreTypeFromString\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetCoreTypeFromString\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ncoretype\n::\nString\n)\n\n\n\n\n\n\nSet the core type from a string\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\ncoretype\n: a string naming a core type\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetFlagOption\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetFlagOption\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nflag\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_federate_flags\n},\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nSet a flag in the info structure\n\n\nvalid flags are available \nHELICS_FEDERATE_FLAGS\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nflag\n: a numerical index for a flag\n\n\nvalue\n: the desired value of the flag \ntrue\n or \nfalse\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetIntegerProperty\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetIntegerProperty\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nintProperty\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_properties\n},\n \npropertyValue\n::\nInt64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetLocalPort\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetLocalPort\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nlocalPort\n::\nInt64\n)\n\n\n\n\n\n\nSet the local port to use\n\n\nthis is only used if the core is automatically created, the port information will be transferred to the core for connection\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nlocalPort\n: a string with the port information to use as the local server port can be a number or \"auto\" or \"os_local\"\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetSeparator\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetSeparator\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \nseparator\n::\nChar\n)\n\n\n\n\n\n\nSet the separator character in the info structure\n\n\nthe separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName\n\n\nArguments\n\n\n\n\nfi\n: the \nFederateInfo\n object to alter\n\n\nseparator\n: the character to use as a separator\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateInfoSetTimeProperty\n \u2014 \nMethod\n.\n\n\nhelicsFederateInfoSetTimeProperty\n(\nfi\n::\nHELICS\n.\nFederateInfo\n,\n \ntimeProperty\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_properties\n},\n \npropertyValue\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateIsAsyncOperationCompleted\n \u2014 \nMethod\n.\n\n\nhelicsFederateIsAsyncOperationCompleted\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if the current Asynchronous operation has completed\n\n\nArguments\n\n\n\n\nfed\n: the federate to operate on\n\n\n\n\nReturns\n\n\n\n\nfalse\n if not completed, \ntrue\n if completed\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateIsValid\n \u2014 \nMethod\n.\n\n\nhelicsFederateIsValid\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a federate_object is valid\n\n\nReturns\n\n\n\n\ntrue\n if the federate is a valid active federate, \nfalse\n otherwise\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateLocalError\n \u2014 \nMethod\n.\n\n\nhelicsFederateLocalError\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nerror_code\n::\nInteger\n,\n \nerror_string\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateLogDebugMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateLogDebugMessage\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nlogmessage\n::\nString\n)\n\n\n\n\n\n\nLog a message through a federate\n\n\nArguments\n\n\n\n\nfed\n: The federate to set the global through\n\n\nlogmessage\n: The message to put in the log\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateLogErrorMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateLogErrorMessage\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nlogmessage\n::\nString\n)\n\n\n\n\n\n\nLog an error message through a federate\n\n\nArguments\n\n\n\n\nfed\n: The federate to set the global through\n\n\nlogmessage\n: The message to put in the log\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateLogInfoMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateLogInfoMessage\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nlogmessage\n::\nString\n)\n\n\n\n\n\n\nLog a message through a federate\n\n\nArguments\n\n\n\n\nfed\n: The federate to set the global through\n\n\nlogmessage\n: The message to put in the log\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateLogLevelMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateLogLevelMessage\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nloglevel\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_log_levels\n},\n \nlogmessage\n::\nString\n)\n\n\n\n\n\n\nLog a message through a federate\n\n\nArguments\n\n\n\n\nfed\n: The federate to set the global through\n\n\nloglevel\n: The level of the message to log. See \nHELICS_LOG_LEVELS\n\n\nlogmessage\n: The message to put in the log\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateLogWarningMessage\n \u2014 \nMethod\n.\n\n\nhelicsFederateLogWarningMessage\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nlogmessage\n::\nString\n)\n\n\n\n\n\n\nLog a warning message through a federate\n\n\nArguments\n\n\n\n\nfed\n: The federate to set the global through\n\n\nlogmessage\n: The message to put in the log\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederatePendingMessages\n \u2014 \nMethod\n.\n\n\nhelicsFederatePendingMessages\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nInt64\n\n\n\n\n\n\nReturns the number of pending receives for the specified destination endpoint.\n\n\nArguments\n\n\n\n\nfed\n: The federate to get the number of waiting messages\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederatePublishJSON\n \u2014 \nMethod\n.\n\n\nhelicsFederatePublishJSON\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \njson\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterCloningFilter\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterCloningFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterEndpoint\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n,\n \nkind\n::\nString\n)\n \n->\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nCreate an endpoint\n\n\nThe endpoint becomes part of the federate and is destroyed when the federate is freed so there are no separate free functions for endpoints.\n\n\nArguments\n\n\n\n\nfed\n: the federate object in which to create an endpoint must have been create with helicsCreateMessageFederate or helicsCreateCombinationFederate\n\n\nname\n: the identifier for the endpoint,  this will be prepended with the federate name for the global identifier\n\n\ntype\n: a string describing the expected type of the publication may be NULL\n\n\n\n\nReturns\n\n\n\n\nEndpoint\n object containing the endpoint, nullptr on failure\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterFilter\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_filter_type\n},\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterFromPublicationJSON\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterFromPublicationJSON\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \njson\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalCloningFilter\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterGlobalCloningFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterGlobalEndpoint\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nname\n::\nString\n,\n \nkind\n::\nString\n)\n \n->\n \nHELICS\n.\nEndpoint\n\n\n\n\n\n\nCreate an endpoint\n\n\nThe endpoint becomes part of the federate and is destroyed when the federate is freed so there are no separate free functions for endpoints\n\n\nArguments\n\n\n\n\nfed\n the federate object in which to create an endpoint must have been create with helicsCreateMessageFederate or helicsCreateCombinationFederate\n\n\nname\n the identifier for the endpoint, the given name is the global identifier\n\n\ntype\n a string describing the expected type of the publication may be NULL\n\n\nerr\n a pointer to an error object for catching errors\n\n\n\n\nReturns\n\n\n\n\nEndpoint\n object containing the endpoint, nullptr on failure\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalFilter\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterGlobalFilter\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_filter_type\n},\n \nname\n::\nString\n)\n \n->\n \nHELICS\n.\nFilter\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalInput\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterGlobalInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n})\n \n->\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterGlobalInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalPublication\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterGlobalPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n})\n \n->\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterGlobalPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalTypeInput\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterGlobalTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterGlobalTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterGlobalTypePublication\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterGlobalTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterGlobalTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterInput\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n})\n \n->\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterInterfaces\n \u2014 \nMethod\n.\n\n\nhelicsFederateRegisterInterfaces\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nfile\n::\nString\n)\n\n\n\n\n\n\nLoad interfaces from a file\n\n\nArguments\n\n\n\n\nfed\n: the federate to which to load interfaces\n\n\nfile\n: the name of a file to load the interfaces from either JSON, or TOML\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterPublication\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n})\n \n->\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterPublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_data_type\n},\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterSubscription\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterSubscription\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterSubscription\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterTypeInput\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\nhelicsFederateRegisterTypeInput\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nSubscription\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRegisterTypePublication\n \u2014 \nFunction\n.\n\n\nhelicsFederateRegisterTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\nhelicsFederateRegisterTypePublication\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nkey\n::\nString\n,\n \nkind\n::\nString\n,\n \nunits\n::\nString\n)\n \n->\n \nHELICS\n.\nPublication\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestNextStep\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestNextStep\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nRequest the next time step for federate execution\n\n\nfeds should have setup the period or minDelta for this to work well but it will request the next time step which is the current time plus the minimum time step.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTime\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTime\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n \n->\n \nFloat64\n\n\n\n\n\n\nRequest the next time for federate execution\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next requested time\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate   invalid\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeAdvance\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTimeAdvance\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ntimeDelta\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n \n->\n \nFloat64\n\n\n\n\n\n\nrequest the next time for federate execution\n\n\nArguments\n\n\n\n\nfed\n: The federate to make the request of\n\n\ntimeDelta\n: The requested amount of time to advance\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate, will return\n\n\n\n\nHELICS_TIME_MAXTIME\n if the simulation has terminated invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeAsync\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTimeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nRequest the next time for federate execution in an asynchronous call Call \nhelicsFederateRequestTimeComplete\n to finish the call\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next requested time\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeComplete\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTimeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nComplete an asynchronous requestTime call\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nthe time granted to the federate\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeIterative\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTimeIterative\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n},\n \niterate\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_iteration_request\n})\n\n\n\n\n\n\nRequest an iterative time\n\n\nthis call allows for finer grain control of the iterative process then \nhelicsFederateRequestTime\n it takes a time and iteration request and return a time and iteration status.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next desired time\n\n\niterate\n: the requested iteration mode\n\n\n\n\nReturns\n\n\n\n\nthe granted time\n\n\nthe iteration specification of the result\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeIterativeAsync\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTimeIterativeAsync\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nrequestTime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n},\n \niterate\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_iteration_request\n})\n\n\n\n\n\n\nRequest an iterative time through an asynchronous call\n\n\nthis call allows for finer grain control of the iterative process then \nhelicsFederateRequestTime\n it takes a time an iteration request and returns a time and iteration status call \nhelicsFederateRequestTimeIterativeComplete\n to finish the process.\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\nrequestTime\n: the next desired time\n\n\niterate\n: the requested iteration mode\n\n\n\n\nReturns\n\n\n\n\na void object with a return code of the result\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateRequestTimeIterativeComplete\n \u2014 \nMethod\n.\n\n\nhelicsFederateRequestTimeIterativeComplete\n(\nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nComplete an iterative time request asynchronous call\n\n\nArguments\n\n\n\n\nfed\n: the federate to make the request of\n\n\n\n\nReturns\n\n\n\n\nthe granted time\n\n\noutIterate\n  the iteration specification of the result\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetFlagOption\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetFlagOption\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nflag\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_federate_flags\n},\n \nflagValue\n::\nBool\n)\n\n\n\n\n\n\nSet a flag for the federate\n\n\nArguments\n\n\n\n\nfed\n: the federate to alter a flag for\n\n\nflag\n: the flag to change\n\n\nflagValue\n: the new value of the flag 0 for false !=0 for true\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetGlobal\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetGlobal\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nvalueName\n::\nString\n,\n \nvalue\n::\nString\n)\n\n\n\n\n\n\nSet a federation global value through a federate\n\n\nthis overwrites any previous value for this name\n\n\nArguments\n\n\n\n\nfed\n: the federate to set the global through\n\n\nvalueName\n: the name of the global to set\n\n\nvalue\n: the value of the global\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetIntegerProperty\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetIntegerProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nintProperty\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_properties\n},\n \npropertyVal\n::\nInt64\n)\n\n\n\n\n\n\nSet an integer based property of a federate\n\n\nArguments\n\n\n\n\nfed\n: the federate to change the property for\n\n\nintProperty\n: the property to set\n\n\npropertyVal\n: the value of the property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetLogFile\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetLogFile\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nlogFile\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetLoggingCallback\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetLoggingCallback\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nlogger\n::\nPtr\n{\nNothing\n},\n \nuserdata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetSeparator\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetSeparator\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \nseparator\n::\nChar\n)\n\n\n\n\n\n\nSet the separator character in a federate\n\n\nthe separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName.\n\n\nArguments\n\n\n\n\nfed\n: the \nFederateInfo\n object to alter\n\n\nseparator\n: the character to use as a separator\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFederateSetTimeProperty\n \u2014 \nMethod\n.\n\n\nhelicsFederateSetTimeProperty\n(\nfed\n::\nHELICS\n.\nFederate\n,\n \ntimeProperty\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_properties\n},\n \ntime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nSet a time based property for a federate\n\n\nArguments\n\n\n\n\nfed\n: the \nFederate\n set the property for\n\n\ntimeProperty\n: a integer code for a time property\n\n\ntime\n: the requested value of the property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterAddDeliveryEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsFilterAddDeliveryEndpoint\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ndeliveryEndpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterAddDestinationTarget\n \u2014 \nMethod\n.\n\n\nhelicsFilterAddDestinationTarget\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ndest\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterAddSourceTarget\n \u2014 \nMethod\n.\n\n\nhelicsFilterAddSourceTarget\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \nsource\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterGetInfo\n \u2014 \nMethod\n.\n\n\nhelicsFilterGetInfo\n(\nfilt\n::\nHELICS\n.\nFilter\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterGetName\n \u2014 \nMethod\n.\n\n\nhelicsFilterGetName\n(\nfilt\n::\nHELICS\n.\nFilter\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterGetOption\n \u2014 \nMethod\n.\n\n\nhelicsFilterGetOption\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \noption\n::\nInt64\n)\n \n->\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterRemoveDeliveryEndpoint\n \u2014 \nMethod\n.\n\n\nhelicsFilterRemoveDeliveryEndpoint\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ndeliveryEndpoint\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterRemoveTarget\n \u2014 \nMethod\n.\n\n\nhelicsFilterRemoveTarget\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSet\n \u2014 \nMethod\n.\n\n\nhelicsFilterSet\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \nprop\n::\nString\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSetInfo\n \u2014 \nMethod\n.\n\n\nhelicsFilterSetInfo\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSetOption\n \u2014 \nMethod\n.\n\n\nhelicsFilterSetOption\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \noption\n::\nInt64\n,\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsFilterSetString\n \u2014 \nMethod\n.\n\n\nhelicsFilterSetString\n(\nfilt\n::\nHELICS\n.\nFilter\n,\n \nprop\n::\nString\n,\n \nval\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetFederateByName\n \u2014 \nMethod\n.\n\n\nhelicsGetFederateByName\n(\nfedName\n::\nString\n)\n \n->\n \nHELICS\n.\nCombinationFederate\n\n\n\n\n\n\nGet an existing \nFederate\n from a core by name\n\n\nthe federate must have been created by one of the other functions and at least one of the objects referencing the created     federate must still be active in the process\n\n\nArguments\n\n\n\n\nfedName\n: the name of the federate to retrieve\n\n\n\n\nReturns\n\n\n\n\nNULL if no fed is available by that name otherwise a \nFederate\n with that name\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetOptionIndex\n \u2014 \nMethod\n.\n\n\nhelicsGetOptionIndex\n(\nval\n::\nString\n)\n \n->\n \nInt64\n\n\n\n\n\n\nGet an option index for use in \nhelicsPublicationSetOption\n, \nhelicsInputSetOption\n, \nhelicsEndpointSetOption\n, \nhelicsFilterSetOption\n, and the corresponding get functions\n\n\nArguments\n\n\n\n\nval\n: a string with the option name\n\n\n\n\nReturns\n\n\n\n\nan int with the option index (-1) if not a valid property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetPropertyIndex\n \u2014 \nMethod\n.\n\n\nhelicsGetPropertyIndex\n(\nval\n::\nString\n)\n \n->\n \nInt64\n\n\n\n\n\n\nGet a property index for use in \nhelicsFederateInfoSetFlagOption\n, \nhelicsFederateInfoSetTimeProperty\n, \nhelicsFederateInfoSetIntegerProperty\n\n\nArguments\n\n\n\n\nval\n: a string with the property name\n\n\n\n\nReturns\n\n\n\n\nan int with the property code (-1) if not a valid property\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsGetVersion\n \u2014 \nMethod\n.\n\n\nhelicsGetVersion\n()\n \n->\n \nString\n\n\n\n\n\n\nGet a version string for HELICS\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputAddTarget\n \u2014 \nMethod\n.\n\n\nhelicsInputAddTarget\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputClearUpdate\n \u2014 \nMethod\n.\n\n\nhelicsInputClearUpdate\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetBoolean\n \u2014 \nMethod\n.\n\n\nhelicsInputGetBoolean\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetChar\n \u2014 \nMethod\n.\n\n\nhelicsInputGetChar\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nChar\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetComplex\n \u2014 \nMethod\n.\n\n\nhelicsInputGetComplex\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nComplex\n{\nFloat64\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetComplexObject\n \u2014 \nMethod\n.\n\n\nhelicsInputGetComplexObject\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nComplex\n{\nFloat64\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetDouble\n \u2014 \nMethod\n.\n\n\nhelicsInputGetDouble\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetExtractionUnits\n \u2014 \nMethod\n.\n\n\nhelicsInputGetExtractionUnits\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetInfo\n \u2014 \nMethod\n.\n\n\nhelicsInputGetInfo\n(\ninp\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetInjectionUnits\n \u2014 \nMethod\n.\n\n\nhelicsInputGetInjectionUnits\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetInteger\n \u2014 \nMethod\n.\n\n\nhelicsInputGetInteger\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetKey\n \u2014 \nMethod\n.\n\n\nhelicsInputGetKey\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetNamedPoint\n \u2014 \nMethod\n.\n\n\nhelicsInputGetNamedPoint\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nTuple\n{\nString\n,\nFloat64\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetOption\n \u2014 \nMethod\n.\n\n\nhelicsInputGetOption\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \noption\n::\nInt64\n)\n \n->\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetPublicationType\n \u2014 \nMethod\n.\n\n\nhelicsInputGetPublicationType\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetRawValue\n \u2014 \nMethod\n.\n\n\nhelicsInputGetRawValue\n(\nipt\n::\nT\n,\n \ndata\n::\nT\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetRawValueSize\n \u2014 \nMethod\n.\n\n\nhelicsInputGetRawValueSize\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetString\n \u2014 \nMethod\n.\n\n\nhelicsInputGetString\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetStringSize\n \u2014 \nMethod\n.\n\n\nhelicsInputGetStringSize\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetTime\n \u2014 \nMethod\n.\n\n\nhelicsInputGetTime\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetType\n \u2014 \nMethod\n.\n\n\nhelicsInputGetType\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetUnits\n \u2014 \nMethod\n.\n\n\nhelicsInputGetUnits\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetVector\n \u2014 \nMethod\n.\n\n\nhelicsInputGetVector\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nArray\n{\nFloat64\n,\n1\n}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputGetVectorSize\n \u2014 \nMethod\n.\n\n\nhelicsInputGetVectorSize\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nInt64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputIsUpdated\n \u2014 \nMethod\n.\n\n\nhelicsInputIsUpdated\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputLastUpdateTime\n \u2014 \nMethod\n.\n\n\nhelicsInputLastUpdateTime\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultBoolean\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultBoolean\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultChar\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultChar\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nChar\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultComplex\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultComplex\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nc\n::\nComplex\n{\nFloat64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultDouble\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultDouble\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultInteger\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultInteger\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nInt64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultNamedPoint\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultNamedPoint\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nstr\n::\nString\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultRaw\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultRaw\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \ndata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultString\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultString\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nstr\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultTime\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultTime\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nval\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetDefaultVector\n \u2014 \nMethod\n.\n\n\nhelicsInputSetDefaultVector\n(\nipt\n::\nHELICS\n.\nSubscription\n,\n \nvectorInput\n::\nArray\n{\nFloat64\n,\n1\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetInfo\n \u2014 \nMethod\n.\n\n\nhelicsInputSetInfo\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetMinimumChange\n \u2014 \nMethod\n.\n\n\nhelicsInputSetMinimumChange\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \ntolerance\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsInputSetOption\n \u2014 \nMethod\n.\n\n\nhelicsInputSetOption\n(\ninp\n::\nHELICS\n.\nSubscription\n,\n \noption\n::\nInt64\n,\n \nvalue\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsIsCoreTypeAvailable\n \u2014 \nMethod\n.\n\n\nhelicsIsCoreTypeAvailable\n(\nkind\n::\nString\n)\n \n->\n \nBool\n\n\n\n\n\n\nReturns true if core/broker type specified is available in current compilation.\n\n\nArguments\n\n\n\n\ntype\n: a string representing a core type\n\n\n\n\nReturns\n\n\n\n\na \nBool\n\n\n\n\npossible options include \"test\",\"zmq\",\"udp\",\"ipc\",\"interprocess\",\"tcp\",\"default\", \"mpi\"\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageAppendData\n \u2014 \nMethod\n.\n\n\nhelicsMessageAppendData\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \ndata\n::\nString\n)\n\n\n\n\n\n\nAppend data to the payload\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\ndata\n: A string containing the message data to append\n\n\ninputDataLength\n: The length of the data to input\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageCheckFlag\n \u2014 \nMethod\n.\n\n\nhelicsMessageCheckFlag\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nflag\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_federate_flags\n})\n \n->\n \nBool\n\n\n\n\n\n\nCheck if a flag is set on a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nflag\n: The flag to check should be between [0,15]\n\n\n\n\nReturns\n\n\n\n\nthe flags associated with a message\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageClearFlags\n \u2014 \nMethod\n.\n\n\nhelicsMessageClearFlags\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n\n\n\n\n\n\nClear the flags of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetDestination\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetDestination\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the destination endpoint of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\na string with the destination endpoint\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetMessageID\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetMessageID\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nInt64\n\n\n\n\n\n\nGet the messageID of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\nthe messageID\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetOriginalDestination\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetOriginalDestination\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the original destination endpoint of a message, the destination may have been modified by filters or other actions\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\na string with the original destination of a message\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetOriginalSource\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetOriginalSource\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the original source endpoint of a message, the source may have modified by filters or other actions\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\na string with the source of a message\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetRawData\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetRawData\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the raw data for a message object\n\n\n\n\nmessage\n: A message object to get the data for\n\n\ndata\n: The memory location of the data\n\n\nmaxMessagelen\n: The maximum size of information that data can hold\n\n\nactualSize\n: The actual length of data copied to data\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetRawDataPointer\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetRawDataPointer\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nPtr\n{\nNothing\n}\n\n\n\n\n\n\nGet a pointer to the raw data of a message\n\n\nArguments\n\n\n\n\nmessage\n: A message object to get the data for\n\n\n\n\nReturns\n\n\n\n\na pointer to the raw data in memory, the\n\n\n\n\npointer may be NULL if the message is not a valid message\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetRawDataSize\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetRawDataSize\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nInt64\n\n\n\n\n\n\nGet the size of the data payload in bytes\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\nthe size of the data payload\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetSource\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetSource\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the source endpoint of a message\n\n\n message operation functions\n\n\n\n\n\n\nfunctions for working with helics message envelopes\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\na string with the source endpoint\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetString\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetString\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nString\n\n\n\n\n\n\nGet the payload of a message as a string\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\na string representing the payload of a message\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageGetTime\n \u2014 \nMethod\n.\n\n\nhelicsMessageGetTime\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nFloat64\n\n\n\n\n\n\nGet the helics time associated with a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\nthe time associated with a message\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageIsValid\n \u2014 \nMethod\n.\n\n\nhelicsMessageIsValid\n(\nmessage\n::\nHELICS\n.\nMessage\n)\n \n->\n \nBool\n\n\n\n\n\n\nA check if the message contains a valid payload\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\n\n\nReturns\n\n\n\n\ntrue if the message contains a payload\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageReserve\n \u2014 \nMethod\n.\n\n\nhelicsMessageReserve\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nreserveSize\n::\nInt64\n)\n\n\n\n\n\n\nReserve space in a buffer but don't actually resize\n\n\nthe message data buffer will be reserved but not resized\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nreserveSize\n: The number of bytes to reserve in the message object\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageResize\n \u2014 \nMethod\n.\n\n\nhelicsMessageResize\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nnewSize\n::\nInt64\n)\n\n\n\n\n\n\nResize the data buffer for a message\n\n\nthe message data buffer will be resized there is no guarantees on what is in the buffer in newly allocated space if the allocated space is not sufficient new allocations will occur\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nnewSize\n: The new size in bytes of the buffer\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetData\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetData\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \ndata\n::\nString\n)\n\n\n\n\n\n\nSet the data payload of a message as raw data\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\ndata\n: A string containing the message data\n\n\ninputDataLength\n: The length of the data to input\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetDestination\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetDestination\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \ndest\n::\nString\n)\n\n\n\n\n\n\nSet the destination of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\ndest\n: A string containing the new destination\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetFlagOption\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetFlagOption\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nflag\n::\nUnion\n{\nInt64\n,\n \nHELICS\n.\nLib\n.\nhelics_federate_flags\n},\n \nflagValue\n::\nBool\n)\n\n\n\n\n\n\nSet a flag on a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nflag\n: An index of a flag to set on the message\n\n\nflagValue\n: The desired value of the flag\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetMessageID\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetMessageID\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nmessageID\n::\nInt32\n)\n\n\n\n\n\n\nSet the message ID for the message\n\n\nnormally this is not needed and the core of HELICS will adjust as needed\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nmessageID\n: A new message ID\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetOriginalDestination\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetOriginalDestination\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \ndest\n::\nString\n)\n\n\n\n\n\n\nSet the original destination of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\ndest\n: A string containing the new original source\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetOriginalSource\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetOriginalSource\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nsrc\n::\nString\n)\n\n\n\n\n\n\nSet the original source of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nsrc\n: A string containing the new original source\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetSource\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetSource\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nsrc\n::\nString\n)\n\n\n\n\n\n\nSet the source of a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nsrc\n: A string containing the source\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetString\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetString\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \nstr\n::\nString\n)\n\n\n\n\n\n\nSet the data payload of a message as a string\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\nstr\n: A string containing the message data\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsMessageSetTime\n \u2014 \nMethod\n.\n\n\nhelicsMessageSetTime\n(\nmessage\n::\nHELICS\n.\nMessage\n,\n \ntime\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nSet the delivery time for a message\n\n\nArguments\n\n\n\n\nmessage\n: The message object in question\n\n\ntime\n: The time the message should be delivered\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationAddTarget\n \u2014 \nMethod\n.\n\n\nhelicsPublicationAddTarget\n(\npub\n::\nHELICS\n.\nPublication\n,\n \ntarget\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetInfo\n \u2014 \nMethod\n.\n\n\nhelicsPublicationGetInfo\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetKey\n \u2014 \nMethod\n.\n\n\nhelicsPublicationGetKey\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetOption\n \u2014 \nMethod\n.\n\n\nhelicsPublicationGetOption\n(\npub\n::\nHELICS\n.\nPublication\n,\n \noption\n::\nInt64\n)\n \n->\n \nBool\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetType\n \u2014 \nMethod\n.\n\n\nhelicsPublicationGetType\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationGetUnits\n \u2014 \nMethod\n.\n\n\nhelicsPublicationGetUnits\n(\npub\n::\nHELICS\n.\nPublication\n)\n \n->\n \nString\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishBoolean\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishBoolean\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishChar\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishChar\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nChar\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishComplex\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishComplex\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nc\n::\nComplex\n{\nFloat64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishDouble\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishDouble\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishInteger\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishInteger\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nInt64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishNamedPoint\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishNamedPoint\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nstr\n::\nString\n,\n \nval\n::\nFloat64\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishRaw\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishRaw\n(\npub\n::\nHELICS\n.\nPublication\n,\n \ndata\n::\nAny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishString\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishString\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nstr\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishTime\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishTime\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nval\n::\nUnion\n{\nFloat64\n,\n \nInt64\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationPublishVector\n \u2014 \nMethod\n.\n\n\nhelicsPublicationPublishVector\n(\npub\n::\nHELICS\n.\nPublication\n,\n \nvectorInput\n::\nArray\n{\nFloat64\n,\n1\n})\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationSetInfo\n \u2014 \nMethod\n.\n\n\nhelicsPublicationSetInfo\n(\npub\n::\nHELICS\n.\nPublication\n,\n \ninfo\n::\nString\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsPublicationSetOption\n \u2014 \nMethod\n.\n\n\nhelicsPublicationSetOption\n(\npub\n::\nHELICS\n.\nPublication\n,\n \noption\n::\nInt64\n,\n \nval\n::\nBool\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryBrokerExecute\n \u2014 \nMethod\n.\n\n\nhelicsQueryBrokerExecute\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \nbroker\n::\nHELICS\n.\nBroker\n)\n \n->\n \nString\n\n\n\n\n\n\nExecute a \nQuery\n directly on a broker\n\n\nthe call will block until the \nQuery\n finishes which may require communication or other delays\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\nbroker\n: the broker to send the \nQuery\n to\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if fed or \nQuery\n is an invalid object, the return string will be \"#invalid\" if the \nQuery\n itself was invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryCoreExecute\n \u2014 \nMethod\n.\n\n\nhelicsQueryCoreExecute\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \ncore\n::\nHELICS\n.\nCore\n)\n \n->\n \nString\n\n\n\n\n\n\nExecute a \nQuery\n directly on a core\n\n\nthe call will block until the \nQuery\n finishes which may require communication or other delays\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\ncore\n: the core to send the \nQuery\n to\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if fed or \nQuery\n is an invalid object, the return string will be \"#invalid\" if the \nQuery\n itself was invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryExecute\n \u2014 \nMethod\n.\n\n\nhelicsQueryExecute\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \nfed\n::\nHELICS\n.\nFederate\n)\n \n->\n \nString\n\n\n\n\n\n\nExecute a query\n\n\nthe call will block until the \nQuery\n finishes which may require communication or other delays\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\nfed\n: a federate to send the \nQuery\n through\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if fed or \nQuery\n is an invalid object, the return string will be \"#invalid\" if the \nQuery\n itself was invalid\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryExecuteAsync\n \u2014 \nMethod\n.\n\n\nhelicsQueryExecuteAsync\n(\nquery\n::\nHELICS\n.\nQuery\n,\n \nfed\n::\nHELICS\n.\nFederate\n)\n\n\n\n\n\n\nExecute a \nQuery\n in a non-blocking call\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to use in the query\n\n\nfed\n: a federate to send the \nQuery\n through\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryExecuteComplete\n \u2014 \nMethod\n.\n\n\nhelicsQueryExecuteComplete\n(\nquery\n::\nHELICS\n.\nQuery\n)\n \n->\n \nString\n\n\n\n\n\n\nComplete the return from a \nQuery\n called with \nhelicsQueryExecuteAsync\n\n\nthe function will block until the \nQuery\n completes \nhelicsQueryIsCompleted\n can be called to determine if a \nQuery\n has completed or not.\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to complete execution of\n\n\n\n\nReturns\n\n\n\n\na string. String will remain valid until the \nQuery\n is freed or executed again\n\n\n\n\nthe return will be nullptr if \nQuery\n is an invalid object\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryFree\n \u2014 \nMethod\n.\n\n\nhelicsQueryFree\n(\nquery\n::\nHELICS\n.\nQuery\n)\n\n\n\n\n\n\nFree the memory associated with a \nQuery\n\n\nsource\n\n\n#\n\n\nHELICS.helicsQueryIsCompleted\n \u2014 \nMethod\n.\n\n\nhelicsQueryIsCompleted\n(\nquery\n::\nHELICS\n.\nQuery\n)\n \n->\n \nBool\n\n\n\n\n\n\nCheck if an asynchronously executed \nQuery\n has completed\n\n\nthis function should usually be called after a QueryExecuteAsync function has been called.\n\n\nArguments\n\n\n\n\nquery\n: the \nQuery\n to check if completed\n\n\n\n\nReturns\n\n\n\n\nwill return \ntrue\n if an asynchronous \nQuery\n has complete or a regular \nQuery\n call was made with a result and \nfalse\n if an asynchronous \nQuery\n has not completed or is invalid\n\n\n\n\nsource\n\n\n#\n\n\nHELICS.helicsSubscriptionGetKey\n \u2014 \nMethod\n.\n\n\nhelicsSubscriptionGetKey\n(\nipt\n::\nHELICS\n.\nSubscription\n)\n \n->\n \nString\n\n\n\n\n\n\nsource",
            "title": "API"
        },
        {
            "location": "/api/#api",
            "text": "#  HELICS.Broker  \u2014  Type .  Summary  struct  HELICS.Broker  <:  HELICS.CWrapper  source  #  HELICS.CWrapper  \u2014  Type .  Summary  abstract type HELICS.CWrapper  source  #  HELICS.CombinationFederate  \u2014  Type .  Summary  struct  HELICS.CombinationFederate  <:  HELICS.Federate  source  #  HELICS.Core  \u2014  Type .  Summary  struct  HELICS.Core  <:  HELICS.CWrapper  source  #  HELICS.Endpoint  \u2014  Type .  Summary  struct  HELICS.Endpoint  <:  HELICS.CWrapper  source  #  HELICS.Federate  \u2014  Type .  Summary  abstract type HELICS.Federate <: HELICS.CWrapper  Subtypes   HELICS.CombinationFederate  HELICS.MessageFederate  HELICS.ValueFederate   Supertype Hierarchy  HELICS.Federate <: HELICS.CWrapper <: Any  source  #  HELICS.FederateInfo  \u2014  Type .  Summary  struct  HELICS.FederateInfo  <:  HELICS.CWrapper  source  #  HELICS.Filter  \u2014  Type .  Summary  struct  HELICS.Filter  <:  HELICS.CWrapper  source  #  HELICS.HELICS_CORE_TYPE  \u2014  Type .   HELICS_CORE_TYPE_DEFAULT : 0  HELICS_CORE_TYPE_ZMQ : 1  HELICS_CORE_TYPE_MPI : 2  HELICS_CORE_TYPE_TEST : 3  HELICS_CORE_TYPE_INTERPROCESS : 4  HELICS_CORE_TYPE_IPC : 5  HELICS_CORE_TYPE_TCP : 6  HELICS_CORE_TYPE_UDP : 7  HELICS_CORE_TYPE_ZMQ_TEST : 10  HELICS_CORE_TYPE_NNG : 9  HELICS_CORE_TYPE_TCP_SS : 11  HELICS_CORE_TYPE_HTTP : 12  HELICS_CORE_TYPE_WEBSOCKET : 14  HELICS_CORE_TYPE_INPROC : 18  HELICS_CORE_TYPE_NULL : 66   source  #  HELICS.HELICS_DATA_TYPE  \u2014  Type .   HELICS_DATA_TYPE_STRING : 0  HELICS_DATA_TYPE_DOUBLE : 1  HELICS_DATA_TYPE_INT : 2  HELICS_DATA_TYPE_COMPLEX : 3  HELICS_DATA_TYPE_VECTOR : 4  HELICS_DATA_TYPE_COMPLEX_VECTOR : 5  HELICS_DATA_TYPE_NAMED_POINT : 6  HELICS_DATA_TYPE_BOOLEAN : 7  HELICS_DATA_TYPE_TIME : 8  HELICS_DATA_TYPE_RAW : 25  HELICS_DATA_TYPE_ANY : 25262   source  #  HELICS.HELICS_ERROR_TYPES  \u2014  Type .   HELICS_OK : 0  HELICS_ERROR_REGISTRATION_FAILURE : -1  HELICS_ERROR_CONNECTION_FAILURE : -2  HELICS_ERROR_INVALID_OBJECT : -3  HELICS_ERROR_INVALID_ARGUMENT : -4  HELICS_ERROR_DISCARD : -5  HELICS_ERROR_SYSTEM_FAILURE : -6  HELICS_WARNING : -8  HELICS_ERROR_INVALID_STATE_TRANSITION : -9  HELICS_ERROR_INVALID_FUNCTION_CALL : -10  HELICS_ERROR_EXECUTION_FAILURE : -14  HELICS_ERROR_INSUFFICIENT_SPACE : -18  HELICS_ERROR_OTHER : -101  HELICS_ERROR_FATAL : -404  HELICS_ERROR_EXTERNAL_TYPE : -203   source  #  HELICS.HELICS_FEDERATE_FLAGS  \u2014  Type .   HELICS_FLAG_OBSERVER : 0  HELICS_FLAG_UNINTERRUPTIBLE : 1  HELICS_FLAG_INTERRUPTIBLE : 2  HELICS_FLAG_SOURCE_ONLY : 4  HELICS_FLAG_ONLY_TRANSMIT_ON_CHANGE : 6  HELICS_FLAG_ONLY_UPDATE_ON_CHANGE : 8  HELICS_FLAG_WAIT_FOR_CURRENT_TIME_UPDATE : 10  HELICS_FLAG_RESTRICTIVE_TIME_POLICY : 11  HELICS_FLAG_ROLLBACK : 12  HELICS_FLAG_FORWARD_COMPUTE : 14  HELICS_FLAG_REALTIME : 16  HELICS_FLAG_SINGLE_THREAD_FEDERATE : 27  HELICS_FLAG_SLOW_RESPONDING : 29  HELICS_FLAG_DELAY_INIT_ENTRY : 45  HELICS_FLAG_ENABLE_INIT_ENTRY : 47  HELICS_FLAG_IGNORE_TIME_MISMATCH_WARNINGS : 67  HELICS_FLAG_TERMINATE_ON_ERROR : 72   source  #  HELICS.HELICS_FEDERATE_STATE  \u2014  Type .   HELICS_STATE_STARTUP : 0  HELICS_STATE_INITIALIZATION : 1  HELICS_STATE_EXECUTION : 2  HELICS_STATE_FINALIZE : 3  HELICS_STATE_ERROR : 4  HELICS_STATE_PENDING_INIT : 5  HELICS_STATE_PENDING_EXEC : 6  HELICS_STATE_PENDING_TIME : 7  HELICS_STATE_PENDING_ITERATIVE_TIME : 8  HELICS_STATE_PENDING_FINALIZE : 9   source  #  HELICS.HELICS_FILTER_TYPE  \u2014  Type .   HELICS_FILTER_TYPE_CUSTOM : 0  HELICS_FILTER_TYPE_DELAY : 1  HELICS_FILTER_TYPE_RANDOM_DELAY : 2  HELICS_FILTER_TYPE_RANDOM_DROP : 3  HELICS_FILTER_TYPE_REROUTE : 4  HELICS_FILTER_TYPE_CLONE : 5  HELICS_FILTER_TYPE_FIREWALL : 6   source  #  HELICS.HELICS_HANDLE_OPTIONS  \u2014  Type .   HELICS_HANDLE_OPTION_CONNECTION_REQUIRED : 397  HELICS_HANDLE_OPTION_CONNECTION_OPTIONAL : 402  HELICS_HANDLE_OPTION_SINGLE_CONNECTION_ONLY : 407  HELICS_HANDLE_OPTION_MULTIPLE_CONNECTIONS_ALLOWED : 409  HELICS_HANDLE_OPTION_BUFFER_DATA : 411  HELICS_HANDLE_OPTION_STRICT_TYPE_CHECKING : 414  HELICS_HANDLE_OPTION_IGNORE_UNIT_MISMATCH : 447  HELICS_HANDLE_OPTION_ONLY_TRANSMIT_ON_CHANGE : 6  HELICS_HANDLE_OPTION_ONLY_UPDATE_ON_CHANGE : 8  HELICS_HANDLE_OPTION_IGNORE_INTERRUPTS : 475   source  #  HELICS.HELICS_ITERATION_REQUEST  \u2014  Type .   HELICS_ITERATION_REQUEST_NO_ITERATION : 0  HELICS_ITERATION_REQUEST_FORCE_ITERATION : 1  HELICS_ITERATION_REQUEST_ITERATE_IF_NEEDED : 2   source  #  HELICS.HELICS_ITERATION_RESULT  \u2014  Type .   HELICS_ITERATION_RESULT_NEXT_STEP : 0  HELICS_ITERATION_RESULT_ERROR : 1  HELICS_ITERATION_RESULT_HALTED : 2  HELICS_ITERATION_RESULT_ITERATING : 3   source  #  HELICS.HELICS_LOG_LEVELS  \u2014  Type .   HELICS_LOG_LEVEL_NO_PRINT : -1  HELICS_LOG_LEVEL_ERROR : 0  HELICS_LOG_LEVEL_WARNING : 1  HELICS_LOG_LEVEL_SUMMARY : 2  HELICS_LOG_LEVEL_CONNECTIONS : 3  HELICS_LOG_LEVEL_INTERFACES : 4  HELICS_LOG_LEVEL_TIMING : 5  HELICS_LOG_LEVEL_DATA : 6  HELICS_LOG_LEVEL_TRACE : 7   source  #  HELICS.HELICS_PROPERTIES  \u2014  Type .   HELICS_PROPERTY_TIME_DELTA : 137  HELICS_PROPERTY_TIME_PERIOD : 140  HELICS_PROPERTY_TIME_OFFSET : 141  HELICS_PROPERTY_TIME_RT_LAG : 143  HELICS_PROPERTY_TIME_RT_LEAD : 144  HELICS_PROPERTY_TIME_RT_TOLERANCE : 145  HELICS_PROPERTY_TIME_INPUT_DELAY : 148  HELICS_PROPERTY_TIME_OUTPUT_DELAY : 150  HELICS_PROPERTY_INT_MAX_ITERATIONS : 259  HELICS_PROPERTY_INT_LOG_LEVEL : 271  HELICS_PROPERTY_INT_FILE_LOG_LEVEL : 272  HELICS_PROPERTY_INT_CONSOLE_LOG_LEVEL : 274   source  #  HELICS.Message  \u2014  Type .  Summary  struct  HELICS.Message  <:  HELICS.CWrapper  source  #  HELICS.MessageFederate  \u2014  Type .  Summary  struct  HELICS.MessageFederate  <:  HELICS.Federate  source  #  HELICS.Publication  \u2014  Type .  Summary  struct  HELICS.Publication  <:  HELICS.CWrapper  source  #  HELICS.Query  \u2014  Type .  Summary  struct  HELICS.Query  <:  HELICS.CWrapper  source  #  HELICS.Subscription  \u2014  Type .  Summary  struct  HELICS.Subscription  <:  HELICS.CWrapper  source  #  HELICS.ValueFederate  \u2014  Type .  Summary  struct  HELICS.ValueFederate  <:  HELICS.Federate  source  #  HELICS.helicsBrokerAddDestinationFilterToEndpoint  \u2014  Method .  helicsBrokerAddDestinationFilterToEndpoint ( broker :: HELICS . Broker ,   filter :: String ,   endpoint :: String )   source  #  HELICS.helicsBrokerAddSourceFilterToEndpoint  \u2014  Method .  helicsBrokerAddSourceFilterToEndpoint ( broker :: HELICS . Broker ,   filter :: String ,   endpoint :: String )   source  #  HELICS.helicsBrokerClone  \u2014  Method .  helicsBrokerClone ( broker :: HELICS . Broker )   ->   HELICS . Broker   Create a new reference to an existing broker  this will create a new broker object that references the existing broker it must be freed as well  Arguments   broker : an existing  Broker   Returns   a new reference to the same broker   source  #  HELICS.helicsBrokerDataLink  \u2014  Method .  helicsBrokerDataLink ( broker :: HELICS . Broker ,   source :: String ,   target :: String )   Link a named publication and named input using a broker  Arguments   broker : the  Broker  to generate the connection from  source : the name of the publication (cannot be NULL)  target : the name of the target to send the publication data (cannot be NULL)   source  #  HELICS.helicsBrokerDestroy  \u2014  Method .  helicsBrokerDestroy ( broker :: HELICS . Broker )   Disconnect and free a broker  source  #  HELICS.helicsBrokerDisconnect  \u2014  Method .  helicsBrokerDisconnect ( broker :: HELICS . Broker )   Disconnect a broker  Arguments   broker : the broker to disconnect   source  #  HELICS.helicsBrokerFree  \u2014  Method .  helicsBrokerFree ( broker :: HELICS . Broker )   Release the memory associated with a broker  source  #  HELICS.helicsBrokerGetAddress  \u2014  Method .  helicsBrokerGetAddress ( broker :: HELICS . Broker )   ->   String   Get the network address associated with a broker  Arguments   broker : the broker to query   Returns   a string with the network address of the broker   source  #  HELICS.helicsBrokerGetIdentifier  \u2014  Method .  helicsBrokerGetIdentifier ( broker :: HELICS . Broker )   ->   String   Get an identifier for the broker  Arguments   broker : the broker to query   Returns   a string containing the identifier for the broker   source  #  HELICS.helicsBrokerIsConnected  \u2014  Method .  helicsBrokerIsConnected ( broker :: HELICS . Broker )   ->   Bool   Check if a broker is connected. A connected broker implies is attached to cores or cores could reach out to communicate. return 0 if not connected , something else if it is connected.  source  #  HELICS.helicsBrokerIsValid  \u2014  Method .  helicsBrokerIsValid ( broker :: HELICS . Broker )   ->   Bool   Check if a broker object is a valid object  Arguments   broker : the  Broker  object to test   source  #  HELICS.helicsBrokerMakeConnections  \u2014  Method .  helicsBrokerMakeConnections ( broker :: HELICS . Broker ,   file :: String )   Load a file containing connection information  Arguments   broker : The broker to generate the connections from  file : A JSON or TOML file containing connection information   source  #  HELICS.helicsBrokerSetGlobal  \u2014  Method .  helicsBrokerSetGlobal ( broker :: HELICS . Broker ,   valueName :: String ,   value :: String )   Set a federation global value  this overwrites any previous value for this name  Arguments   broker : the broker to set the global through  valueName : the name of the global to set  value : the value of the global   source  #  HELICS.helicsBrokerSetLogFile  \u2014  Method .  helicsBrokerSetLogFile ( broker :: HELICS . Broker ,   logFileName :: String )   Set a the log file on a broker  Arguments   broker : The broker to set the global through  logFileName : The name of the file to log to   source  #  HELICS.helicsBrokerSetLoggingCallback  \u2014  Method .  helicsBrokerSetLoggingCallback ( broker :: HELICS . Broker ,   logger :: Ptr { Nothing },   userdata :: Any )   source  #  HELICS.helicsBrokerWaitForDisconnect  \u2014  Method .  helicsBrokerWaitForDisconnect ( broker :: HELICS . Broker ,   msToWait :: Int64 )   ->   Bool   Wait for the broker to disconnect  Arguments   broker : the broker to wait for  msToWait : the time out in millisecond (<0 for infinite timeout)   Returns   true  if the disconnect was successful,  false  if there was a timeout   source  #  HELICS.helicsCleanupLibrary  \u2014  Method .  helicsCleanupLibrary ()   Function to do some housekeeping work  this runs some cleanup routines and tries to close out any residual thread that haven't been shutdown yet.  source  #  HELICS.helicsCloseLibrary  \u2014  Method .  helicsCloseLibrary ()   Call when done using the helics library,  this function will ensure the threads are closed properly if possible     this should be the last call before exiting,  source  #  HELICS.helicsCoreAddDestinationFilterToEndpoint  \u2014  Method .  helicsCoreAddDestinationFilterToEndpoint ( core :: HELICS . Core ,   filter :: String ,   endpoint :: String )   source  #  HELICS.helicsCoreAddSourceFilterToEndpoint  \u2014  Method .  helicsCoreAddSourceFilterToEndpoint ( core :: HELICS . Core ,   filter :: String ,   endpoint :: String )   Link a named filter to a source endpoint  Arguments   core : the core to generate the connection from  filter : the name of the filter (cannot be NULL)  endpoint : the name of the endpoint to filter the data from (cannot be NULL)   source  #  HELICS.helicsCoreClone  \u2014  Method .  helicsCoreClone ( core :: HELICS . Core )   ->   HELICS . Core   Create a new reference to an existing core  this will create a new broker object that references the existing broker it must be freed as well  Arguments   core : an existing  Core   Returns   a new reference to the same  Core   source  #  HELICS.helicsCoreDataLink  \u2014  Method .  helicsCoreDataLink ( core :: HELICS . Core ,   source :: String ,   target :: String )   Link a named publication and named input using a core  Arguments   core : the core to generate the connection from  source : the name of the publication (cannot be NULL)  target : the named of the target to send the publication data (cannot be NULL)   source  #  HELICS.helicsCoreDestroy  \u2014  Method .  helicsCoreDestroy ( core :: HELICS . Core )   Disconnect and free a core  source  #  HELICS.helicsCoreDisconnect  \u2014  Method .  helicsCoreDisconnect ( core :: HELICS . Core )   Get an identifier for the core  Arguments   core : the core to query   Returns   a void enumeration indicating any error condition   source  #  HELICS.helicsCoreFree  \u2014  Method .  helicsCoreFree ( core :: HELICS . Core )   Release the memory associated with a core  source  #  HELICS.helicsCoreGetAddress  \u2014  Method .  helicsCoreGetAddress ( core :: HELICS . Core )   ->   String   Get the network address associated with a core  Arguments   core : The core to query   Returns   a string with the network address of the broker   source  #  HELICS.helicsCoreGetIdentifier  \u2014  Method .  helicsCoreGetIdentifier ( core :: HELICS . Core )   ->   String   Get an identifier for the core  Arguments   core : the core to query   Returns   a string with the identifier of the core   source  #  HELICS.helicsCoreIsConnected  \u2014  Method .  helicsCoreIsConnected ( core :: HELICS . Core )   ->   Bool   Check if a core is connected. A connected core implies is attached to federate or federates could be attached to it.  Returns   false  if not connected,  true  if it is connected   source  #  HELICS.helicsCoreIsValid  \u2014  Method .  helicsCoreIsValid ( core :: HELICS . Core )   ->   Bool   Check if a core object is a valid object  Arguments   core : the  Core  object to test   source  #  HELICS.helicsCoreMakeConnections  \u2014  Method .  helicsCoreMakeConnections ( core :: HELICS . Core ,   file :: String )   Load a file containing connection information  Arguments   core : The core to generate the connections from  file : A JSON or TOML file containing connection information   source  #  HELICS.helicsCoreRegisterCloningFilter  \u2014  Method .  helicsCoreRegisterCloningFilter ( core :: HELICS . Core ,   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsCoreRegisterFilter  \u2014  Method .  helicsCoreRegisterFilter ( core :: HELICS . Core ,   kind :: Union { Int64 ,   HELICS . Lib . helics_filter_type },   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsCoreSetGlobal  \u2014  Method .  helicsCoreSetGlobal ( core :: HELICS . Core ,   valueName :: String ,   value :: String )   Set a global value in a core  this overwrites any previous value for this name  Arguments   core : the core to set the global through  valueName : the name of the global to set  value : the value of the global   source  #  HELICS.helicsCoreSetLogFile  \u2014  Method .  helicsCoreSetLogFile ( core :: HELICS . Core ,   logFileName :: String )   Set a the log file on a core  Arguments   core : The core to set the global through  logFileName : The name of the file to log to   source  #  HELICS.helicsCoreSetLoggingCallback  \u2014  Method .  helicsCoreSetLoggingCallback ( core :: HELICS . Core ,   logger :: Ptr { Nothing },   userdata :: Any )   source  #  HELICS.helicsCoreSetReadyToInit  \u2014  Method .  helicsCoreSetReadyToInit ( core :: HELICS . Core )   Set the core to ready for init  this function is used for cores that have filters but no federates so there needs to be a direct signal to the core to trigger the federation initialization  Arguments   core : the core object to enable init values for   source  #  HELICS.helicsCoreWaitForDisconnect  \u2014  Method .  helicsCoreWaitForDisconnect ( core :: HELICS . Core ,   msWait :: Int64 )   ->   Int32   Wait for the core to disconnect  Arguments   core : The core to wait for  msToWait : The time out in millisecond (<0 for infinite timeout)   Returns  true  if the disconnect was successful,  false  if there was a timeout  source  #  HELICS.helicsCreateBroker  \u2014  Method .  helicsCreateBroker ( kind :: String ,   name :: String ,   initString :: String )   ->   HELICS . Broker   Create a broker object  Arguments   type : the type of the broker to create  name : the name of the broker , may be a nullptr or empty string to have a name automatically assigned  initString : an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" if this is a subbroker or the number of federates or the address   Returns   a  Broker  object, will be NULL if there was an error indicated in the err object   source  <a id='HELICS.helicsCreateBrokerFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}' href='#HELICS.helicsCreateBrokerFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}'>#  HELICS.helicsCreateBrokerFromArgs  \u2014  Method .  helicsCreateBrokerFromArgs ( kind :: String ,   name :: String ,   argc :: Int64 ,   argv :: Array { #s45,1} where #s45<:AbstractString) -> HELICS.Broker   source  #  HELICS.helicsCreateCombinationFederate  \u2014  Method .  helicsCreateCombinationFederate ( fedName :: String ,   fi :: HELICS . FederateInfo )   ->   HELICS . CombinationFederate   Create a  CombinationFederate  from a  FederateInfo  object  CombinationFederate  are both  ValueFederate  and  MessageFederate , objects can be used in all functions that take a  Federate ,  MessageFederate  or  ValueFederate  object as an argument  Arguments   fedName : a string with the name of the federate, can be NULL or an empty string to pull the default name from fi  fi : the  FederateInfo  object that contains details on the federate   Returns   an opaque  ValueFederate , nullptr if the object creation failed   source  #  HELICS.helicsCreateCombinationFederateFromConfig  \u2014  Method .  helicsCreateCombinationFederateFromConfig ( configFile :: String )   ->   HELICS . CombinationFederate   Create a  CombinationFederate  from a JSON file or JSON string  CombinationFederate  are both  ValueFederate  and  MessageFederate , objects can be used in all functions that take a  Federate ,  MessageFederate  or  ValueFederate  object as an argument  Arguments   configFile :  a JSON file or a JSON string or TOML file that contains setup and configuration information   Returns   an opaque  CombinationFederate   source  #  HELICS.helicsCreateCore  \u2014  Method .  helicsCreateCore ( kind :: String ,   name :: String ,   initString :: String )   ->   HELICS . Core   Create a core object  Arguments   type : the type of the core to create  name : the name of the core , may be a nullptr or empty string to have a name automatically assigned  initString : an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  \u2013broker=\"XSSAF\" or the number of federates or the address   Returns   a  Core  object if the core is invalid err will contain some indication   source  <a id='HELICS.helicsCreateCoreFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}' href='#HELICS.helicsCreateCoreFromArgs-Tuple{String,String,Int64,Array{#s45,1} where #s45<:AbstractString}'>#  HELICS.helicsCreateCoreFromArgs  \u2014  Method .  helicsCreateCoreFromArgs ( kind :: String ,   name :: String ,   argc :: Int64 ,   argv :: Array { #s45,1} where #s45<:AbstractString) -> HELICS.Core   source  #  HELICS.helicsCreateFederateInfo  \u2014  Method .  helicsCreateFederateInfo ()   ->   HELICS . FederateInfo   Create a  FederateInfo  object for specifying federate information when constructing a federate  Returns   a  FederateInfo  object which is a reference to the created object   source  #  HELICS.helicsCreateMessageFederate  \u2014  Method .  helicsCreateMessageFederate ( fedName :: String ,   fi :: HELICS . FederateInfo )   ->   HELICS . MessageFederate   Create a  MessageFederate  from a  FederateInfo  object  MessageFederate  objects can be used in all functions that take a  MessageFederate  or  Federate  object as an argument  Arguments   fedName : the name of the federate to create  fi : the  FederateInfo  object that contains details on the federate   Returns   an opaque  MessageFederate   source  #  HELICS.helicsCreateMessageFederateFromConfig  \u2014  Method .  helicsCreateMessageFederateFromConfig ( configFile :: String )   ->   HELICS . MessageFederate   Create a  MessageFederate  from a JSON file or JSON string or TOML file  MessageFederate  objects can be used in all functions that take a  MessageFederate  or  Federate  object as an argument  Arguments   configFile :  a Config(JSON,TOML) file or a JSON string that contains setup and configuration information   Returns   an opaque  MessageFederate   source  #  HELICS.helicsCreateQuery  \u2014  Method .  helicsCreateQuery ( target :: String ,   query :: String )   ->   HELICS . Query   Create a  Query  a  Query  consists of a target and query string  Arguments   target : the name of the target to query  query : the query string to make of the target   source  #  HELICS.helicsCreateValueFederate  \u2014  Method .  helicsCreateValueFederate ( fedName :: String ,   fi :: HELICS . FederateInfo )   ->   HELICS . ValueFederate   Create a value federate from a  FederateInfo  object  Federate  objects can be used in all functions that take a  Federate  object as an argument  Arguments   fedName : the name of the federate to create, can NULL or an empty string to use the default name from fi or an assigned name  fi : the  FederateInfo  object that contains details on the federate   Returns   an opaque value  Federate   source  #  HELICS.helicsCreateValueFederateFromConfig  \u2014  Method .  helicsCreateValueFederateFromConfig ( configFile :: String )   ->   HELICS . ValueFederate   Create a value federate from a JSON file, JSON string, or TOML file  Federate  objects can be used in all functions that take a  Federate  object as an argument  Arguments   configFile :  a JSON file or a JSON string or TOML file that contains setup and configuration information   Returns   an opaque value  Federate   source  #  HELICS.helicsEndpointClearMessages  \u2014  Method .  helicsEndpointClearMessages ( endpoint :: HELICS . Endpoint )   Clear all message from an endpoint  Arguments   endpoint : The endpoint object to operate on   source  #  HELICS.helicsEndpointGetDefaultDestination  \u2014  Method .  helicsEndpointGetDefaultDestination ( endpoint :: HELICS . Endpoint )   ->   String   Get the default destination for an endpoint  Arguments   endpoint : The endpoint to set the destination for   Returns   a string with the default destination   source  #  HELICS.helicsEndpointGetInfo  \u2014  Method .  helicsEndpointGetInfo ( _end :: HELICS . Endpoint )   ->   String   Get the data in the info field of an filter  Arguments   end : The filter to query   Returns   a string with the info field string   source  #  HELICS.helicsEndpointGetMessage  \u2014  Method .  helicsEndpointGetMessage ( endpoint :: HELICS . Endpoint )   ->   HELICS . Lib . helics_message   Receive a packet from a particular endpoint  Arguments   endpoint : The identifier for the endpoint   Returns   a message object   source  #  HELICS.helicsEndpointGetMessageObject  \u2014  Method .  helicsEndpointGetMessageObject ( endpoint :: HELICS . Endpoint )   ->   HELICS . Message   Receive a packet from a particular endpoint  Arguments   endpoint : The identifier for the endpoint   Returns   a message object   source  #  HELICS.helicsEndpointGetName  \u2014  Method .  helicsEndpointGetName ( endpoint :: HELICS . Endpoint )   ->   String   get the name of an endpoint  Arguments   endpoint : The endpoint object in question   Returns   the name of the endpoint   source  #  HELICS.helicsEndpointGetOption  \u2014  Method .  helicsEndpointGetOption ( _end :: HELICS . Endpoint ,   option :: Union { Int64 ,   HELICS . Lib . helics_handle_options })   ->   Bool   Get a handle option on an endpoint   end : The endpoint to modify  option : Integer code for the option to set  HELICS_HANDLE_OPTIONS   source  #  HELICS.helicsEndpointGetType  \u2014  Method .  helicsEndpointGetType ( endpoint :: HELICS . Endpoint )   ->   String   Get the type specified for an endpoint  Arguments   endpoint : The endpoint object in question   Returns   the defined type of the endpoint   source  #  HELICS.helicsEndpointHasMessage  \u2014  Method .  helicsEndpointHasMessage ( endpoint :: HELICS . Endpoint )   ->   Bool   Check if a given endpoint has any unread messages  Arguments   endpoint : The endpoint to check   Returns   true  if the endpoint has a message,  false  otherwise   source  #  HELICS.helicsEndpointPendingMessages  \u2014  Method .  helicsEndpointPendingMessages ( endpoint :: HELICS . Endpoint )   ->   Int64   Returns the number of pending receives for all endpoints of particular federate.  Arguments   endpoint : The endpoint to query   source  #  HELICS.helicsEndpointSendEventRaw  \u2014  Method .  helicsEndpointSendEventRaw ( endpoint :: HELICS . Endpoint ,   dest :: String ,   data :: String ,   time :: Union { Float64 ,   Int64 })   Send a message at a specific time to the specified destination  Arguments   endpoint : The endpoint to send the data from  dest : The target destination (nullptr to use the default destination)  data : The data to send  inputDataLength : The length of the data to send  time : The time the message should be sent   source  #  HELICS.helicsEndpointSendMessage  \u2014  Method .  helicsEndpointSendMessage ( endpoint :: HELICS . Endpoint ,   message :: HELICS . Message )   Send a message object from a specific endpoint  Arguments   endpoint : The endpoint to send the data from  message : The actual message to send   source  #  HELICS.helicsEndpointSendMessageObject  \u2014  Method .  helicsEndpointSendMessageObject ( endpoint :: HELICS . Endpoint ,   message :: HELICS . Message )   Send a message object from a specific endpoint  Arguments   endpoint : The endpoint to send the data from  message : The actual message to send   source  #  HELICS.helicsEndpointSendMessageRaw  \u2014  Method .  helicsEndpointSendMessageRaw ( endpoint :: HELICS . Endpoint ,   dest :: String ,   data :: String )   Send a message to the specified destination  Arguments   endpoint : The endpoint to send the data from  dest : The target destination (nullptr to use the default destination)  data : The data to send  inputDataLength : The length of the data to send   source  #  HELICS.helicsEndpointSetDefaultDestination  \u2014  Method .  helicsEndpointSetDefaultDestination ( endpoint :: HELICS . Endpoint ,   dest :: String )   Set the default destination for an endpoint if no other endpoint is given  Arguments   endpoint : The endpoint to set the destination for  dest : A string naming the desired default endpoint   source  #  HELICS.helicsEndpointSetInfo  \u2014  Method .  helicsEndpointSetInfo ( _end :: HELICS . Endpoint ,   info :: String )   Set the data in the info field for an filter  Arguments   end : The endpoint to query  info : The string to set   source  #  HELICS.helicsEndpointSetOption  \u2014  Method .  helicsEndpointSetOption ( _end :: HELICS . Endpoint ,   option :: Union { Int64 ,   HELICS . Lib . helics_handle_options },   value :: Bool )   Set a handle option on an endpoint   end : The endpoint to modify  option : Integer code for the option to set  HELICS_HANDLE_OPTIONS  value : The value to set the option   source  #  HELICS.helicsEndpointSubscribe  \u2014  Method .  helicsEndpointSubscribe ( endpoint :: HELICS . Endpoint ,   key :: String )   Subscribe an endpoint to a publication  Arguments   endpoint : The endpoint to use  key : The name of the publication   source  #  HELICS.helicsErrorClear  \u2014  Method .  helicsErrorClear ( err :: HELICS . Lib . helics_error )   Clear an error object  source  #  HELICS.helicsErrorInitialize  \u2014  Method .  helicsErrorInitialize ()   ->   HELICS . Lib . helics_error   Return an initialized error object  source  #  HELICS.helicsFederateAddDependency  \u2014  Method .  helicsFederateAddDependency ( fed :: HELICS . Federate ,   fedName :: String )   source  #  HELICS.helicsFederateClearMessages  \u2014  Method .  helicsFederateClearMessages ( fed :: HELICS . Federate )   Clear all stored messages from a federate  this clears messages retrieved through helicsFederateGetMessage or helicsFederateGetMessageObject  Arguments   fed : The federate to clear the message for   source  #  HELICS.helicsFederateClearUpdates  \u2014  Method .  helicsFederateClearUpdates ( fed :: HELICS . Federate )   source  <a id='HELICS.helicsFederateClone-Union{Tuple{T}, Tuple{T}} where T<:HELICS.Federate' href='#HELICS.helicsFederateClone-Union{Tuple{T}, Tuple{T}} where T<:HELICS.Federate'>#  HELICS.helicsFederateClone  \u2014  Method .  helicsFederateClone ( fed :: T <: HELICS . Federate )   ->   Union { HELICS . CombinationFederate ,   HELICS . MessageFederate ,   HELICS . ValueFederate }   Create a new reference to an existing federate  this will create a new  Federate  object that references the existing federate it must be freed as well  Arguments   fed : an existing  Federate   Returns   a new reference to the same federate   source  #  HELICS.helicsFederateDestroy  \u2014  Method .  helicsFederateDestroy ( fed :: HELICS . Federate )   Disconnect and free a broker  source  #  HELICS.helicsFederateEnterExecutingMode  \u2014  Method .  helicsFederateEnterExecutingMode ( fed :: HELICS . Federate )   Request that the federate enter the Execution mode  this call is blocking until granted entry by the core object for an asynchronous alternative call  helicsFederateEnterExecutingModeAsync  on return from this call the federate will be at time 0.  Arguments   fed : a federate to change modes   source  #  HELICS.helicsFederateEnterExecutingModeAsync  \u2014  Method .  helicsFederateEnterExecutingModeAsync ( fed :: HELICS . Federate )   Request that the federate enter the Execution mode  this call is non-blocking and will return immediately. Call  helicsFederateEnterExecutingModeComplete  to finish the call sequence.  Arguments   fed : the federate object to complete the call   source  #  HELICS.helicsFederateEnterExecutingModeComplete  \u2014  Method .  helicsFederateEnterExecutingModeComplete ( fed :: HELICS . Federate )   Complete the call to  helicsFederateEnterExecutingModeAsync  Arguments   fed : the federate object to complete the call   source  #  HELICS.helicsFederateEnterExecutingModeIterative  \u2014  Method .  helicsFederateEnterExecutingModeIterative ( fed :: HELICS . Federate ,   iterate :: Union { Int64 ,   HELICS . Lib . helics_iteration_request })   ->   HELICS . Lib . helics_iteration_result   Request an iterative time  this call allows for finer grain control of the iterative process then  helicsFederateRequestTime  it takes a time and iteration request and return a time and iteration status.  Arguments   fed : the federate to make the request of  iterate : the requested iteration mode   Returns   an iteration structure with field containing the time and iteration status   source  #  HELICS.helicsFederateEnterExecutingModeIterativeAsync  \u2014  Method .  helicsFederateEnterExecutingModeIterativeAsync ( fed :: HELICS . Federate ,   iterate :: Union { Int64 ,   HELICS . Lib . helics_iteration_request })   source  #  HELICS.helicsFederateEnterExecutingModeIterativeComplete  \u2014  Method .  helicsFederateEnterExecutingModeIterativeComplete ( fed :: HELICS . Federate )   ->   HELICS . Lib . helics_iteration_result   Complete the asynchronous iterative call into ExecutionModel  Arguments   fed : the federate to make the request of   Returns   an iteration object containing the iteration time and iteration_status   source  #  HELICS.helicsFederateEnterInitializingMode  \u2014  Method .  helicsFederateEnterInitializingMode ( fed :: HELICS . Federate )   Enter the initialization state of a federate  the initialization state allows initial values to be set and received if the iteration is requested on entry to the execution state. This is a blocking call and will block until the core allows it to proceed.  Arguments   fed : the federate to operate on   source  #  HELICS.helicsFederateEnterInitializingModeAsync  \u2014  Method .  helicsFederateEnterInitializingModeAsync ( fed :: HELICS . Federate )   Non blocking alternative to  helicsFederateEnterInitializingMode . The function  helicsFederateFinalize  must be called to finish the operation  Arguments   fed : the federate to operate on   source  #  HELICS.helicsFederateEnterInitializingModeComplete  \u2014  Method .  helicsFederateEnterInitializingModeComplete ( fed :: HELICS . Federate )   Finalize the entry to initialize mode that was initiated with  helicsFederateEnterInitializingModeAsync  Arguments   fed : the federate desiring to complete the initialization step function   source  #  HELICS.helicsFederateFinalize  \u2014  Method .  helicsFederateFinalize ( fed :: HELICS . Federate )   Finalize the federate this function halts all communication in the federate and disconnects it from the core  source  #  HELICS.helicsFederateFinalizeAsync  \u2014  Method .  helicsFederateFinalizeAsync ( fed :: HELICS . Federate )   Finalize the federate in an async call  source  #  HELICS.helicsFederateFinalizeComplete  \u2014  Method .  helicsFederateFinalizeComplete ( fed :: HELICS . Federate )   Complete the asynchronous finalize call  source  #  HELICS.helicsFederateFree  \u2014  Method .  helicsFederateFree ( fed :: HELICS . Federate )   Release the memory associated withe a federate  source  #  HELICS.helicsFederateGetCoreObject  \u2014  Method .  helicsFederateGetCoreObject ( fed :: HELICS . Federate )   ->   HELICS . Core   Get the core object associated with a federate  Arguments   fed : a federate object   Returns   a core object, nullptr if invalid   source  #  HELICS.helicsFederateGetCurrentTime  \u2014  Method .  helicsFederateGetCurrentTime ( fed :: HELICS . Federate )   ->   Float64   Get the current time of the federate  Arguments   fed : the  Federate  to query   Returns   the current time of the federate   source  #  HELICS.helicsFederateGetEndpoint  \u2014  Method .  helicsFederateGetEndpoint ( fed :: HELICS . Federate ,   name :: String )   ->   HELICS . Endpoint   Get an endpoint object from a name  Arguments   fed : The message federate object to use to get the endpoint  name : The name of the endpoint  err : The error object to complete if there is an error   Returns   a  helics_endpoint  object, the object will not   be valid and err will contain an error code if no endpoint with the specified name exists  source  #  HELICS.helicsFederateGetEndpointByIndex  \u2014  Method .  helicsFederateGetEndpointByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   ->   HELICS . Endpoint   Get an endpoint by its index typically already created via registerInterfaces file or something of that nature  Arguments   fed : The federate object in which to create a publication  index : The index of the publication to get   Returns   a helics_endpoint, which will be NULL if an invalid index   source  #  HELICS.helicsFederateGetEndpointCount  \u2014  Method .  helicsFederateGetEndpointCount ( fed :: HELICS . Federate )   ->   Int64   Get the number of endpoints in a federate  Arguments   fed : The message federate to query   Returns   (-1) if fed was not a valid federate otherwise returns the number of endpoints   source  #  HELICS.helicsFederateGetFilter  \u2014  Method .  helicsFederateGetFilter ( fed :: HELICS . Federate ,   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsFederateGetFilterByIndex  \u2014  Method .  helicsFederateGetFilterByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   ->   HELICS . Filter   source  #  HELICS.helicsFederateGetFilterCount  \u2014  Method .  helicsFederateGetFilterCount ( fed :: HELICS . Federate )   ->   Int64   source  #  HELICS.helicsFederateGetFlagOption  \u2014  Method .  helicsFederateGetFlagOption ( fed :: HELICS . Federate ,   flag :: Union { Int64 ,   HELICS . Lib . helics_federate_flags })   ->   Bool   Get a flag value for a federate  Arguments   fed : the federate to get the flag for  flag : the flag to query   Returns   the value of the flag   source  #  HELICS.helicsFederateGetInput  \u2014  Method .  helicsFederateGetInput ( fed :: HELICS . Federate ,   key :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateGetInputByIndex  \u2014  Method .  helicsFederateGetInputByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateGetInputCount  \u2014  Method .  helicsFederateGetInputCount ( fed :: HELICS . Federate )   ->   Int64   source  #  HELICS.helicsFederateGetIntegerProperty  \u2014  Method .  helicsFederateGetIntegerProperty ( fed :: HELICS . Federate ,   intProperty :: Union { Int64 ,   HELICS . Lib . helics_handle_options })   ->   Int64   Set the logging level for the federate  debug and trace only do anything if they were enabled in the compilation  Arguments   fed : the federate to get the flag for  intProperty : a code for the property to set  HELICS_HANDLE_OPTIONS   Returns   the value of the property   source  #  HELICS.helicsFederateGetMessage  \u2014  Method .  helicsFederateGetMessage ( fed :: HELICS . Federate )   ->   HELICS . Lib . helics_message   Receive a communication message for any endpoint in the federate  the return order will be in order of endpoint creation. So all messages that are available for the first endpoint, then all for the second, and so on within a single endpoint the messages are ordered by time, then  source_id , then order of arrival  Returns   a  unique_ptr  to a  Lib.helics_message  object containing the message data   source  #  HELICS.helicsFederateGetMessageObject  \u2014  Method .  helicsFederateGetMessageObject ( fed :: HELICS . Federate )   ->   HELICS . Message   Receive a communication message for any endpoint in the federate  the return order will be in order of endpoint creation. So all messages that are available for the first endpoint, then all for the second, and so on within a single endpoint the messages are ordered by time, then  source_id , then order of arrival  Returns   a  Message  which references the   data in the message  source  #  HELICS.helicsFederateGetName  \u2014  Method .  helicsFederateGetName ( fed :: HELICS . Federate )   ->   String   Get the name of the federate  Arguments   fed : the  Federate  to query   Returns   a string with the name   source  #  HELICS.helicsFederateGetPublication  \u2014  Method .  helicsFederateGetPublication ( fed :: HELICS . Federate ,   key :: String )   ->   HELICS . Publication   source  #  HELICS.helicsFederateGetPublicationByIndex  \u2014  Method .  helicsFederateGetPublicationByIndex ( fed :: HELICS . Federate ,   index :: Int64 )   ->   HELICS . Publication   source  #  HELICS.helicsFederateGetPublicationCount  \u2014  Method .  helicsFederateGetPublicationCount ( fed :: HELICS . Federate )   ->   Int64   source  #  HELICS.helicsFederateGetState  \u2014  Method .  helicsFederateGetState ( fed :: HELICS . Federate )   ->   HELICS . Lib . helics_federate_state   Get the current state of a federate  Arguments   fed : the  Federate  to query   Returns   state the resulting state if void return helics_ok   source  #  HELICS.helicsFederateGetSubscription  \u2014  Method .  helicsFederateGetSubscription ( fed :: HELICS . Federate ,   key :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateGetTimeProperty  \u2014  Method .  helicsFederateGetTimeProperty ( fed :: HELICS . Federate ,   timeProperty :: Union { Int64 ,   HELICS . Lib . helics_properties })   ->   Float64   Get the current value of a time based property in a federate  Arguments   fed : the federate query  timeProperty : the property to query   source  #  HELICS.helicsFederateGlobalError  \u2014  Method .  helicsFederateGlobalError ( fed :: HELICS . Federate ,   error_code :: Integer ,   error_string :: String )   source  #  HELICS.helicsFederateHasMessage  \u2014  Method .  helicsFederateHasMessage ( fed :: HELICS . Federate )   ->   Bool   Check if the federate has any outstanding messages  Arguments   fed : The federate to check if it has   Returns   true  if the federate has a message waiting  false  otherwise   source  #  HELICS.helicsFederateInfoClone  \u2014  Method .  helicsFederateInfoClone ( fi :: HELICS . FederateInfo )   ->   HELICS . FederateInfo   Create a  FederateInfo  object from an existing one and clone the information  Arguments   fi : a  FederateInfo  object to duplicate   Returns   a helics federate info object which is a reference to the created object   source  #  HELICS.helicsFederateInfoFree  \u2014  Method .  helicsFederateInfoFree ( fi :: HELICS . FederateInfo )   Delete the memory associated with a  FederateInfo  object  source  <a id='HELICS.helicsFederateInfoLoadFromArgs-Tuple{HELICS.FederateInfo,Int64,Array{#s45,1} where #s45<:AbstractString}' href='#HELICS.helicsFederateInfoLoadFromArgs-Tuple{HELICS.FederateInfo,Int64,Array{#s45,1} where #s45<:AbstractString}'>#  HELICS.helicsFederateInfoLoadFromArgs  \u2014  Method .  helicsFederateInfoLoadFromArgs ( fi :: HELICS . FederateInfo ,   argc :: Int64 ,   argv :: Array { #s45,1} where #s45<:AbstractString)   Load a  FederateInfo  from command line arguments  Arguments   fi : a  FederateInfo  object  argc : the number of command line arguments  argv : an array of strings from the command line   source  #  HELICS.helicsFederateInfoSetBroker  \u2014  Method .  helicsFederateInfoSetBroker ( fi :: HELICS . FederateInfo ,   broker :: HELICS . Broker )   Set the name or connection information for a broker  this is only used if the core is automatically created, the broker information will be transferred to the core for connection  Arguments   fi : the  FederateInfo  object to alter  broker : a string which defined the connection information for a broker either a name or an address   source  #  HELICS.helicsFederateInfoSetBrokerInitString  \u2014  Method .  helicsFederateInfoSetBrokerInitString ( fi :: HELICS . FederateInfo ,   brokerInit :: String )   Set the initialization string that a core will pass to a generated broker usually in the form of command line arguments  Arguments   fi : The federate info object to alter  brokerInit : A string with command line arguments for a generated broker   source  #  HELICS.helicsFederateInfoSetBrokerKey  \u2014  Method .  helicsFederateInfoSetBrokerKey ( fi :: HELICS . FederateInfo ,   brokerKey :: String )   Set the key for a broker connection  this is only used if the core is automatically created, the broker information will be transferred to the core for connection  Arguments   fi : The federate info object to alter  brokerkey : A string containing a key for the broker to connect   source  #  HELICS.helicsFederateInfoSetBrokerPort  \u2014  Method .  helicsFederateInfoSetBrokerPort ( fi :: HELICS . FederateInfo ,   brokerPort :: Int64 )   Set the port to use for the broker  this is only used if the core is automatically created, the broker information will be transferred to the core for connection this will only be useful for network broker connections  Arguments   fi : the  FederateInfo  object to alter  brokerPort : the integer port number to use for connection with a broker   source  #  HELICS.helicsFederateInfoSetCoreInitString  \u2014  Method .  helicsFederateInfoSetCoreInitString ( fi :: HELICS . FederateInfo ,   coreInit :: String )   Set the initialization string for the core usually in the form of command line arguments  Arguments   fi : the  FederateInfo  object to alter  coreInit : a string with the core initialization strings   source  #  HELICS.helicsFederateInfoSetCoreName  \u2014  Method .  helicsFederateInfoSetCoreName ( fi :: HELICS . FederateInfo ,   corename :: String )   Set the name of the core to link to for a federate  Arguments   fi : the  FederateInfo  object to alter  corename : the identifier for a core to link to   source  #  HELICS.helicsFederateInfoSetCoreType  \u2014  Method .  helicsFederateInfoSetCoreType ( fi :: HELICS . FederateInfo ,   coretype :: Union { Int64 ,   HELICS . Lib . helics_core_type })   Set the core type by integer code  valid values available by definitions in api-data.h  Arguments   fi : the  FederateInfo  object to alter  coretype : an numerical code for a core type see /ref helics core type   source  #  HELICS.helicsFederateInfoSetCoreTypeFromString  \u2014  Method .  helicsFederateInfoSetCoreTypeFromString ( fi :: HELICS . FederateInfo ,   coretype :: String )   Set the core type from a string  Arguments   fi : the  FederateInfo  object to alter  coretype : a string naming a core type   source  #  HELICS.helicsFederateInfoSetFlagOption  \u2014  Method .  helicsFederateInfoSetFlagOption ( fi :: HELICS . FederateInfo ,   flag :: Union { Int64 ,   HELICS . Lib . helics_federate_flags },   value :: Bool )   Set a flag in the info structure  valid flags are available  HELICS_FEDERATE_FLAGS  Arguments   fi : the  FederateInfo  object to alter  flag : a numerical index for a flag  value : the desired value of the flag  true  or  false   source  #  HELICS.helicsFederateInfoSetIntegerProperty  \u2014  Method .  helicsFederateInfoSetIntegerProperty ( fi :: HELICS . FederateInfo ,   intProperty :: Union { Int64 ,   HELICS . Lib . helics_properties },   propertyValue :: Int64 )   source  #  HELICS.helicsFederateInfoSetLocalPort  \u2014  Method .  helicsFederateInfoSetLocalPort ( fi :: HELICS . FederateInfo ,   localPort :: Int64 )   Set the local port to use  this is only used if the core is automatically created, the port information will be transferred to the core for connection  Arguments   fi : the  FederateInfo  object to alter  localPort : a string with the port information to use as the local server port can be a number or \"auto\" or \"os_local\"   source  #  HELICS.helicsFederateInfoSetSeparator  \u2014  Method .  helicsFederateInfoSetSeparator ( fi :: HELICS . FederateInfo ,   separator :: Char )   Set the separator character in the info structure  the separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName  Arguments   fi : the  FederateInfo  object to alter  separator : the character to use as a separator   source  #  HELICS.helicsFederateInfoSetTimeProperty  \u2014  Method .  helicsFederateInfoSetTimeProperty ( fi :: HELICS . FederateInfo ,   timeProperty :: Union { Int64 ,   HELICS . Lib . helics_properties },   propertyValue :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsFederateIsAsyncOperationCompleted  \u2014  Method .  helicsFederateIsAsyncOperationCompleted ( fed :: HELICS . Federate )   ->   Bool   Check if the current Asynchronous operation has completed  Arguments   fed : the federate to operate on   Returns   false  if not completed,  true  if completed   source  #  HELICS.helicsFederateIsValid  \u2014  Method .  helicsFederateIsValid ( fed :: HELICS . Federate )   ->   Bool   Check if a federate_object is valid  Returns   true  if the federate is a valid active federate,  false  otherwise   source  #  HELICS.helicsFederateLocalError  \u2014  Method .  helicsFederateLocalError ( fed :: HELICS . Federate ,   error_code :: Integer ,   error_string :: String )   source  #  HELICS.helicsFederateLogDebugMessage  \u2014  Method .  helicsFederateLogDebugMessage ( fed :: HELICS . Federate ,   logmessage :: String )   Log a message through a federate  Arguments   fed : The federate to set the global through  logmessage : The message to put in the log   source  #  HELICS.helicsFederateLogErrorMessage  \u2014  Method .  helicsFederateLogErrorMessage ( fed :: HELICS . Federate ,   logmessage :: String )   Log an error message through a federate  Arguments   fed : The federate to set the global through  logmessage : The message to put in the log   source  #  HELICS.helicsFederateLogInfoMessage  \u2014  Method .  helicsFederateLogInfoMessage ( fed :: HELICS . Federate ,   logmessage :: String )   Log a message through a federate  Arguments   fed : The federate to set the global through  logmessage : The message to put in the log   source  #  HELICS.helicsFederateLogLevelMessage  \u2014  Method .  helicsFederateLogLevelMessage ( fed :: HELICS . Federate ,   loglevel :: Union { Int64 ,   HELICS . Lib . helics_log_levels },   logmessage :: String )   Log a message through a federate  Arguments   fed : The federate to set the global through  loglevel : The level of the message to log. See  HELICS_LOG_LEVELS  logmessage : The message to put in the log   source  #  HELICS.helicsFederateLogWarningMessage  \u2014  Method .  helicsFederateLogWarningMessage ( fed :: HELICS . Federate ,   logmessage :: String )   Log a warning message through a federate  Arguments   fed : The federate to set the global through  logmessage : The message to put in the log   source  #  HELICS.helicsFederatePendingMessages  \u2014  Method .  helicsFederatePendingMessages ( fed :: HELICS . Federate )   ->   Int64   Returns the number of pending receives for the specified destination endpoint.  Arguments   fed : The federate to get the number of waiting messages   source  #  HELICS.helicsFederatePublishJSON  \u2014  Method .  helicsFederatePublishJSON ( fed :: HELICS . Federate ,   json :: String )   source  #  HELICS.helicsFederateRegisterCloningFilter  \u2014  Method .  helicsFederateRegisterCloningFilter ( fed :: HELICS . Federate ,   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsFederateRegisterEndpoint  \u2014  Method .  helicsFederateRegisterEndpoint ( fed :: HELICS . Federate ,   name :: String ,   kind :: String )   ->   HELICS . Endpoint   Create an endpoint  The endpoint becomes part of the federate and is destroyed when the federate is freed so there are no separate free functions for endpoints.  Arguments   fed : the federate object in which to create an endpoint must have been create with helicsCreateMessageFederate or helicsCreateCombinationFederate  name : the identifier for the endpoint,  this will be prepended with the federate name for the global identifier  type : a string describing the expected type of the publication may be NULL   Returns   Endpoint  object containing the endpoint, nullptr on failure   source  #  HELICS.helicsFederateRegisterFilter  \u2014  Method .  helicsFederateRegisterFilter ( fed :: HELICS . Federate ,   kind :: Union { Int64 ,   HELICS . Lib . helics_filter_type },   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsFederateRegisterFromPublicationJSON  \u2014  Method .  helicsFederateRegisterFromPublicationJSON ( fed :: HELICS . Federate ,   json :: String )   source  #  HELICS.helicsFederateRegisterGlobalCloningFilter  \u2014  Method .  helicsFederateRegisterGlobalCloningFilter ( fed :: HELICS . Federate ,   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsFederateRegisterGlobalEndpoint  \u2014  Method .  helicsFederateRegisterGlobalEndpoint ( fed :: HELICS . Federate ,   name :: String ,   kind :: String )   ->   HELICS . Endpoint   Create an endpoint  The endpoint becomes part of the federate and is destroyed when the federate is freed so there are no separate free functions for endpoints  Arguments   fed  the federate object in which to create an endpoint must have been create with helicsCreateMessageFederate or helicsCreateCombinationFederate  name  the identifier for the endpoint, the given name is the global identifier  type  a string describing the expected type of the publication may be NULL  err  a pointer to an error object for catching errors   Returns   Endpoint  object containing the endpoint, nullptr on failure   source  #  HELICS.helicsFederateRegisterGlobalFilter  \u2014  Method .  helicsFederateRegisterGlobalFilter ( fed :: HELICS . Federate ,   kind :: Union { Int64 ,   HELICS . Lib . helics_filter_type },   name :: String )   ->   HELICS . Filter   source  #  HELICS.helicsFederateRegisterGlobalInput  \u2014  Function .  helicsFederateRegisterGlobalInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type })   ->   HELICS . Subscription  helicsFederateRegisterGlobalInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type },   units :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterGlobalPublication  \u2014  Function .  helicsFederateRegisterGlobalPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type })   ->   HELICS . Publication  helicsFederateRegisterGlobalPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type },   units :: String )   ->   HELICS . Publication   source  #  HELICS.helicsFederateRegisterGlobalTypeInput  \u2014  Function .  helicsFederateRegisterGlobalTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   ->   HELICS . Subscription  helicsFederateRegisterGlobalTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterGlobalTypePublication  \u2014  Function .  helicsFederateRegisterGlobalTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   ->   HELICS . Publication  helicsFederateRegisterGlobalTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   ->   HELICS . Publication   source  #  HELICS.helicsFederateRegisterInput  \u2014  Function .  helicsFederateRegisterInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type })   ->   HELICS . Subscription  helicsFederateRegisterInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type },   units :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterInterfaces  \u2014  Method .  helicsFederateRegisterInterfaces ( fed :: HELICS . Federate ,   file :: String )   Load interfaces from a file  Arguments   fed : the federate to which to load interfaces  file : the name of a file to load the interfaces from either JSON, or TOML   source  #  HELICS.helicsFederateRegisterPublication  \u2014  Function .  helicsFederateRegisterPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type })   ->   HELICS . Publication  helicsFederateRegisterPublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: Union { Int64 ,   HELICS . Lib . helics_data_type },   units :: String )   ->   HELICS . Publication   source  #  HELICS.helicsFederateRegisterSubscription  \u2014  Function .  helicsFederateRegisterSubscription ( fed :: HELICS . Federate ,   key :: String )   ->   HELICS . Subscription  helicsFederateRegisterSubscription ( fed :: HELICS . Federate ,   key :: String ,   units :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterTypeInput  \u2014  Function .  helicsFederateRegisterTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   ->   HELICS . Subscription  helicsFederateRegisterTypeInput ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   ->   HELICS . Subscription   source  #  HELICS.helicsFederateRegisterTypePublication  \u2014  Function .  helicsFederateRegisterTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String )   ->   HELICS . Publication  helicsFederateRegisterTypePublication ( fed :: HELICS . Federate ,   key :: String ,   kind :: String ,   units :: String )   ->   HELICS . Publication   source  #  HELICS.helicsFederateRequestNextStep  \u2014  Method .  helicsFederateRequestNextStep ( fed :: HELICS . Federate )   ->   Float64   Request the next time step for federate execution  feds should have setup the period or minDelta for this to work well but it will request the next time step which is the current time plus the minimum time step.  Arguments   fed : the federate to make the request of   Returns   the time granted to the federate   source  #  HELICS.helicsFederateRequestTime  \u2014  Method .  helicsFederateRequestTime ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 })   ->   Float64   Request the next time for federate execution  Arguments   fed : the federate to make the request of  requestTime : the next requested time   Returns   the time granted to the federate   invalid   source  #  HELICS.helicsFederateRequestTimeAdvance  \u2014  Method .  helicsFederateRequestTimeAdvance ( fed :: HELICS . Federate ,   timeDelta :: Union { Float64 ,   Int64 })   ->   Float64   request the next time for federate execution  Arguments   fed : The federate to make the request of  timeDelta : The requested amount of time to advance   Returns   the time granted to the federate, will return   HELICS_TIME_MAXTIME  if the simulation has terminated invalid  source  #  HELICS.helicsFederateRequestTimeAsync  \u2014  Method .  helicsFederateRequestTimeAsync ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 })   Request the next time for federate execution in an asynchronous call Call  helicsFederateRequestTimeComplete  to finish the call  Arguments   fed : the federate to make the request of  requestTime : the next requested time   source  #  HELICS.helicsFederateRequestTimeComplete  \u2014  Method .  helicsFederateRequestTimeComplete ( fed :: HELICS . Federate )   ->   Float64   Complete an asynchronous requestTime call  Arguments   fed : the federate to make the request of   Returns   the time granted to the federate   source  #  HELICS.helicsFederateRequestTimeIterative  \u2014  Method .  helicsFederateRequestTimeIterative ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 },   iterate :: Union { Int64 ,   HELICS . Lib . helics_iteration_request })   Request an iterative time  this call allows for finer grain control of the iterative process then  helicsFederateRequestTime  it takes a time and iteration request and return a time and iteration status.  Arguments   fed : the federate to make the request of  requestTime : the next desired time  iterate : the requested iteration mode   Returns   the granted time  the iteration specification of the result   source  #  HELICS.helicsFederateRequestTimeIterativeAsync  \u2014  Method .  helicsFederateRequestTimeIterativeAsync ( fed :: HELICS . Federate ,   requestTime :: Union { Float64 ,   Int64 },   iterate :: Union { Int64 ,   HELICS . Lib . helics_iteration_request })   Request an iterative time through an asynchronous call  this call allows for finer grain control of the iterative process then  helicsFederateRequestTime  it takes a time an iteration request and returns a time and iteration status call  helicsFederateRequestTimeIterativeComplete  to finish the process.  Arguments   fed : the federate to make the request of  requestTime : the next desired time  iterate : the requested iteration mode   Returns   a void object with a return code of the result   source  #  HELICS.helicsFederateRequestTimeIterativeComplete  \u2014  Method .  helicsFederateRequestTimeIterativeComplete ( fed :: HELICS . Federate )   Complete an iterative time request asynchronous call  Arguments   fed : the federate to make the request of   Returns   the granted time  outIterate   the iteration specification of the result   source  #  HELICS.helicsFederateSetFlagOption  \u2014  Method .  helicsFederateSetFlagOption ( fed :: HELICS . Federate ,   flag :: Union { Int64 ,   HELICS . Lib . helics_federate_flags },   flagValue :: Bool )   Set a flag for the federate  Arguments   fed : the federate to alter a flag for  flag : the flag to change  flagValue : the new value of the flag 0 for false !=0 for true   source  #  HELICS.helicsFederateSetGlobal  \u2014  Method .  helicsFederateSetGlobal ( fed :: HELICS . Federate ,   valueName :: String ,   value :: String )   Set a federation global value through a federate  this overwrites any previous value for this name  Arguments   fed : the federate to set the global through  valueName : the name of the global to set  value : the value of the global   source  #  HELICS.helicsFederateSetIntegerProperty  \u2014  Method .  helicsFederateSetIntegerProperty ( fed :: HELICS . Federate ,   intProperty :: Union { Int64 ,   HELICS . Lib . helics_properties },   propertyVal :: Int64 )   Set an integer based property of a federate  Arguments   fed : the federate to change the property for  intProperty : the property to set  propertyVal : the value of the property   source  #  HELICS.helicsFederateSetLogFile  \u2014  Method .  helicsFederateSetLogFile ( fed :: HELICS . Federate ,   logFile :: String )   source  #  HELICS.helicsFederateSetLoggingCallback  \u2014  Method .  helicsFederateSetLoggingCallback ( fed :: HELICS . Federate ,   logger :: Ptr { Nothing },   userdata :: Any )   source  #  HELICS.helicsFederateSetSeparator  \u2014  Method .  helicsFederateSetSeparator ( fed :: HELICS . Federate ,   separator :: Char )   Set the separator character in a federate  the separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName.  Arguments   fed : the  FederateInfo  object to alter  separator : the character to use as a separator   source  #  HELICS.helicsFederateSetTimeProperty  \u2014  Method .  helicsFederateSetTimeProperty ( fed :: HELICS . Federate ,   timeProperty :: Union { Int64 ,   HELICS . Lib . helics_properties },   time :: Union { Float64 ,   Int64 })   Set a time based property for a federate  Arguments   fed : the  Federate  set the property for  timeProperty : a integer code for a time property  time : the requested value of the property   source  #  HELICS.helicsFilterAddDeliveryEndpoint  \u2014  Method .  helicsFilterAddDeliveryEndpoint ( filt :: HELICS . Filter ,   deliveryEndpoint :: String )   source  #  HELICS.helicsFilterAddDestinationTarget  \u2014  Method .  helicsFilterAddDestinationTarget ( filt :: HELICS . Filter ,   dest :: String )   source  #  HELICS.helicsFilterAddSourceTarget  \u2014  Method .  helicsFilterAddSourceTarget ( filt :: HELICS . Filter ,   source :: String )   source  #  HELICS.helicsFilterGetInfo  \u2014  Method .  helicsFilterGetInfo ( filt :: HELICS . Filter )   ->   String   source  #  HELICS.helicsFilterGetName  \u2014  Method .  helicsFilterGetName ( filt :: HELICS . Filter )   ->   String   source  #  HELICS.helicsFilterGetOption  \u2014  Method .  helicsFilterGetOption ( filt :: HELICS . Filter ,   option :: Int64 )   ->   Bool   source  #  HELICS.helicsFilterRemoveDeliveryEndpoint  \u2014  Method .  helicsFilterRemoveDeliveryEndpoint ( filt :: HELICS . Filter ,   deliveryEndpoint :: String )   source  #  HELICS.helicsFilterRemoveTarget  \u2014  Method .  helicsFilterRemoveTarget ( filt :: HELICS . Filter ,   target :: String )   source  #  HELICS.helicsFilterSet  \u2014  Method .  helicsFilterSet ( filt :: HELICS . Filter ,   prop :: String ,   val :: Float64 )   source  #  HELICS.helicsFilterSetInfo  \u2014  Method .  helicsFilterSetInfo ( filt :: HELICS . Filter ,   info :: String )   source  #  HELICS.helicsFilterSetOption  \u2014  Method .  helicsFilterSetOption ( filt :: HELICS . Filter ,   option :: Int64 ,   value :: Bool )   source  #  HELICS.helicsFilterSetString  \u2014  Method .  helicsFilterSetString ( filt :: HELICS . Filter ,   prop :: String ,   val :: String )   source  #  HELICS.helicsGetFederateByName  \u2014  Method .  helicsGetFederateByName ( fedName :: String )   ->   HELICS . CombinationFederate   Get an existing  Federate  from a core by name  the federate must have been created by one of the other functions and at least one of the objects referencing the created     federate must still be active in the process  Arguments   fedName : the name of the federate to retrieve   Returns   NULL if no fed is available by that name otherwise a  Federate  with that name   source  #  HELICS.helicsGetOptionIndex  \u2014  Method .  helicsGetOptionIndex ( val :: String )   ->   Int64   Get an option index for use in  helicsPublicationSetOption ,  helicsInputSetOption ,  helicsEndpointSetOption ,  helicsFilterSetOption , and the corresponding get functions  Arguments   val : a string with the option name   Returns   an int with the option index (-1) if not a valid property   source  #  HELICS.helicsGetPropertyIndex  \u2014  Method .  helicsGetPropertyIndex ( val :: String )   ->   Int64   Get a property index for use in  helicsFederateInfoSetFlagOption ,  helicsFederateInfoSetTimeProperty ,  helicsFederateInfoSetIntegerProperty  Arguments   val : a string with the property name   Returns   an int with the property code (-1) if not a valid property   source  #  HELICS.helicsGetVersion  \u2014  Method .  helicsGetVersion ()   ->   String   Get a version string for HELICS  source  #  HELICS.helicsInputAddTarget  \u2014  Method .  helicsInputAddTarget ( ipt :: HELICS . Subscription ,   target :: String )   source  #  HELICS.helicsInputClearUpdate  \u2014  Method .  helicsInputClearUpdate ( ipt :: HELICS . Subscription )   source  #  HELICS.helicsInputGetBoolean  \u2014  Method .  helicsInputGetBoolean ( ipt :: HELICS . Subscription )   ->   Bool   source  #  HELICS.helicsInputGetChar  \u2014  Method .  helicsInputGetChar ( ipt :: HELICS . Subscription )   ->   Char   source  #  HELICS.helicsInputGetComplex  \u2014  Method .  helicsInputGetComplex ( ipt :: HELICS . Subscription )   ->   Complex { Float64 }   source  #  HELICS.helicsInputGetComplexObject  \u2014  Method .  helicsInputGetComplexObject ( ipt :: HELICS . Subscription )   ->   Complex { Float64 }   source  #  HELICS.helicsInputGetDouble  \u2014  Method .  helicsInputGetDouble ( ipt :: HELICS . Subscription )   ->   Float64   source  #  HELICS.helicsInputGetExtractionUnits  \u2014  Method .  helicsInputGetExtractionUnits ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetInfo  \u2014  Method .  helicsInputGetInfo ( inp :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetInjectionUnits  \u2014  Method .  helicsInputGetInjectionUnits ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetInteger  \u2014  Method .  helicsInputGetInteger ( ipt :: HELICS . Subscription )   ->   Int64   source  #  HELICS.helicsInputGetKey  \u2014  Method .  helicsInputGetKey ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetNamedPoint  \u2014  Method .  helicsInputGetNamedPoint ( ipt :: HELICS . Subscription )   ->   Tuple { String , Float64 }   source  #  HELICS.helicsInputGetOption  \u2014  Method .  helicsInputGetOption ( inp :: HELICS . Subscription ,   option :: Int64 )   ->   Bool   source  #  HELICS.helicsInputGetPublicationType  \u2014  Method .  helicsInputGetPublicationType ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetRawValue  \u2014  Method .  helicsInputGetRawValue ( ipt :: T ,   data :: T )   source  #  HELICS.helicsInputGetRawValueSize  \u2014  Method .  helicsInputGetRawValueSize ( ipt :: HELICS . Subscription )   ->   Int64   source  #  HELICS.helicsInputGetString  \u2014  Method .  helicsInputGetString ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetStringSize  \u2014  Method .  helicsInputGetStringSize ( ipt :: HELICS . Subscription )   ->   Int64   source  #  HELICS.helicsInputGetTime  \u2014  Method .  helicsInputGetTime ( ipt :: HELICS . Subscription )   ->   Float64   source  #  HELICS.helicsInputGetType  \u2014  Method .  helicsInputGetType ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetUnits  \u2014  Method .  helicsInputGetUnits ( ipt :: HELICS . Subscription )   ->   String   source  #  HELICS.helicsInputGetVector  \u2014  Method .  helicsInputGetVector ( ipt :: HELICS . Subscription )   ->   Array { Float64 , 1 }   source  #  HELICS.helicsInputGetVectorSize  \u2014  Method .  helicsInputGetVectorSize ( ipt :: HELICS . Subscription )   ->   Int64   source  #  HELICS.helicsInputIsUpdated  \u2014  Method .  helicsInputIsUpdated ( ipt :: HELICS . Subscription )   ->   Bool   source  #  HELICS.helicsInputLastUpdateTime  \u2014  Method .  helicsInputLastUpdateTime ( ipt :: HELICS . Subscription )   ->   Float64   source  #  HELICS.helicsInputSetDefaultBoolean  \u2014  Method .  helicsInputSetDefaultBoolean ( ipt :: HELICS . Subscription ,   val :: Bool )   source  #  HELICS.helicsInputSetDefaultChar  \u2014  Method .  helicsInputSetDefaultChar ( ipt :: HELICS . Subscription ,   val :: Char )   source  #  HELICS.helicsInputSetDefaultComplex  \u2014  Method .  helicsInputSetDefaultComplex ( ipt :: HELICS . Subscription ,   c :: Complex { Float64 })   source  #  HELICS.helicsInputSetDefaultDouble  \u2014  Method .  helicsInputSetDefaultDouble ( ipt :: HELICS . Subscription ,   val :: Float64 )   source  #  HELICS.helicsInputSetDefaultInteger  \u2014  Method .  helicsInputSetDefaultInteger ( ipt :: HELICS . Subscription ,   val :: Int64 )   source  #  HELICS.helicsInputSetDefaultNamedPoint  \u2014  Method .  helicsInputSetDefaultNamedPoint ( ipt :: HELICS . Subscription ,   str :: String ,   val :: Float64 )   source  #  HELICS.helicsInputSetDefaultRaw  \u2014  Method .  helicsInputSetDefaultRaw ( ipt :: HELICS . Subscription ,   data :: Any )   source  #  HELICS.helicsInputSetDefaultString  \u2014  Method .  helicsInputSetDefaultString ( ipt :: HELICS . Subscription ,   str :: String )   source  #  HELICS.helicsInputSetDefaultTime  \u2014  Method .  helicsInputSetDefaultTime ( ipt :: HELICS . Subscription ,   val :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsInputSetDefaultVector  \u2014  Method .  helicsInputSetDefaultVector ( ipt :: HELICS . Subscription ,   vectorInput :: Array { Float64 , 1 })   source  #  HELICS.helicsInputSetInfo  \u2014  Method .  helicsInputSetInfo ( inp :: HELICS . Subscription ,   info :: String )   source  #  HELICS.helicsInputSetMinimumChange  \u2014  Method .  helicsInputSetMinimumChange ( inp :: HELICS . Subscription ,   tolerance :: Float64 )   source  #  HELICS.helicsInputSetOption  \u2014  Method .  helicsInputSetOption ( inp :: HELICS . Subscription ,   option :: Int64 ,   value :: Bool )   source  #  HELICS.helicsIsCoreTypeAvailable  \u2014  Method .  helicsIsCoreTypeAvailable ( kind :: String )   ->   Bool   Returns true if core/broker type specified is available in current compilation.  Arguments   type : a string representing a core type   Returns   a  Bool   possible options include \"test\",\"zmq\",\"udp\",\"ipc\",\"interprocess\",\"tcp\",\"default\", \"mpi\"  source  #  HELICS.helicsMessageAppendData  \u2014  Method .  helicsMessageAppendData ( message :: HELICS . Message ,   data :: String )   Append data to the payload  Arguments   message : The message object in question  data : A string containing the message data to append  inputDataLength : The length of the data to input   source  #  HELICS.helicsMessageCheckFlag  \u2014  Method .  helicsMessageCheckFlag ( message :: HELICS . Message ,   flag :: Union { Int64 ,   HELICS . Lib . helics_federate_flags })   ->   Bool   Check if a flag is set on a message  Arguments   message : The message object in question  flag : The flag to check should be between [0,15]   Returns   the flags associated with a message   source  #  HELICS.helicsMessageClearFlags  \u2014  Method .  helicsMessageClearFlags ( message :: HELICS . Message )   Clear the flags of a message  Arguments   message : The message object in question   source  #  HELICS.helicsMessageGetDestination  \u2014  Method .  helicsMessageGetDestination ( message :: HELICS . Message )   ->   String   Get the destination endpoint of a message  Arguments   message : The message object in question   Returns   a string with the destination endpoint   source  #  HELICS.helicsMessageGetMessageID  \u2014  Method .  helicsMessageGetMessageID ( message :: HELICS . Message )   ->   Int64   Get the messageID of a message  Arguments   message : The message object in question   Returns   the messageID   source  #  HELICS.helicsMessageGetOriginalDestination  \u2014  Method .  helicsMessageGetOriginalDestination ( message :: HELICS . Message )   ->   String   Get the original destination endpoint of a message, the destination may have been modified by filters or other actions  Arguments   message : The message object in question   Returns   a string with the original destination of a message   source  #  HELICS.helicsMessageGetOriginalSource  \u2014  Method .  helicsMessageGetOriginalSource ( message :: HELICS . Message )   ->   String   Get the original source endpoint of a message, the source may have modified by filters or other actions  Arguments   message : The message object in question   Returns   a string with the source of a message   source  #  HELICS.helicsMessageGetRawData  \u2014  Method .  helicsMessageGetRawData ( message :: HELICS . Message )   ->   String   Get the raw data for a message object   message : A message object to get the data for  data : The memory location of the data  maxMessagelen : The maximum size of information that data can hold  actualSize : The actual length of data copied to data   source  #  HELICS.helicsMessageGetRawDataPointer  \u2014  Method .  helicsMessageGetRawDataPointer ( message :: HELICS . Message )   ->   Ptr { Nothing }   Get a pointer to the raw data of a message  Arguments   message : A message object to get the data for   Returns   a pointer to the raw data in memory, the   pointer may be NULL if the message is not a valid message  source  #  HELICS.helicsMessageGetRawDataSize  \u2014  Method .  helicsMessageGetRawDataSize ( message :: HELICS . Message )   ->   Int64   Get the size of the data payload in bytes  Arguments   message : The message object in question   Returns   the size of the data payload   source  #  HELICS.helicsMessageGetSource  \u2014  Method .  helicsMessageGetSource ( message :: HELICS . Message )   ->   String   Get the source endpoint of a message   message operation functions   functions for working with helics message envelopes  Arguments   message : The message object in question   Returns   a string with the source endpoint   source  #  HELICS.helicsMessageGetString  \u2014  Method .  helicsMessageGetString ( message :: HELICS . Message )   ->   String   Get the payload of a message as a string  Arguments   message : The message object in question   Returns   a string representing the payload of a message   source  #  HELICS.helicsMessageGetTime  \u2014  Method .  helicsMessageGetTime ( message :: HELICS . Message )   ->   Float64   Get the helics time associated with a message  Arguments   message : The message object in question   Returns   the time associated with a message   source  #  HELICS.helicsMessageIsValid  \u2014  Method .  helicsMessageIsValid ( message :: HELICS . Message )   ->   Bool   A check if the message contains a valid payload  Arguments   message : The message object in question   Returns   true if the message contains a payload   source  #  HELICS.helicsMessageReserve  \u2014  Method .  helicsMessageReserve ( message :: HELICS . Message ,   reserveSize :: Int64 )   Reserve space in a buffer but don't actually resize  the message data buffer will be reserved but not resized  Arguments   message : The message object in question  reserveSize : The number of bytes to reserve in the message object   source  #  HELICS.helicsMessageResize  \u2014  Method .  helicsMessageResize ( message :: HELICS . Message ,   newSize :: Int64 )   Resize the data buffer for a message  the message data buffer will be resized there is no guarantees on what is in the buffer in newly allocated space if the allocated space is not sufficient new allocations will occur  Arguments   message : The message object in question  newSize : The new size in bytes of the buffer   source  #  HELICS.helicsMessageSetData  \u2014  Method .  helicsMessageSetData ( message :: HELICS . Message ,   data :: String )   Set the data payload of a message as raw data  Arguments   message : The message object in question  data : A string containing the message data  inputDataLength : The length of the data to input   source  #  HELICS.helicsMessageSetDestination  \u2014  Method .  helicsMessageSetDestination ( message :: HELICS . Message ,   dest :: String )   Set the destination of a message  Arguments   message : The message object in question  dest : A string containing the new destination   source  #  HELICS.helicsMessageSetFlagOption  \u2014  Method .  helicsMessageSetFlagOption ( message :: HELICS . Message ,   flag :: Union { Int64 ,   HELICS . Lib . helics_federate_flags },   flagValue :: Bool )   Set a flag on a message  Arguments   message : The message object in question  flag : An index of a flag to set on the message  flagValue : The desired value of the flag   source  #  HELICS.helicsMessageSetMessageID  \u2014  Method .  helicsMessageSetMessageID ( message :: HELICS . Message ,   messageID :: Int32 )   Set the message ID for the message  normally this is not needed and the core of HELICS will adjust as needed  Arguments   message : The message object in question  messageID : A new message ID   source  #  HELICS.helicsMessageSetOriginalDestination  \u2014  Method .  helicsMessageSetOriginalDestination ( message :: HELICS . Message ,   dest :: String )   Set the original destination of a message  Arguments   message : The message object in question  dest : A string containing the new original source   source  #  HELICS.helicsMessageSetOriginalSource  \u2014  Method .  helicsMessageSetOriginalSource ( message :: HELICS . Message ,   src :: String )   Set the original source of a message  Arguments   message : The message object in question  src : A string containing the new original source   source  #  HELICS.helicsMessageSetSource  \u2014  Method .  helicsMessageSetSource ( message :: HELICS . Message ,   src :: String )   Set the source of a message  Arguments   message : The message object in question  src : A string containing the source   source  #  HELICS.helicsMessageSetString  \u2014  Method .  helicsMessageSetString ( message :: HELICS . Message ,   str :: String )   Set the data payload of a message as a string  Arguments   message : The message object in question  str : A string containing the message data   source  #  HELICS.helicsMessageSetTime  \u2014  Method .  helicsMessageSetTime ( message :: HELICS . Message ,   time :: Union { Float64 ,   Int64 })   Set the delivery time for a message  Arguments   message : The message object in question  time : The time the message should be delivered   source  #  HELICS.helicsPublicationAddTarget  \u2014  Method .  helicsPublicationAddTarget ( pub :: HELICS . Publication ,   target :: String )   source  #  HELICS.helicsPublicationGetInfo  \u2014  Method .  helicsPublicationGetInfo ( pub :: HELICS . Publication )   ->   String   source  #  HELICS.helicsPublicationGetKey  \u2014  Method .  helicsPublicationGetKey ( pub :: HELICS . Publication )   ->   String   source  #  HELICS.helicsPublicationGetOption  \u2014  Method .  helicsPublicationGetOption ( pub :: HELICS . Publication ,   option :: Int64 )   ->   Bool   source  #  HELICS.helicsPublicationGetType  \u2014  Method .  helicsPublicationGetType ( pub :: HELICS . Publication )   ->   String   source  #  HELICS.helicsPublicationGetUnits  \u2014  Method .  helicsPublicationGetUnits ( pub :: HELICS . Publication )   ->   String   source  #  HELICS.helicsPublicationPublishBoolean  \u2014  Method .  helicsPublicationPublishBoolean ( pub :: HELICS . Publication ,   val :: Bool )   source  #  HELICS.helicsPublicationPublishChar  \u2014  Method .  helicsPublicationPublishChar ( pub :: HELICS . Publication ,   val :: Char )   source  #  HELICS.helicsPublicationPublishComplex  \u2014  Method .  helicsPublicationPublishComplex ( pub :: HELICS . Publication ,   c :: Complex { Float64 })   source  #  HELICS.helicsPublicationPublishDouble  \u2014  Method .  helicsPublicationPublishDouble ( pub :: HELICS . Publication ,   val :: Float64 )   source  #  HELICS.helicsPublicationPublishInteger  \u2014  Method .  helicsPublicationPublishInteger ( pub :: HELICS . Publication ,   val :: Int64 )   source  #  HELICS.helicsPublicationPublishNamedPoint  \u2014  Method .  helicsPublicationPublishNamedPoint ( pub :: HELICS . Publication ,   str :: String ,   val :: Float64 )   source  #  HELICS.helicsPublicationPublishRaw  \u2014  Method .  helicsPublicationPublishRaw ( pub :: HELICS . Publication ,   data :: Any )   source  #  HELICS.helicsPublicationPublishString  \u2014  Method .  helicsPublicationPublishString ( pub :: HELICS . Publication ,   str :: String )   source  #  HELICS.helicsPublicationPublishTime  \u2014  Method .  helicsPublicationPublishTime ( pub :: HELICS . Publication ,   val :: Union { Float64 ,   Int64 })   source  #  HELICS.helicsPublicationPublishVector  \u2014  Method .  helicsPublicationPublishVector ( pub :: HELICS . Publication ,   vectorInput :: Array { Float64 , 1 })   source  #  HELICS.helicsPublicationSetInfo  \u2014  Method .  helicsPublicationSetInfo ( pub :: HELICS . Publication ,   info :: String )   source  #  HELICS.helicsPublicationSetOption  \u2014  Method .  helicsPublicationSetOption ( pub :: HELICS . Publication ,   option :: Int64 ,   val :: Bool )   source  #  HELICS.helicsQueryBrokerExecute  \u2014  Method .  helicsQueryBrokerExecute ( query :: HELICS . Query ,   broker :: HELICS . Broker )   ->   String   Execute a  Query  directly on a broker  the call will block until the  Query  finishes which may require communication or other delays  Arguments   query : the  Query  to use in the query  broker : the broker to send the  Query  to   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if fed or  Query  is an invalid object, the return string will be \"#invalid\" if the  Query  itself was invalid  source  #  HELICS.helicsQueryCoreExecute  \u2014  Method .  helicsQueryCoreExecute ( query :: HELICS . Query ,   core :: HELICS . Core )   ->   String   Execute a  Query  directly on a core  the call will block until the  Query  finishes which may require communication or other delays  Arguments   query : the  Query  to use in the query  core : the core to send the  Query  to   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if fed or  Query  is an invalid object, the return string will be \"#invalid\" if the  Query  itself was invalid  source  #  HELICS.helicsQueryExecute  \u2014  Method .  helicsQueryExecute ( query :: HELICS . Query ,   fed :: HELICS . Federate )   ->   String   Execute a query  the call will block until the  Query  finishes which may require communication or other delays  Arguments   query : the  Query  to use in the query  fed : a federate to send the  Query  through   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if fed or  Query  is an invalid object, the return string will be \"#invalid\" if the  Query  itself was invalid  source  #  HELICS.helicsQueryExecuteAsync  \u2014  Method .  helicsQueryExecuteAsync ( query :: HELICS . Query ,   fed :: HELICS . Federate )   Execute a  Query  in a non-blocking call  Arguments   query : the  Query  to use in the query  fed : a federate to send the  Query  through   source  #  HELICS.helicsQueryExecuteComplete  \u2014  Method .  helicsQueryExecuteComplete ( query :: HELICS . Query )   ->   String   Complete the return from a  Query  called with  helicsQueryExecuteAsync  the function will block until the  Query  completes  helicsQueryIsCompleted  can be called to determine if a  Query  has completed or not.  Arguments   query : the  Query  to complete execution of   Returns   a string. String will remain valid until the  Query  is freed or executed again   the return will be nullptr if  Query  is an invalid object  source  #  HELICS.helicsQueryFree  \u2014  Method .  helicsQueryFree ( query :: HELICS . Query )   Free the memory associated with a  Query  source  #  HELICS.helicsQueryIsCompleted  \u2014  Method .  helicsQueryIsCompleted ( query :: HELICS . Query )   ->   Bool   Check if an asynchronously executed  Query  has completed  this function should usually be called after a QueryExecuteAsync function has been called.  Arguments   query : the  Query  to check if completed   Returns   will return  true  if an asynchronous  Query  has complete or a regular  Query  call was made with a result and  false  if an asynchronous  Query  has not completed or is invalid   source  #  HELICS.helicsSubscriptionGetKey  \u2014  Method .  helicsSubscriptionGetKey ( ipt :: HELICS . Subscription )   ->   String   source",
            "title": "API"
        }
    ]
}
var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"This is the Julia API for the HELICS library.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using HELICS; const h = HELICS;\nh.helicsGetVersion()","category":"page"},{"location":"api/#Enum-1","page":"API","title":"Enum","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [HELICS]\nFilter = t -> typeof(t) === DataType && t <: HELICS.Lib.CEnum.Cenum","category":"page"},{"location":"api/#HELICS.HELICS_CORE_TYPE","page":"API","title":"HELICS.HELICS_CORE_TYPE","text":"Pick a core type depending on compile configuration\n\nHELICS_CORE_TYPE_DEFAULT: a default core type that will default to something available (0)\nHELICS_CORE_TYPE_ZMQ: use the Zero MQ networking protocol (1)\nHELICS_CORE_TYPE_MPI: use MPI for operation on a parallel cluster (2)\nHELICS_CORE_TYPE_TEST: use the Test core if all federates are in the same process (3)\nHELICS_CORE_TYPE_INTERPROCESS: interprocess uses memory mapped files to transfer data (for use when all federates are on the same machine (4)\nHELICS_CORE_TYPE_IPC: interprocess uses memory mapped files to transfer data (for use when all federates are on the same machine ipc is the same as HELICS_CORE_TYPE_INTERPROCESS (5)\nHELICS_CORE_TYPE_TCP: use a generic TCP protocol message stream to send messages (6)\nHELICS_CORE_TYPE_UDP: use UDP packets to send the data (7)\nHELICS_CORE_TYPE_ZMQ_TEST: single socket version of ZMQ core usually for high fed count on the same system (10)\nHELICS_CORE_TYPE_NNG: for using the nanomsg communications (9)\nHELICS_CORE_TYPE_TCP_SS: a single socket version of the TCP core for more easily handling firewalls (11)\nHELICS_CORE_TYPE_HTTP: a core type using http for communication (12)\nHELICS_CORE_TYPE_WEBSOCKET: a core using websockets for communication (14)\nHELICS_CORE_TYPE_INPROC: an in process core type for handling communications in shared memory it is pretty similar to the test core but stripped from the \"test\" components (18)\nHELICS_CORE_TYPE_NULL: an explicit core type that is recognized but explicitly doesn't exist, for testing and a few other assorted reasons (66)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_DATA_TYPE","page":"API","title":"HELICS.HELICS_DATA_TYPE","text":"Enumeration of allowable data types for publications and inputs\n\nHELICS_DATA_TYPE_STRING: a sequence of characters (0)\nHELICS_DATA_TYPE_DOUBLE: a double precision floating point number (1)\nHELICS_DATA_TYPE_INT: a 64 bit integer (2)\nHELICS_DATA_TYPE_COMPLEX: a pair of doubles representing a complex number (3)\nHELICS_DATA_TYPE_VECTOR: an array of doubles (4)\nHELICS_DATA_TYPE_COMPLEX_VECTOR: a complex vector object (5)\nHELICS_DATA_TYPE_NAMED_POINT: a named point consisting of a string and a double (6)\nHELICS_DATA_TYPE_BOOLEAN: a boolean data type (7)\nHELICS_DATA_TYPE_TIME: time data type (8)\nHELICS_DATA_TYPE_RAW: raw data type (25)\nHELICS_DATA_TYPE_ANY: open type that can be anything (25262)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_ERROR_TYPES","page":"API","title":"HELICS.HELICS_ERROR_TYPES","text":"Enumeration of return values from the C interface functions\n\nHELICS_OK: the function executed successfully (0)\nHELICS_ERROR_REGISTRATION_FAILURE: registration has failed (-1)\nHELICS_ERROR_CONNECTION_FAILURE: the operation to connect has failed (-2)\nHELICS_ERROR_INVALID_OBJECT: indicator that the object used was not a valid object (-3)\nHELICS_ERROR_INVALID_ARGUMENT: the parameter passed was invalid and unable to be used (-4)\nHELICS_ERROR_DISCARD: the input was discarded and not used for some reason (-5)\nHELICS_ERROR_SYSTEM_FAILURE: the federate has terminated unexpectedly and the call cannot be completed (-6)\nHELICS_WARNING: the function issued a warning of some kind (-8)\nHELICS_ERROR_INVALID_STATE_TRANSITION: error issued when an invalid state transition occurred (-9)\nHELICS_ERROR_INVALID_FUNCTION_CALL: the call made was invalid in the present state of the calling object (-10)\nHELICS_ERROR_EXECUTION_FAILURE: the function execution has failed (-14)\nHELICS_ERROR_INSUFFICIENT_SPACE: insufficient space is available to store requested data (-18)\nHELICS_ERROR_OTHER: the function produced a helics error of some other type (-101)\nHELICS_ERROR_FATAL: global fatal error for federation (-404)\nHELICS_ERROR_EXTERNAL_TYPE: an unknown non-helics error was produced (-203)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_FEDERATE_FLAGS","page":"API","title":"HELICS.HELICS_FEDERATE_FLAGS","text":"Enumeration of possible federate flags\n\nHELICS_FLAG_OBSERVER: flag indicating that a federate is observe only (0)\nHELICS_FLAG_UNINTERRUPTIBLE: flag indicating that a federate can only return requested times (1)\nHELICS_FLAG_INTERRUPTIBLE: flag indicating that a federate can be interrupted (2)\nHELICS_FLAG_SOURCE_ONLY: flag indicating that a federate/interface is a signal generator only (4)\nHELICS_FLAG_ONLY_TRANSMIT_ON_CHANGE: flag indicating a federate/interface should only transmit values if they have changed(binary equivalence) (6)\nHELICS_FLAG_ONLY_UPDATE_ON_CHANGE: flag indicating a federate/interface should only trigger an update if a value has changed (binary equivalence) (8)\nHELICS_FLAG_WAIT_FOR_CURRENT_TIME_UPDATE: flag indicating a federate should only grant time if all other federates have already passed the requested time (10)\nHELICS_FLAG_RESTRICTIVE_TIME_POLICY: flag indicating a federate should operate on a restrictive time policy, which disallows some 2nd order time evaluation and can be useful for certain types of dependency cycles and update patterns, but generally shouldn't be used as it can lead to some very slow update conditions (11)\nHELICS_FLAG_ROLLBACK: flag indicating that a federate has rollback capability (12)\nHELICS_FLAG_FORWARD_COMPUTE: flag indicating that a federate performs forward computation and does internal rollback (14)\nHELICS_FLAG_REALTIME: flag indicating that a federate needs to run in real time (16)\nHELICS_FLAG_SINGLE_THREAD_FEDERATE: flag indicating that the federate will only interact on a single thread (27)\nHELICS_FLAG_SLOW_RESPONDING: flag specifying that a federate, core, or broker may be slow to respond to pings If the federate goes offline there is no good way to detect it so use with caution (29)\nHELICS_FLAG_DELAY_INIT_ENTRY: used to delay a core from entering initialization mode even if it would otherwise be ready (45)\nHELICS_FLAG_ENABLE_INIT_ENTRY: used to clear the HELICSDELAYINIT_ENTRY flag in cores (47)\nHELICS_FLAG_IGNORE_TIME_MISMATCH_WARNINGS: used to not display warnings on mismatched requested times (67)\nHELICS_FLAG_TERMINATE_ON_ERROR: specify that a federate error should terminate the federation (72)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_FEDERATE_STATE","page":"API","title":"HELICS.HELICS_FEDERATE_STATE","text":"Enumeration of possible federate states\n\nHELICS_STATE_STARTUP: when created the federate is in startup state (0)\nHELICS_STATE_INITIALIZATION: entered after the enterInitializingMode call has returned (1)\nHELICS_STATE_EXECUTION: entered after the enterExectuationState call has returned (2)\nHELICS_STATE_FINALIZE: the federate has finished executing normally final values may be retrieved (3)\nHELICS_STATE_ERROR: error state no core communication is possible but values can be retrieved the following states are for asynchronous operations (4)\nHELICS_STATE_PENDING_INIT: indicator that the federate is pending entry to initialization state (5)\nHELICS_STATE_PENDING_EXEC: state pending EnterExecution State (6)\nHELICS_STATE_PENDING_TIME: state that the federate is pending a timeRequest (7)\nHELICS_STATE_PENDING_ITERATIVE_TIME: state that the federate is pending an iterative time request (8)\nHELICS_STATE_PENDING_FINALIZE: state that the federate is pending a finalize request (9)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_FILTER_TYPE","page":"API","title":"HELICS.HELICS_FILTER_TYPE","text":"Enumeration of the predefined filter types\n\nHELICS_FILTER_TYPE_CUSTOM: a custom filter type that executes a user defined callback (0)\nHELICS_FILTER_TYPE_DELAY: a filter type that executes a fixed delay on a message (1)\nHELICS_FILTER_TYPE_RANDOM_DELAY: a filter type that executes a random delay on the messages (2)\nHELICS_FILTER_TYPE_RANDOM_DROP: a filter type that randomly drops messages (3)\nHELICS_FILTER_TYPE_REROUTE: a filter type that reroutes a message to a different destination than originally specified (4)\nHELICS_FILTER_TYPE_CLONE: a filter type that duplicates a message and sends the copy to a different destination (5)\nHELICS_FILTER_TYPE_FIREWALL: a customizable filter type that can perform different actions on a message based on firewall like rules (6)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_HANDLE_OPTIONS","page":"API","title":"HELICS.HELICS_HANDLE_OPTIONS","text":"Enumeration of options that apply to handles\n\nHELICS_HANDLE_OPTION_CONNECTION_REQUIRED: specify that a connection is required for an interface and will generate an error if not available (397)\nHELICS_HANDLE_OPTION_CONNECTION_OPTIONAL: specify that a connection is NOT required for an interface and will only be made if available no warning will be issues if not available (402)\nHELICS_HANDLE_OPTION_SINGLE_CONNECTION_ONLY: specify that only a single connection is allowed for an interface (407)\nHELICS_HANDLE_OPTION_MULTIPLE_CONNECTIONS_ALLOWED: specify that multiple connections are allowed for an interface (409)\nHELICS_HANDLE_OPTION_BUFFER_DATA: specify that the last data should be buffered and send on subscriptions after init (411)\nHELICS_HANDLE_OPTION_STRICT_TYPE_CHECKING: specify that the types should be checked strictly for pub/sub and filters (414)\nHELICS_HANDLE_OPTION_IGNORE_UNIT_MISMATCH: specify that the mismatching units should be ignored (447)\nHELICS_HANDLE_OPTION_ONLY_TRANSMIT_ON_CHANGE: specify that an interface will only transmit on change (only applicable to publications) (6)\nHELICS_HANDLE_OPTION_ONLY_UPDATE_ON_CHANGE: specify that an interface will only update if the value has actually changed (8)\nHELICS_HANDLE_OPTION_IGNORE_INTERRUPTS: specify that an interface does not participate in determining time interrupts (475)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_ITERATION_REQUEST","page":"API","title":"HELICS.HELICS_ITERATION_REQUEST","text":"Enumeration of the different iteration results\n\nHELICS_ITERATION_REQUEST_NO_ITERATION: No iteration is requested (0)\nHELICS_ITERATION_REQUEST_FORCE_ITERATION: Force iteration return when able (1)\nHELICS_ITERATION_REQUEST_ITERATE_IF_NEEDED: Only return an iteration if necessary (2)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_ITERATION_RESULT","page":"API","title":"HELICS.HELICS_ITERATION_RESULT","text":"Enumeration of possible return values from an iterative time request\n\nHELICS_ITERATION_RESULT_NEXT_STEP: the iterations have progressed to the next time (0)\nHELICS_ITERATION_RESULT_ERROR: there was an error (1)\nHELICS_ITERATION_RESULT_HALTED: the federation has halted (2)\nHELICS_ITERATION_RESULT_ITERATING: the federate is iterating at current time (3)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_LOG_LEVELS","page":"API","title":"HELICS.HELICS_LOG_LEVELS","text":"Log level definitions\n\nHELICS_LOG_LEVEL_NO_PRINT: don't print anything except a few catastrophic errors (-1)\nHELICS_LOG_LEVEL_ERROR: only print error level indicators (0)\nHELICS_LOG_LEVEL_WARNING: only print warnings and errors (1)\nHELICS_LOG_LEVEL_SUMMARY: warning errors and summary level information (2)\nHELICS_LOG_LEVEL_CONNECTIONS: summary+ notices about federate and broker connections +messages about network connections (3)\nHELICS_LOG_LEVEL_INTERFACES: connections+ interface definitions (4)\nHELICS_LOG_LEVEL_TIMING: interfaces + timing message (5)\nHELICS_LOG_LEVEL_DATA: timing+ data transfer notices (6)\nHELICS_LOG_LEVEL_TRACE: all internal messages (7)\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.HELICS_PROPERTIES","page":"API","title":"HELICS.HELICS_PROPERTIES","text":"Enumeration of properties that apply to federates\n\nHELICS_PROPERTY_TIME_DELTA: the property controlling the minimum time delta for a federate (137)\nHELICS_PROPERTY_TIME_PERIOD: the property controlling the period for a federate (140)\nHELICS_PROPERTY_TIME_OFFSET: the property controlling time offset for the period of federate (141)\nHELICS_PROPERTY_TIME_RT_LAG: the property controlling real time lag for a federate the max time a federate can lag real time (143)\nHELICS_PROPERTY_TIME_RT_LEAD: the property controlling real time lead for a federate the max time a federate can be ahead of real time (144)\nHELICS_PROPERTY_TIME_RT_TOLERANCE: the property controlling real time tolerance for a federate sets both HELICS_PROPERTY_RT_LAG and HELICS_PROPERTY_RT_LEAD (145)\nHELICS_PROPERTY_TIME_INPUT_DELAY: the property controlling input delay for a federate (148)\nHELICS_PROPERTY_TIME_OUTPUT_DELAY: the property controlling output delay for a federate (150)\nHELICS_PROPERTY_INT_MAX_ITERATIONS: integer property controlling the maximum number of iterations in a federate (259)\nHELICS_PROPERTY_INT_LOG_LEVEL: integer property controlling the log level in a federate see HELICS_LOG_LEVELS (271)\nHELICS_PROPERTY_INT_FILE_LOG_LEVEL: integer property controlling the log level for file logging in a federate see HELICS_LOG_LEVELS (272)\nHELICS_PROPERTY_INT_CONSOLE_LOG_LEVEL: integer property controlling the log level for file logging in a federate see HELICS_LOG_LEVELS (274)\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions-1","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [HELICS]\nOrder   = [:function]","category":"page"},{"location":"api/#HELICS.helicsBrokerAddDestinationFilterToEndpoint-Tuple{HELICS.Broker,String,String}","page":"API","title":"HELICS.helicsBrokerAddDestinationFilterToEndpoint","text":"helicsBrokerAddDestinationFilterToEndpoint(broker::HELICS.Broker, filter::String, endpoint::String)\n\n\nLink a named filter to a destination endpoint\n\nArguments\n\nbroker the Broker to generate the connection from\nfilter the name of the Filter (cannot be NULL)\nendpoint the name of the Endpoint to filter the data going to (cannot be NULL)\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerAddSourceFilterToEndpoint-Tuple{HELICS.Broker,String,String}","page":"API","title":"HELICS.helicsBrokerAddSourceFilterToEndpoint","text":"helicsBrokerAddSourceFilterToEndpoint(broker::HELICS.Broker, filter::String, endpoint::String)\n\n\nLink a named filter to a source endpoint\n\nArguments\n\nbroker the Broker to generate the connection from\nfilter the name of the Filter (cannot be NULL)\nendpoint the name of the Endpoint to filter the data from (cannot be NULL)\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerClone-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerClone","text":"helicsBrokerClone(broker::HELICS.Broker) -> HELICS.Broker\n\n\nCreate a new reference to an existing broker\n\nthis will create a new broker object that references the existing broker it must be freed as well\n\nArguments\n\nbroker: an existing Broker\n\nReturns\n\na new reference to the same broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerDataLink-Tuple{HELICS.Broker,String,String}","page":"API","title":"HELICS.helicsBrokerDataLink","text":"helicsBrokerDataLink(broker::HELICS.Broker, source::String, target::String)\n\n\nLink a named publication and named input using a broker\n\nArguments\n\nbroker: the Broker to generate the connection from\nsource: the name of the Publication (cannot be NULL)\ntarget: the name of the target to send the Publication data (cannot be NULL)\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerDestroy-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerDestroy","text":"helicsBrokerDestroy(broker::HELICS.Broker)\n\n\nDisconnect and free a broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerDisconnect-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerDisconnect","text":"helicsBrokerDisconnect(broker::HELICS.Broker)\n\n\nDisconnect a broker\n\nArguments\n\nbroker: the Broker to disconnect\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerFree-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerFree","text":"helicsBrokerFree(broker::HELICS.Broker)\n\n\nRelease the memory associated with a broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerGetAddress-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerGetAddress","text":"helicsBrokerGetAddress(broker::HELICS.Broker) -> String\n\n\nGet the network address associated with a broker\n\nArguments\n\nbroker: the Broker to query\n\nReturns\n\na string with the network address of the Broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerGetIdentifier-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerGetIdentifier","text":"helicsBrokerGetIdentifier(broker::HELICS.Broker) -> String\n\n\nGet an identifier for the Broker\n\nArguments\n\nbroker: the Broker to query\n\nReturns\n\na string containing the identifier for the Broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerIsConnected-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerIsConnected","text":"helicsBrokerIsConnected(broker::HELICS.Broker) -> Bool\n\n\nCheck if a broker is connected. A connected broker implies is attached to cores or cores could reach out to communicate. return 0 if not connected , something else if it is connected.\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerIsValid-Tuple{HELICS.Broker}","page":"API","title":"HELICS.helicsBrokerIsValid","text":"helicsBrokerIsValid(broker::HELICS.Broker) -> Bool\n\n\nCheck if a broker object is a valid object\n\nArguments\n\nbroker: the Broker object to test\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerMakeConnections-Tuple{HELICS.Broker,String}","page":"API","title":"HELICS.helicsBrokerMakeConnections","text":"helicsBrokerMakeConnections(broker::HELICS.Broker, file::String)\n\n\nLoad a file containing connection information\n\nArguments\n\nbroker: the Broker to generate the connections from\nfile: A JSON or TOML file containing connection information\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerSetGlobal-Tuple{HELICS.Broker,String,String}","page":"API","title":"HELICS.helicsBrokerSetGlobal","text":"helicsBrokerSetGlobal(broker::HELICS.Broker, valueName::String, value::String)\n\n\nSet a federation global value\n\nthis overwrites any previous value for this name\n\nArguments\n\nbroker: the Broker to set the global through\nvalueName: the name of the global to set\nvalue: the value of the global\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerSetLogFile-Tuple{HELICS.Broker,String}","page":"API","title":"HELICS.helicsBrokerSetLogFile","text":"helicsBrokerSetLogFile(broker::HELICS.Broker, logFileName::String)\n\n\nSet a the log file on a broker\n\nArguments\n\nbroker: the Broker to set the global through\nlogFileName: The name of the file to log to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerSetLoggingCallback-Tuple{HELICS.Broker,Ptr{Nothing},Any}","page":"API","title":"HELICS.helicsBrokerSetLoggingCallback","text":"helicsBrokerSetLoggingCallback(broker::HELICS.Broker, logger::Ptr{Nothing}, userdata::Any)\n\n\nSet the logging callback to a broker\n\nAdd a logging callback function for the C The logging callback will be called when a message flows into a broker from the core or from a broker\n\nArguments\n\nbroker: the Broker object in which to create a Subscription must have been create with helicsCreateValueFederate or helicsCreateCombinationFederate\nlogger: a callback with signature void(int, const char *, const char *, void *); the function arguments are loglevel,  an identifier, and a message string, and a pointer to user data\nuserdata: a point to user data that is passed to the function when executing\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsBrokerWaitForDisconnect-Tuple{HELICS.Broker,Int64}","page":"API","title":"HELICS.helicsBrokerWaitForDisconnect","text":"helicsBrokerWaitForDisconnect(broker::HELICS.Broker, msToWait::Int64) -> Bool\n\n\nWait for the Broker to disconnect\n\nArguments\n\nbroker: the Broker to wait for\nmsToWait: the time out in millisecond (<0 for infinite timeout)\n\nReturns\n\ntrue if the disconnect was successful, false if there was a timeout\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCleanupLibrary-Tuple{}","page":"API","title":"HELICS.helicsCleanupLibrary","text":"helicsCleanupLibrary()\n\n\nFunction to do some housekeeping work\n\nthis runs some cleanup routines and tries to close out any residual thread that haven't been shutdown yet.\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCloseLibrary-Tuple{}","page":"API","title":"HELICS.helicsCloseLibrary","text":"helicsCloseLibrary()\n\n\nCall when done using the helics library,  this function will ensure the threads are closed properly if possible     this should be the last call before exiting,\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreAddDestinationFilterToEndpoint-Tuple{HELICS.Core,String,String}","page":"API","title":"HELICS.helicsCoreAddDestinationFilterToEndpoint","text":"helicsCoreAddDestinationFilterToEndpoint(core::HELICS.Core, filter::String, endpoint::String)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreAddSourceFilterToEndpoint-Tuple{HELICS.Core,String,String}","page":"API","title":"HELICS.helicsCoreAddSourceFilterToEndpoint","text":"helicsCoreAddSourceFilterToEndpoint(core::HELICS.Core, filter::String, endpoint::String)\n\n\nLink a named filter to a source endpoint\n\nArguments\n\ncore: the core to generate the connection from\nfilter: the name of the Filter (cannot be NULL)\nendpoint: the name of the Endpoint to filter the data from (cannot be NULL)\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreClone-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreClone","text":"helicsCoreClone(core::HELICS.Core) -> HELICS.Core\n\n\nCreate a new reference to an existing core\n\nthis will create a new broker object that references the existing broker it must be freed as well\n\nArguments\n\ncore: an existing Core\n\nReturns\n\na new reference to the same Core\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreDataLink-Tuple{HELICS.Core,String,String}","page":"API","title":"HELICS.helicsCoreDataLink","text":"helicsCoreDataLink(core::HELICS.Core, source::String, target::String)\n\n\nLink a named publication and named input using a core\n\nArguments\n\ncore: the core to generate the connection from\nsource: the name of the Publication (cannot be NULL)\ntarget: the named of the target to send the Publication data (cannot be NULL)\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreDestroy-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreDestroy","text":"helicsCoreDestroy(core::HELICS.Core)\n\n\nDisconnect and free a core\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreDisconnect-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreDisconnect","text":"helicsCoreDisconnect(core::HELICS.Core)\n\n\nGet an identifier for the core\n\nArguments\n\ncore: the core to query\n\nReturns\n\na void enumeration indicating any error condition\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreFree-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreFree","text":"helicsCoreFree(core::HELICS.Core)\n\n\nRelease the memory associated with a core\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreGetAddress-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreGetAddress","text":"helicsCoreGetAddress(core::HELICS.Core) -> String\n\n\nGet the network address associated with a core\n\nArguments\n\ncore: The core to query\n\nReturns\n\na string with the network address of the Broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreGetIdentifier-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreGetIdentifier","text":"helicsCoreGetIdentifier(core::HELICS.Core) -> String\n\n\nGet an identifier for the core\n\nArguments\n\ncore: the core to query\n\nReturns\n\na string with the identifier of the core\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreIsConnected-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreIsConnected","text":"helicsCoreIsConnected(core::HELICS.Core) -> Bool\n\n\nCheck if a core is connected. A connected core implies is attached to federate or federates could be attached to it.\n\nReturns\n\nfalse if not connected, true if it is connected\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreIsValid-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreIsValid","text":"helicsCoreIsValid(core::HELICS.Core) -> Bool\n\n\nCheck if a core object is a valid object\n\nArguments\n\ncore: the Core object to test\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreMakeConnections-Tuple{HELICS.Core,String}","page":"API","title":"HELICS.helicsCoreMakeConnections","text":"helicsCoreMakeConnections(core::HELICS.Core, file::String)\n\n\nLoad a file containing connection information\n\nArguments\n\ncore: The core to generate the connections from\nfile: A JSON or TOML file containing connection information\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreRegisterCloningFilter-Tuple{HELICS.Core,String}","page":"API","title":"HELICS.helicsCoreRegisterCloningFilter","text":"helicsCoreRegisterCloningFilter(core::HELICS.Core, name::String) -> HELICS.Filter\n\n\nCreate a cloning Filter on the specified core\n\nCloning filters copy a message and send it to multiple locations source and destination can be added through other functions\n\nArguments\n\ncore: the core to register through\nname: the name of the Filter (can be NULL)\n\nReturns\n\na Filter object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreRegisterFilter-Tuple{HELICS.Core,Union{Int64, HELICS.Lib.helics_filter_type},String}","page":"API","title":"HELICS.helicsCoreRegisterFilter","text":"helicsCoreRegisterFilter(core::HELICS.Core, kind::Union{Int64, HELICS.Lib.helics_filter_type}, name::String) -> HELICS.Filter\n\n\nCreate a source Filter on the specified core\n\nFilters can be created through a Federate or a core , linking through a federate allows a few extra features of name matching to function on the Federate interface but otherwise equivalent behavior\n\nArguments\n\ncore the core to register through\ntype the type of filter to create HELICS_FILTER_TYPE\nname the name of the Filter (can be NULL)\n\nReturns\n\na Filter object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreSetGlobal-Tuple{HELICS.Core,String,String}","page":"API","title":"HELICS.helicsCoreSetGlobal","text":"helicsCoreSetGlobal(core::HELICS.Core, valueName::String, value::String)\n\n\nSet a global value in a core\n\nthis overwrites any previous value for this name\n\nArguments\n\ncore: the core to set the global through\nvalueName: the name of the global to set\nvalue: the value of the global\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreSetLogFile-Tuple{HELICS.Core,String}","page":"API","title":"HELICS.helicsCoreSetLogFile","text":"helicsCoreSetLogFile(core::HELICS.Core, logFileName::String)\n\n\nSet a the log file on a core\n\nArguments\n\ncore: The core to set the global through\nlogFileName: The name of the file to log to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreSetLoggingCallback-Tuple{HELICS.Core,Ptr{Nothing},Any}","page":"API","title":"HELICS.helicsCoreSetLoggingCallback","text":"helicsCoreSetLoggingCallback(core::HELICS.Core, logger::Ptr{Nothing}, userdata::Any)\n\n\nSet the logging callback for a core\n\nAdd a logging callback function for the C The logging callback will be called when a message flows into a core from the core or from a broker\n\nArguments\n\ncore: the core object in which to create a Subscription must have been create with helicsCreateValueFederate or helicsCreateCombinationFederate\nlogger: a callback with signature void(int, const char *, const char *, void *); the function arguments are loglevel,  an identifier, and a message string\nuserdata: a point to user data that is passed to the function when executing\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreSetReadyToInit-Tuple{HELICS.Core}","page":"API","title":"HELICS.helicsCoreSetReadyToInit","text":"helicsCoreSetReadyToInit(core::HELICS.Core)\n\n\nSet the core to ready for init\n\nthis function is used for cores that have filters but no federates so there needs to be a direct signal to the core to trigger the federation initialization\n\nArguments\n\ncore: the core object to enable init values for\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCoreWaitForDisconnect-Tuple{HELICS.Core,Int64}","page":"API","title":"HELICS.helicsCoreWaitForDisconnect","text":"helicsCoreWaitForDisconnect(core::HELICS.Core, msWait::Int64) -> Int32\n\n\nWait for the core to disconnect\n\nArguments\n\ncore: The core to wait for\nmsToWait: The time out in millisecond (<0 for infinite timeout)\n\nReturns\n\ntrue if the disconnect was successful, false if there was a timeout\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateBroker-Tuple{String,String,String}","page":"API","title":"HELICS.helicsCreateBroker","text":"helicsCreateBroker(kind::String, name::String, initString::String) -> HELICS.Broker\n\n\nCreate a broker object\n\nArguments\n\ntype: the type of Broker to create\nname: the name of Broker, may be a empty string to have a name automatically assigned\ninitString: an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  –broker=\"XSSAF\" if this is a subbroker or the number of federates or the address\n\nReturns\n\na Broker object, will be NULL if there was an error indicated in the err object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateBrokerFromArgs-Tuple{String,String,Array{#s45,1} where #s45<:AbstractString}","page":"API","title":"HELICS.helicsCreateBrokerFromArgs","text":"helicsCreateBrokerFromArgs(kind::String, name::String, argv::Array{#s45,1} where #s45<:AbstractString) -> HELICS.Broker\n\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateCombinationFederate-Tuple{String,HELICS.FederateInfo}","page":"API","title":"HELICS.helicsCreateCombinationFederate","text":"helicsCreateCombinationFederate(fedName::String, fi::HELICS.FederateInfo) -> HELICS.CombinationFederate\n\n\nCreate a CombinationFederate from a FederateInfo object\n\nCombinationFederate are both ValueFederate and MessageFederate, objects can be used in all functions that take a Federate, MessageFederate or ValueFederate object as an argument\n\nArguments\n\nfedName: a string with the name of the Federate, can be NULL or an empty string to pull the default name from fi\nfi: the FederateInfo object that contains details on the Federate\n\nReturns\n\nValueFederate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateCombinationFederateFromConfig-Tuple{String}","page":"API","title":"HELICS.helicsCreateCombinationFederateFromConfig","text":"helicsCreateCombinationFederateFromConfig(configFile::String) -> HELICS.CombinationFederate\n\n\nCreate a CombinationFederate from a JSON file or JSON string\n\nCombinationFederate are both ValueFederate and MessageFederate, objects can be used in all functions that take a Federate, MessageFederate or ValueFederate object as an argument\n\nArguments\n\nconfigFile:  a JSON file or a JSON string or TOML file that contains setup and configuration information\n\nReturns\n\nCombinationFederate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateCore-Tuple{String,String,String}","page":"API","title":"HELICS.helicsCreateCore","text":"helicsCreateCore(kind::String, name::String, initString::String) -> HELICS.Core\n\n\nCreate a core object\n\nArguments\n\ntype: the type of the core to create\nname: the name of the core , may be a empty string to have a name automatically assigned\ninitString: an initialization string to send to the core-the format is similar to command line arguments. Typical options include a broker address  –broker=\"XSSAF\" or the number of federates or the address\n\nReturns\n\na Core object if the core is invalid err will contain some indication\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateCoreFromArgs-Tuple{String,String,Array{#s45,1} where #s45<:AbstractString}","page":"API","title":"HELICS.helicsCreateCoreFromArgs","text":"helicsCreateCoreFromArgs(kind::String, name::String, argv::Array{#s45,1} where #s45<:AbstractString) -> HELICS.Core\n\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateFederateInfo-Tuple{}","page":"API","title":"HELICS.helicsCreateFederateInfo","text":"helicsCreateFederateInfo() -> HELICS.FederateInfo\n\n\nCreate a FederateInfo object for specifying federate information when constructing a Federate\n\nReturns\n\na FederateInfo object which is a reference to the created object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateMessageFederate-Tuple{String,HELICS.FederateInfo}","page":"API","title":"HELICS.helicsCreateMessageFederate","text":"helicsCreateMessageFederate(fedName::String, fi::HELICS.FederateInfo) -> HELICS.MessageFederate\n\n\nCreate a MessageFederate from a FederateInfo object\n\nMessageFederate objects can be used in all functions that take a MessageFederate or Federate object as an argument\n\nArguments\n\nfedName: the name of the Federate to create\nfi: the FederateInfo object that contains details on the Federate\n\nReturns\n\nMessageFederate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateMessageFederateFromConfig-Tuple{String}","page":"API","title":"HELICS.helicsCreateMessageFederateFromConfig","text":"helicsCreateMessageFederateFromConfig(configFile::String) -> HELICS.MessageFederate\n\n\nCreate a MessageFederate from a JSON file or JSON string or TOML file\n\nMessageFederate objects can be used in all functions that take a MessageFederate or Federate object as an argument\n\nArguments\n\nconfigFile:  a Config(JSON,TOML) file or a JSON string that contains setup and configuration information\n\nReturns\n\nMessageFederate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateQuery-Tuple{String,String}","page":"API","title":"HELICS.helicsCreateQuery","text":"helicsCreateQuery(target::String, query::String) -> HELICS.Query\n\n\nCreate a Query\n\na Query consists of a target and query string\n\nArguments\n\ntarget: the name of the target to query\nquery: the query string to make of the target\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateValueFederate-Tuple{String,HELICS.FederateInfo}","page":"API","title":"HELICS.helicsCreateValueFederate","text":"helicsCreateValueFederate(fedName::String, fi::HELICS.FederateInfo) -> HELICS.ValueFederate\n\n\nCreate a value federate from a FederateInfo object\n\nFederate objects can be used in all functions that take a Federate object as an argument\n\nArguments\n\nfedName: the name of the Federate to create, can NULL or an empty string to use the default name from fi or an assigned name\nfi: the FederateInfo object that contains details on the Federate\n\nReturns\n\nValueFederate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsCreateValueFederateFromConfig-Tuple{String}","page":"API","title":"HELICS.helicsCreateValueFederateFromConfig","text":"helicsCreateValueFederateFromConfig(configFile::String) -> HELICS.ValueFederate\n\n\nCreate a value federate from a JSON file, JSON string, or TOML file\n\nFederate objects can be used in all functions that take a Federate object as an argument\n\nArguments\n\nconfigFile:  a JSON file or a JSON string or TOML file that contains setup and configuration information\n\nReturns\n\nValueFederate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointClearMessages-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointClearMessages","text":"helicsEndpointClearMessages(endpoint::HELICS.Endpoint)\n\n\nClear all message from an Endpoint\n\nArguments\n\nendpoint: The Endpoint object to operate on\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetDefaultDestination-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointGetDefaultDestination","text":"helicsEndpointGetDefaultDestination(endpoint::HELICS.Endpoint) -> String\n\n\nGet the default destination for an Endpoint\n\nArguments\n\nendpoint: The Endpoint to set the destination for\n\nReturns\n\na string with the default destination\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetInfo-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointGetInfo","text":"helicsEndpointGetInfo(_end::HELICS.Endpoint) -> String\n\n\nGet the data in the info field of an filter\n\nArguments\n\nend: The Filter to query\n\nReturns\n\na string with the info field string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetMessage-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointGetMessage","text":"helicsEndpointGetMessage(endpoint::HELICS.Endpoint) -> HELICS.Lib.helics_message\n\n\nReceive a packet from a particular endpoint\n\nArguments\n\nendpoint: The identifier for the Endpoint\n\nReturns\n\nMessage object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetMessageObject-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointGetMessageObject","text":"helicsEndpointGetMessageObject(endpoint::HELICS.Endpoint) -> HELICS.Message\n\n\nReceive a packet from a particular endpoint\n\nArguments\n\nendpoint: The identifier for the Endpoint\n\nReturns\n\nMessage object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetName-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointGetName","text":"helicsEndpointGetName(endpoint::HELICS.Endpoint) -> String\n\n\nget the name of an Endpoint\n\nArguments\n\nendpoint: The Endpoint object in question\n\nReturns\n\nthe name of the Endpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetOption-Tuple{HELICS.Endpoint,Union{Int64, HELICS.Lib.helics_handle_options}}","page":"API","title":"HELICS.helicsEndpointGetOption","text":"helicsEndpointGetOption(_end::HELICS.Endpoint, option::Union{Int64, HELICS.Lib.helics_handle_options}) -> Bool\n\n\nGet a handle option on an Endpoint\n\nend: The Endpoint to modify\noption: Integer code for the option to set HELICS_HANDLE_OPTIONS\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointGetType-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointGetType","text":"helicsEndpointGetType(endpoint::HELICS.Endpoint) -> String\n\n\nGet the type specified for an Endpoint\n\nArguments\n\nendpoint: The Endpoint object in question\n\nReturns\n\nthe defined type of the Endpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointHasMessage-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointHasMessage","text":"helicsEndpointHasMessage(endpoint::HELICS.Endpoint) -> Bool\n\n\nCheck if a given endpoint has any unread messages\n\nArguments\n\nendpoint: The Endpoint to check\n\nReturns\n\ntrue if the Endpoint has a message, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointPendingMessages-Tuple{HELICS.Endpoint}","page":"API","title":"HELICS.helicsEndpointPendingMessages","text":"helicsEndpointPendingMessages(endpoint::HELICS.Endpoint) -> Int64\n\n\nReturns the number of pending receives for all endpoints of particular federate.\n\nArguments\n\nendpoint: The Endpoint to query\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSendEventRaw-Tuple{HELICS.Endpoint,String,String,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsEndpointSendEventRaw","text":"helicsEndpointSendEventRaw(endpoint::HELICS.Endpoint, dest::String, data::String, time::Union{Float64, Int64})\n\n\nSend a message at a specific time to the specified destination\n\nArguments\n\nendpoint: The Endpoint to send the data from\ndest: The target destination (empty string to use the default destination)\ndata: The data to send\ntime: The time the message should be sent\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSendMessage-Tuple{HELICS.Endpoint,HELICS.Lib.helics_message}","page":"API","title":"HELICS.helicsEndpointSendMessage","text":"helicsEndpointSendMessage(endpoint::HELICS.Endpoint, message::HELICS.Lib.helics_message)\n\n\nSend a message object from a specific endpoint\n\nArguments\n\nendpoint: The Endpoint to send the data from\nmessage: The Lib.helics_message to send\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSendMessageObject-Tuple{HELICS.Endpoint,HELICS.Message}","page":"API","title":"HELICS.helicsEndpointSendMessageObject","text":"helicsEndpointSendMessageObject(endpoint::HELICS.Endpoint, message::HELICS.Message)\n\n\nSend a message object from a specific endpoint\n\nArguments\n\nendpoint: The Endpoint to send the data from\nmessage: The Message to send\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSendMessageRaw-Tuple{HELICS.Endpoint,String,String}","page":"API","title":"HELICS.helicsEndpointSendMessageRaw","text":"helicsEndpointSendMessageRaw(endpoint::HELICS.Endpoint, dest::String, data::String)\n\n\nSend a message to the specified destination\n\nArguments\n\nendpoint: The Endpoint to send the data from\ndest: The target destination (empty string to use the default destination)\ndata: The data to send\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSetDefaultDestination-Tuple{HELICS.Endpoint,String}","page":"API","title":"HELICS.helicsEndpointSetDefaultDestination","text":"helicsEndpointSetDefaultDestination(endpoint::HELICS.Endpoint, dest::String)\n\n\nSet the default destination for an Endpoint if no other endpoint is given\n\nArguments\n\nendpoint: The Endpoint to set the destination for\ndest: A string naming the desired default endpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSetInfo-Tuple{HELICS.Endpoint,String}","page":"API","title":"HELICS.helicsEndpointSetInfo","text":"helicsEndpointSetInfo(_end::HELICS.Endpoint, info::String)\n\n\nSet the data in the info field for an filter\n\nArguments\n\nend: The Endpoint to query\ninfo: The string to set\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSetOption-Tuple{HELICS.Endpoint,Union{Int64, HELICS.Lib.helics_handle_options},Bool}","page":"API","title":"HELICS.helicsEndpointSetOption","text":"helicsEndpointSetOption(_end::HELICS.Endpoint, option::Union{Int64, HELICS.Lib.helics_handle_options}, value::Bool)\n\n\nSet a handle option on an Endpoint\n\nend: The Endpoint to modify\noption: Integer code for the option to set HELICS_HANDLE_OPTIONS\nvalue: The value to set the option\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsEndpointSubscribe-Tuple{HELICS.Endpoint,String}","page":"API","title":"HELICS.helicsEndpointSubscribe","text":"helicsEndpointSubscribe(endpoint::HELICS.Endpoint, key::String)\n\n\nSubscribe an Endpoint to a Publication\n\nArguments\n\nendpoint: The Endpoint to use\nkey: The name of the Publication\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsErrorClear-Tuple{Ref{HELICS.Lib.helics_error}}","page":"API","title":"HELICS.helicsErrorClear","text":"helicsErrorClear(err::Ref{HELICS.Lib.helics_error})\n\n\nClear an error object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsErrorInitialize-Tuple{}","page":"API","title":"HELICS.helicsErrorInitialize","text":"helicsErrorInitialize() -> HELICS.Lib.helics_error\n\n\nReturn an initialized error object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateAddDependency-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateAddDependency","text":"helicsFederateAddDependency(fed::HELICS.Federate, fedName::String)\n\n\nAdd a time dependency for a Federate.  The Federate will depend on the given named federate for time synchronization\n\nArguments\n\nfed: the Federate to add the dependency for\nfedName: the name of the Federate to depend on\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateClearMessages-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateClearMessages","text":"helicsFederateClearMessages(fed::HELICS.Federate)\n\n\nClear all stored messages from a Federate\n\nthis clears messages retrieved through helicsFederateGetMessage or helicsFederateGetMessageObject\n\nArguments\n\nfed: The Federate to clear the message for\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateClearUpdates-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateClearUpdates","text":"helicsFederateClearUpdates(fed::HELICS.Federate)\n\n\nClear all the update flags from a Federates inputs\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateClone-Union{Tuple{T}, Tuple{T}} where T<:HELICS.Federate","page":"API","title":"HELICS.helicsFederateClone","text":"helicsFederateClone(fed::T<:HELICS.Federate) -> Union{HELICS.CombinationFederate, HELICS.MessageFederate, HELICS.ValueFederate}\n\n\nCreate a new reference to an existing federate\n\nthis will create a new Federate object that references the existing federate it must be freed as well\n\nArguments\n\nfed: an existing Federate\n\nReturns\n\na new reference to the same federate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateCreateMessageObject-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateCreateMessageObject","text":"helicsFederateCreateMessageObject(fed::HELICS.Federate) -> HELICS.Message\n\n\nCreate a new empty message object\n\nThe message is empty and isValid will return false since there is no data associated with the message yet.\n\nReturns\n\na Message containing the message data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateDestroy-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateDestroy","text":"helicsFederateDestroy(fed::HELICS.Federate)\n\n\nDisconnect and free a broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterExecutingMode-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterExecutingMode","text":"helicsFederateEnterExecutingMode(fed::HELICS.Federate)\n\n\nRequest that the Federate enter the Execution mode\n\nthis call is blocking until granted entry by the core object for an asynchronous alternative call helicsFederateEnterExecutingModeAsync on return from this call the Federate will be at time 0.\n\nArguments\n\nfed: a Federate to change modes\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterExecutingModeAsync-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterExecutingModeAsync","text":"helicsFederateEnterExecutingModeAsync(fed::HELICS.Federate)\n\n\nRequest that the Federate enter the Execution mode\n\nthis call is non-blocking and will return immediately. Call helicsFederateEnterExecutingModeComplete to finish the call sequence.\n\nArguments\n\nfed: the Federate to complete the call\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterExecutingModeComplete-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterExecutingModeComplete","text":"helicsFederateEnterExecutingModeComplete(fed::HELICS.Federate)\n\n\nComplete the call to helicsFederateEnterExecutingModeAsync\n\nArguments\n\nfed: the Federate to complete the call\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterExecutingModeIterative-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_iteration_request}}","page":"API","title":"HELICS.helicsFederateEnterExecutingModeIterative","text":"helicsFederateEnterExecutingModeIterative(fed::HELICS.Federate, iterate::Union{Int64, HELICS.Lib.helics_iteration_request}) -> HELICS.Lib.helics_iteration_result\n\n\nRequest an iterative time\n\nthis call allows for finer grain control of the iterative process then helicsFederateRequestTime it takes a time and iteration request and return a time and iteration status.\n\nArguments\n\nfed: the Federate to make the request of\niterate: the requested iteration mode\n\nReturns\n\nan iteration structure with field containing the time and iteration status\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterExecutingModeIterativeAsync-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_iteration_request}}","page":"API","title":"HELICS.helicsFederateEnterExecutingModeIterativeAsync","text":"helicsFederateEnterExecutingModeIterativeAsync(fed::HELICS.Federate, iterate::Union{Int64, HELICS.Lib.helics_iteration_request})\n\n\nRequest an iterative entry to the execution mode\n\nThis call allows for finer grain control of the iterative process then helicsFederateRequestTime it takes a time and and iteration request and return a time and iteration status\n\nArguments\n\nfed: the Federate to make the request of\niterate: the requested iteration mode\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterExecutingModeIterativeComplete-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterExecutingModeIterativeComplete","text":"helicsFederateEnterExecutingModeIterativeComplete(fed::HELICS.Federate) -> HELICS.Lib.helics_iteration_result\n\n\nComplete the asynchronous iterative call into ExecutionModel\n\nArguments\n\nfed: the Federate to make the request of\n\nReturns\n\nan iteration object containing the iteration time and iteration_status\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterInitializingMode-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterInitializingMode","text":"helicsFederateEnterInitializingMode(fed::HELICS.Federate)\n\n\nEnter the initialization state of a Federate\n\nthe initialization state allows initial values to be set and received if the iteration is requested on entry to the execution state. This is a blocking call and will block until the core allows it to proceed.\n\nArguments\n\nfed: the Federate to operate on\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterInitializingModeAsync-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterInitializingModeAsync","text":"helicsFederateEnterInitializingModeAsync(fed::HELICS.Federate)\n\n\nNon blocking alternative to helicsFederateEnterInitializingMode. The function helicsFederateFinalize must be called to finish the operation\n\nArguments\n\nfed: the Federate to operate on\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateEnterInitializingModeComplete-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateEnterInitializingModeComplete","text":"helicsFederateEnterInitializingModeComplete(fed::HELICS.Federate)\n\n\nFinalize the entry to initialize mode that was initiated with helicsFederateEnterInitializingModeAsync\n\nArguments\n\nfed: the Federate desiring to complete the initialization step function\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateFinalize-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateFinalize","text":"helicsFederateFinalize(fed::HELICS.Federate)\n\n\nFinalize the Federate this function halts all communication in the Federate and disconnects it from the core\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateFinalizeAsync-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateFinalizeAsync","text":"helicsFederateFinalizeAsync(fed::HELICS.Federate)\n\n\nFinalize the Federate in an async call\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateFinalizeComplete-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateFinalizeComplete","text":"helicsFederateFinalizeComplete(fed::HELICS.Federate)\n\n\nComplete the asynchronous finalize call\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateFree-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateFree","text":"helicsFederateFree(fed::HELICS.Federate)\n\n\nRelease the memory associated with a Federate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetCoreObject-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetCoreObject","text":"helicsFederateGetCoreObject(fed::HELICS.Federate) -> HELICS.Core\n\n\nGet the core object associated with a Federate\n\nArguments\n\nfed: a Federate object\n\nReturns\n\na Core object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetCurrentTime-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetCurrentTime","text":"helicsFederateGetCurrentTime(fed::HELICS.Federate) -> Float64\n\n\nGet the current time of the Federate\n\nArguments\n\nfed: the Federate to query\n\nReturns\n\nthe current time of the Federate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetEndpoint-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateGetEndpoint","text":"helicsFederateGetEndpoint(fed::HELICS.Federate, name::String) -> HELICS.Endpoint\n\n\nGet an Endpoint object from a name\n\nArguments\n\nfed: The Federate to use to get the Endpoint\nname: The name of the Endpoint\n\nReturns\n\na Endpoint object, the object will not be valid and err will contain an error code if no endpoint with the specified name exists\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetEndpointByIndex-Tuple{HELICS.Federate,Int64}","page":"API","title":"HELICS.helicsFederateGetEndpointByIndex","text":"helicsFederateGetEndpointByIndex(fed::HELICS.Federate, index::Int64) -> HELICS.Endpoint\n\n\nGet an Endpoint by its index typically already created via helicsFederateRegisterInterfaces file or something of that nature\n\nArguments\n\nfed: the Federate in which to create a Publication\nindex: The index of the Publication to get\n\nReturns\n\na Endpoint, which will be NULL if an invalid index\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetEndpointCount-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetEndpointCount","text":"helicsFederateGetEndpointCount(fed::HELICS.Federate) -> Int64\n\n\nGet the number of endpoints in a Federate\n\nArguments\n\nfed: The Federate to query\n\nReturns\n\n(-1) if fed was not a valid federate otherwise returns the number of endpoints\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetFilter-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateGetFilter","text":"helicsFederateGetFilter(fed::HELICS.Federate, name::String) -> HELICS.Filter\n\n\nGet a Filter by its name typically already created via helicsFederateRegisterInterfaces file or something of that nature\n\nArguments\n\nfed: the Federate to use to get the Filter\nname: the name of the Filter\n\nReturns\n\na Filter object, the object will not be valid and err will contain an error code if no filter with the specified name exists\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetFilterByIndex-Tuple{HELICS.Federate,Int64}","page":"API","title":"HELICS.helicsFederateGetFilterByIndex","text":"helicsFederateGetFilterByIndex(fed::HELICS.Federate, index::Int64) -> HELICS.Filter\n\n\nGet a Filter by its index typically already created via helicsFederateRegisterInterfaces file or something of that nature\n\nArguments\n\nfed: the Federate in which to create a Publication\nindex: the index of the Publication to get\na Filter, which will be NULL if an invalid index\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetFilterCount-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetFilterCount","text":"helicsFederateGetFilterCount(fed::HELICS.Federate) -> Int64\n\n\nGet a the number of filters registered through a Federate\n\nArguments\n\nfed: the Federate to use to get the Filter\n\nReturns\n\na count of the number of filters registered through a Federate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetFlagOption-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_federate_flags, HELICS.Lib.helics_handle_options}}","page":"API","title":"HELICS.helicsFederateGetFlagOption","text":"helicsFederateGetFlagOption(fed::HELICS.Federate, flag::Union{Int64, HELICS.Lib.helics_federate_flags, HELICS.Lib.helics_handle_options}) -> Bool\n\n\nGet a flag value for a Federate\n\nArguments\n\nfed: the Federate to get the flag for\nflag: the flag to query\n\nReturns\n\nthe value of the flag\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetInput-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateGetInput","text":"helicsFederateGetInput(fed::HELICS.Federate, key::String) -> HELICS.Subscription\n\n\nGet an Input object from a key\n\nArguments\n\nfed: the value federate object to use to get the Publication\nkey: the name of the Input\n\nReturns\n\na Subscription object, the object will not be valid and err will contain an error code if no input with the specified key exists\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetInputByIndex-Tuple{HELICS.Federate,Int64}","page":"API","title":"HELICS.helicsFederateGetInputByIndex","text":"helicsFederateGetInputByIndex(fed::HELICS.Federate, index::Int64) -> HELICS.Subscription\n\n\nGet an Input by its index typically already created via helicsFederateRegisterInterfaces file or something of that nature\n\nArguments\n\nfed: the Federate in which to create a Publication\nindex: the index of the Publication to get\n\nReturns\n\na helics_input, which will be NULL if an invalid index\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetInputCount-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetInputCount","text":"helicsFederateGetInputCount(fed::HELICS.Federate) -> Int64\n\n\nGet the number of subscriptions in a Federate\n\nArguments\n\nfed: an existing Federate\n\nReturns\n\n(-1) if fed was not a valid federate otherwise returns the number of subscriptions\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetIntegerProperty-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_handle_options}}","page":"API","title":"HELICS.helicsFederateGetIntegerProperty","text":"helicsFederateGetIntegerProperty(fed::HELICS.Federate, intProperty::Union{Int64, HELICS.Lib.helics_handle_options}) -> Int64\n\n\nSet the logging level for the Federate\n\ndebug and trace only do anything if they were enabled in the compilation\n\nArguments\n\nfed: the Federate to get the flag for\nintProperty: a code for the property to set HELICS_HANDLE_OPTIONS\n\nReturns\n\nthe value of the property\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetMessage-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetMessage","text":"helicsFederateGetMessage(fed::HELICS.Federate) -> HELICS.Lib.helics_message\n\n\nReceive a communication message for any endpoint in the Federate\n\nThe return order will be in order of endpoint creation. So all messages that are available for the first endpoint, then all for the second, and so on within a single endpoint the messages are ordered by time, then source_id, then order of arrival\n\nReturns\n\na unique_ptr to a HELICS.Lib.helics_message object containing the message data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetMessageObject-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetMessageObject","text":"helicsFederateGetMessageObject(fed::HELICS.Federate) -> HELICS.Message\n\n\nReceive a communication message for any endpoint in the Federate\n\nThe return order will be in order of endpoint creation. So all messages that are available for the first endpoint, then all for the second, and so on within a single endpoint the messages are ordered by time, then source_id, then order of arrival\n\nReturns\n\na Message which references the\n\ndata in the message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetName-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetName","text":"helicsFederateGetName(fed::HELICS.Federate) -> String\n\n\nGet the name of the Federate\n\nArguments\n\nfed: the Federate to query\n\nReturns\n\na string with the name\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetPublication-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateGetPublication","text":"helicsFederateGetPublication(fed::HELICS.Federate, key::String) -> HELICS.Publication\n\n\nGet a Publication object from a key\n\nArguments\n\nfed: the value federate object to use to get the Publication\nkey: the name of the Publication\n\nReturns\n\na Publication object, the object will not be valid and err will contain an error code if no publication with the\n\nspecified key exists\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetPublicationByIndex-Tuple{HELICS.Federate,Int64}","page":"API","title":"HELICS.helicsFederateGetPublicationByIndex","text":"helicsFederateGetPublicationByIndex(fed::HELICS.Federate, index::Int64) -> HELICS.Publication\n\n\nGet a Publication by its index typically already created via helicsFederateRegisterInterfaces file or something of that nature\n\nArguments\n\nfed: the Federate in which to create a Publication\nindex: the index of the Publication to get\n\nReturns\n\na helics_publication\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetPublicationCount-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetPublicationCount","text":"helicsFederateGetPublicationCount(fed::HELICS.Federate) -> Int64\n\n\nGet the number of publications in a Federate\n\nArguments\n\nfed: an existing Federate\n\nReturns\n\n(-1) if fed was not a valid federate otherwise returns the number of publications\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetState-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateGetState","text":"helicsFederateGetState(fed::HELICS.Federate) -> HELICS.Lib.helics_federate_state\n\n\nGet the current state of a Federate\n\nArguments\n\nfed: the Federate to query\n\nReturns\n\nstate the resulting state if void return helics_ok\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetSubscription-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateGetSubscription","text":"helicsFederateGetSubscription(fed::HELICS.Federate, key::String) -> HELICS.Subscription\n\n\nGet an Input object from a Subscription target\n\nArguments\n\nfed: the value federate object to use to get the Publication\nkey: the name of the Publication that a Subscription is targeting\n\nReturns\n\na Subscription object, the object will not be valid and err will contain an error code if no input with the specified\n\nkey exists\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGetTimeProperty-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_properties}}","page":"API","title":"HELICS.helicsFederateGetTimeProperty","text":"helicsFederateGetTimeProperty(fed::HELICS.Federate, timeProperty::Union{Int64, HELICS.Lib.helics_properties}) -> Float64\n\n\nGet the current value of a time based property in a Federate\n\nArguments\n\nfed: the Federate query\ntimeProperty: the property to query\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateGlobalError-Tuple{HELICS.Federate,Integer,String}","page":"API","title":"HELICS.helicsFederateGlobalError","text":"helicsFederateGlobalError(fed::HELICS.Federate, error_code::Integer, error_string::String)\n\n\nGenerate a global Error from a Federate\n\nA global error halts the co-simulation completely\n\nArguments\n\nfed: the Federate to create an error in\nerror_code: the integer code for the error\nerror_string: a string describing the error\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateHasMessage-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateHasMessage","text":"helicsFederateHasMessage(fed::HELICS.Federate) -> Bool\n\n\nCheck if the Federate has any outstanding messages\n\nArguments\n\nfed: The Federate to check if it has\n\nReturns\n\ntrue if the Federate has a message waiting false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoClone-Tuple{HELICS.FederateInfo}","page":"API","title":"HELICS.helicsFederateInfoClone","text":"helicsFederateInfoClone(fi::HELICS.FederateInfo) -> HELICS.FederateInfo\n\n\nCreate a FederateInfo object from an existing one and clone the information\n\nArguments\n\nfi: a FederateInfo object to duplicate\n\nReturns\n\na FederateInfo object which is a reference to the created object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoFree-Tuple{HELICS.FederateInfo}","page":"API","title":"HELICS.helicsFederateInfoFree","text":"helicsFederateInfoFree(fi::HELICS.FederateInfo)\n\n\nDelete the memory associated with a FederateInfo object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoLoadFromArgs-Tuple{HELICS.FederateInfo,Array{#s45,1} where #s45<:AbstractString}","page":"API","title":"HELICS.helicsFederateInfoLoadFromArgs","text":"helicsFederateInfoLoadFromArgs(fi::HELICS.FederateInfo, argv::Array{#s45,1} where #s45<:AbstractString)\n\n\nLoad a FederateInfo from command line arguments\n\nArguments\n\nfi: a FederateInfo object\nargc: the number of command line arguments\nargv: an array of strings from the command line\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetBroker-Tuple{HELICS.FederateInfo,String}","page":"API","title":"HELICS.helicsFederateInfoSetBroker","text":"helicsFederateInfoSetBroker(fi::HELICS.FederateInfo, broker::String)\n\n\nSet the name or connection information for a broker\n\nthis is only used if the core is automatically created, the Broker information will be transferred to the core for connection\n\nArguments\n\nfi: the FederateInfo object to alter\nbroker: a string which defined the connection information for a broker either a name or an address\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetBrokerInitString-Tuple{HELICS.FederateInfo,String}","page":"API","title":"HELICS.helicsFederateInfoSetBrokerInitString","text":"helicsFederateInfoSetBrokerInitString(fi::HELICS.FederateInfo, brokerInit::String)\n\n\nSet the initialization string that a core will pass to a generated broker usually in the form of command line arguments\n\nArguments\n\nfi: The Federate info object to alter\nbrokerInit: A string with command line arguments for a generated broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetBrokerKey-Tuple{HELICS.FederateInfo,String}","page":"API","title":"HELICS.helicsFederateInfoSetBrokerKey","text":"helicsFederateInfoSetBrokerKey(fi::HELICS.FederateInfo, brokerKey::String)\n\n\nSet the key for a broker connection\n\nthis is only used if the core is automatically created, the Broker information will be transferred to the core for connection\n\nArguments\n\nfi: The Federate info object to alter\nbrokerkey: A string containing a key for the Broker to connect\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetBrokerPort-Tuple{HELICS.FederateInfo,Int64}","page":"API","title":"HELICS.helicsFederateInfoSetBrokerPort","text":"helicsFederateInfoSetBrokerPort(fi::HELICS.FederateInfo, brokerPort::Int64)\n\n\nSet the port to use for the Broker\n\nthis is only used if the core is automatically created, the Broker information will be transferred to the core for connection this will only be useful for network broker connections\n\nArguments\n\nfi: the FederateInfo object to alter\nbrokerPort: the integer port number to use for connection with a broker\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetCoreInitString-Tuple{HELICS.FederateInfo,String}","page":"API","title":"HELICS.helicsFederateInfoSetCoreInitString","text":"helicsFederateInfoSetCoreInitString(fi::HELICS.FederateInfo, coreInit::String)\n\n\nSet the initialization string for the core usually in the form of command line arguments\n\nArguments\n\nfi: the FederateInfo object to alter\ncoreInit: a string with the core initialization strings\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetCoreName-Tuple{HELICS.FederateInfo,String}","page":"API","title":"HELICS.helicsFederateInfoSetCoreName","text":"helicsFederateInfoSetCoreName(fi::HELICS.FederateInfo, corename::String)\n\n\nSet the name of the core to link to for a Federate\n\nArguments\n\nfi: the FederateInfo object to alter\ncorename: the identifier for a core to link to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetCoreType-Tuple{HELICS.FederateInfo,Union{Int64, HELICS.Lib.helics_core_type}}","page":"API","title":"HELICS.helicsFederateInfoSetCoreType","text":"helicsFederateInfoSetCoreType(fi::HELICS.FederateInfo, coretype::Union{Int64, HELICS.Lib.helics_core_type})\n\n\nSet the core type by integer code\n\nvalid values available by definitions in api-data.h\n\nArguments\n\nfi: the FederateInfo object to alter\ncoretype: an numerical code for a core type see /ref helicscoretype\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetCoreTypeFromString-Tuple{HELICS.FederateInfo,String}","page":"API","title":"HELICS.helicsFederateInfoSetCoreTypeFromString","text":"helicsFederateInfoSetCoreTypeFromString(fi::HELICS.FederateInfo, coretype::String)\n\n\nSet the core type from a string\n\nArguments\n\nfi: the FederateInfo object to alter\ncoretype: a string naming a core type\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetFlagOption-Tuple{HELICS.FederateInfo,Union{Int64, HELICS.Lib.helics_federate_flags},Bool}","page":"API","title":"HELICS.helicsFederateInfoSetFlagOption","text":"helicsFederateInfoSetFlagOption(fi::HELICS.FederateInfo, flag::Union{Int64, HELICS.Lib.helics_federate_flags}, value::Bool)\n\n\nSet a flag in the info structure\n\nvalid flags are available HELICS_FEDERATE_FLAGS\n\nArguments\n\nfi: the FederateInfo object to alter\nflag: a numerical index for a flag\nvalue: the desired value of the flag true or false\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetIntegerProperty-Tuple{HELICS.FederateInfo,Union{Int64, HELICS.Lib.helics_properties},Int64}","page":"API","title":"HELICS.helicsFederateInfoSetIntegerProperty","text":"helicsFederateInfoSetIntegerProperty(fi::HELICS.FederateInfo, intProperty::Union{Int64, HELICS.Lib.helics_properties}, propertyValue::Int64)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetLocalPort-Tuple{HELICS.FederateInfo,Int64}","page":"API","title":"HELICS.helicsFederateInfoSetLocalPort","text":"helicsFederateInfoSetLocalPort(fi::HELICS.FederateInfo, localPort::Int64)\n\n\nSet the local port to use\n\nthis is only used if the core is automatically created, the port information will be transferred to the core for connection\n\nArguments\n\nfi: the FederateInfo object to alter\nlocalPort: a string with the port information to use as the local server port can be a number or \"auto\" or \"os_local\"\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetSeparator-Tuple{HELICS.FederateInfo,Char}","page":"API","title":"HELICS.helicsFederateInfoSetSeparator","text":"helicsFederateInfoSetSeparator(fi::HELICS.FederateInfo, separator::Char)\n\n\nSet the separator character in the info structure\n\nthe separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName\n\nArguments\n\nfi: the FederateInfo object to alter\nseparator: the character to use as a separator\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateInfoSetTimeProperty-Tuple{HELICS.FederateInfo,Union{Int64, HELICS.Lib.helics_properties},Union{Float64, Int64}}","page":"API","title":"HELICS.helicsFederateInfoSetTimeProperty","text":"helicsFederateInfoSetTimeProperty(fi::HELICS.FederateInfo, timeProperty::Union{Int64, HELICS.Lib.helics_properties}, propertyValue::Union{Float64, Int64})\n\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateIsAsyncOperationCompleted-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateIsAsyncOperationCompleted","text":"helicsFederateIsAsyncOperationCompleted(fed::HELICS.Federate) -> Bool\n\n\nCheck if the current Asynchronous operation has completed\n\nArguments\n\nfed: the Federate to operate on\n\nReturns\n\nfalse if not completed, true if completed\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateIsValid-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateIsValid","text":"helicsFederateIsValid(fed::HELICS.Federate) -> Bool\n\n\nCheck if a Federate_object is valid\n\nReturns\n\ntrue if the Federate is a valid active federate, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateLocalError-Tuple{HELICS.Federate,Integer,String}","page":"API","title":"HELICS.helicsFederateLocalError","text":"helicsFederateLocalError(fed::HELICS.Federate, error_code::Integer, error_string::String)\n\n\nGenerate a local error in a Federate\n\nThis will propagate through the co-simulation but not necessarily halt the co-simulation, it has a similar effect to finalize but does allow some interaction with a core for a brief time.\n\nArguments\n\nfed: the Federate to create an error in\nerror_code: the integer code for the error\nerror_string: a string describing the error\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateLogDebugMessage-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateLogDebugMessage","text":"helicsFederateLogDebugMessage(fed::HELICS.Federate, logmessage::String)\n\n\nLog a message through a Federate\n\nArguments\n\nfed: The Federate to set the global through\nlogmessage: The message to put in the log\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateLogErrorMessage-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateLogErrorMessage","text":"helicsFederateLogErrorMessage(fed::HELICS.Federate, logmessage::String)\n\n\nLog an error message through a Federate\n\nArguments\n\nfed: The Federate to set the global through\nlogmessage: The message to put in the log\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateLogInfoMessage-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateLogInfoMessage","text":"helicsFederateLogInfoMessage(fed::HELICS.Federate, logmessage::String)\n\n\nLog a message through a Federate\n\nArguments\n\nfed: The Federate to set the global through\nlogmessage: The message to put in the log\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateLogLevelMessage-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_log_levels},String}","page":"API","title":"HELICS.helicsFederateLogLevelMessage","text":"helicsFederateLogLevelMessage(fed::HELICS.Federate, loglevel::Union{Int64, HELICS.Lib.helics_log_levels}, logmessage::String)\n\n\nLog a message through a Federate\n\nArguments\n\nfed: The Federate to set the global through\nloglevel: The level of the message to log. See HELICS_LOG_LEVELS\nlogmessage: The message to put in the log\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateLogWarningMessage-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateLogWarningMessage","text":"helicsFederateLogWarningMessage(fed::HELICS.Federate, logmessage::String)\n\n\nLog a warning message through a Federate\n\nArguments\n\nfed: The Federate to set the global through\nlogmessage: The message to put in the log\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederatePendingMessages-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederatePendingMessages","text":"helicsFederatePendingMessages(fed::HELICS.Federate) -> Int64\n\n\nReturns the number of pending receives for the specified destination endpoint.\n\nArguments\n\nfed: The Federate to get the number of waiting messages\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederatePublishJSON-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederatePublishJSON","text":"helicsFederatePublishJSON(fed::HELICS.Federate, json::String)\n\n\nPublish data contained in a json file or string\n\nArguments\n\nfed: The Federate\njson: json file or string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterCloningFilter-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateRegisterCloningFilter","text":"helicsFederateRegisterCloningFilter(fed::HELICS.Federate, name::String) -> HELICS.Filter\n\n\nCreate a cloning Filter on the specified federate\n\nCloning filters copy a message and send it to multiple locations source and destination can be added through other functions\n\nArguments\n\nfed: the fed to register through\nname: the name of the Filter (can be NULL)\n\nReturns\n\na Filter object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterEndpoint-Tuple{HELICS.Federate,String,String}","page":"API","title":"HELICS.helicsFederateRegisterEndpoint","text":"helicsFederateRegisterEndpoint(fed::HELICS.Federate, name::String, kind::String) -> HELICS.Endpoint\n\n\nCreate an Endpoint\n\nThe Endpoint becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for endpoints.\n\nArguments\n\nfed: the Federate in which to create an Endpoint must have been create with helicsCreateMessageFederate or helicsCreateCombinationFederate\nname: the identifier for the Endpoint,  this will be prepended with the Federate name for the global identifier\ntype: a string describing the expected type of the Publication may be NULL\n\nReturns\n\nEndpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterFilter-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_filter_type},String}","page":"API","title":"HELICS.helicsFederateRegisterFilter","text":"helicsFederateRegisterFilter(fed::HELICS.Federate, kind::Union{Int64, HELICS.Lib.helics_filter_type}, name::String) -> HELICS.Filter\n\n\nCreate a source Filter on the specified federate\n\nfilters can be created through a Federate or a core , linking through a federate allows a few extra features of name matching to function on the Federate interface but otherwise equivalent behavior\n\nArguments\n\nfed: the fed to register through\ntype: the type of filter to create HELICS_FILTER_TYPE\nname: the name of the Filter (can be NULL)\n\nReturns\n\na Filter object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterFromPublicationJSON-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateRegisterFromPublicationJSON","text":"helicsFederateRegisterFromPublicationJSON(fed::HELICS.Federate, json::String)\n\n\nRegister the Publications via  JSON publication string\n\nThis would be the same JSON that would be used to publish data\n\nArguments\n\nfed: the Federate\njson: json string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterGlobalCloningFilter-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateRegisterGlobalCloningFilter","text":"helicsFederateRegisterGlobalCloningFilter(fed::HELICS.Federate, name::String) -> HELICS.Filter\n\n\nCreate a global cloning Filter on the specified federate\n\nCloning filters copy a message and send it to multiple locations source and destination can be added through other functions\n\nArguments\n\nfed: the fed to register through\nname: the name of the Filter (can be NULL)\n\nReturns\n\na Filter object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterGlobalEndpoint-Tuple{HELICS.Federate,String,String}","page":"API","title":"HELICS.helicsFederateRegisterGlobalEndpoint","text":"helicsFederateRegisterGlobalEndpoint(fed::HELICS.Federate, name::String, kind::String) -> HELICS.Endpoint\n\n\nCreate an Endpoint\n\nThe Endpoint becomes part of the Federate and is destroyed when the federate is freed so there are no separate free functions for endpoints\n\nArguments\n\nfed: the Federate in which to create an Endpoint must have been create with helicsCreateMessageFederate or helicsCreateCombinationFederate\nname: the identifier for the Endpoint, the given name is the global identifier\ntype: a string describing the expected type of the Publication may be NULL\n\nReturns\n\nEndpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterGlobalFilter-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_filter_type},String}","page":"API","title":"HELICS.helicsFederateRegisterGlobalFilter","text":"helicsFederateRegisterGlobalFilter(fed::HELICS.Federate, kind::Union{Int64, HELICS.Lib.helics_filter_type}, name::String) -> HELICS.Filter\n\n\nCreate a global source filter through a Federate\n\nFilters can be created through a Federate or a core , linking through a federate allows a few extra features of name matching to function on the Federate interface but otherwise equivalent behavior\n\nArguments\n\nfed: the fed to register through\ntype: the type of filter to create HELICS_FILTER_TYPE\nname: the name of the Filter (can be NULL)\n\nReturns\n\na Filter object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterGlobalInput","page":"API","title":"HELICS.helicsFederateRegisterGlobalInput","text":"helicsFederateRegisterGlobalInput(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}) -> HELICS.Subscription\nhelicsFederateRegisterGlobalInput(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}, units::String) -> HELICS.Subscription\n\n\nRegister a global named input\n\nThe Publication becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nArguments\n\nfed: the Federate in which to create a Publication\nkey: the identifier for the Publication\ntype: a code identifying the type of the Input see HELICS_DATA_TYPE for available options\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterGlobalPublication","page":"API","title":"HELICS.helicsFederateRegisterGlobalPublication","text":"helicsFederateRegisterGlobalPublication(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}) -> HELICS.Publication\nhelicsFederateRegisterGlobalPublication(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}, units::String) -> HELICS.Publication\n\n\nRegister a global named publication with an arbitrary type\n\nArguments\n\nThe Publication becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nArguments\n\nfed: the Federate in which to create a Publication\nkey: the identifier for the Publication\ntype: a code identifying the type of the Input see HELICS_DATA_TYPE for available options\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterGlobalTypeInput","page":"API","title":"HELICS.helicsFederateRegisterGlobalTypeInput","text":"helicsFederateRegisterGlobalTypeInput(fed::HELICS.Federate, key::String, kind::String) -> HELICS.Subscription\nhelicsFederateRegisterGlobalTypeInput(fed::HELICS.Federate, key::String, kind::String, units::String) -> HELICS.Subscription\n\n\nRegister a global publication with an arbitrary type\n\nThe Publication becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nArguments\n\nfed: the Federate in which to create a Publication\nkey: the identifier for the Publication\ntype: a string defining the type of the Input\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterGlobalTypePublication","page":"API","title":"HELICS.helicsFederateRegisterGlobalTypePublication","text":"helicsFederateRegisterGlobalTypePublication(fed::HELICS.Federate, key::String, kind::String) -> HELICS.Publication\nhelicsFederateRegisterGlobalTypePublication(fed::HELICS.Federate, key::String, kind::String, units::String) -> HELICS.Publication\n\n\nRegister a global publication with a defined type\n\nArguments\n\nThe Publication becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nfed: the Federate in which to create a Publication\nkey: the identifier for the Publication\ntype: a string describing the expected type of the Publication\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterInput","page":"API","title":"HELICS.helicsFederateRegisterInput","text":"helicsFederateRegisterInput(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}) -> HELICS.Subscription\nhelicsFederateRegisterInput(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}, units::String) -> HELICS.Subscription\n\n\nRegister a named input\n\nThe Input becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions, inputs, and publications\n\nArguments\n\nfed: the Federate in which to create an Input\nkey: the identifier for the Publication the global input key will be prepended with the Federate name\ntype: a code identifying the type of the Input see HELICS_DATA_TYPE for available options\nunits: a string listing the units of the Input maybe NULL\n\nReturns\n\nthe Input\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterInterfaces-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateRegisterInterfaces","text":"helicsFederateRegisterInterfaces(fed::HELICS.Federate, file::String)\n\n\nLoad interfaces from a file\n\nArguments\n\nfed: the Federate to which to load interfaces\nfile: the name of a file to load the interfaces from either JSON, or TOML\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRegisterPublication","page":"API","title":"HELICS.helicsFederateRegisterPublication","text":"helicsFederateRegisterPublication(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}) -> HELICS.Publication\nhelicsFederateRegisterPublication(fed::HELICS.Federate, key::String, kind::Union{Int64, HELICS.Lib.helics_data_type}, units::String) -> HELICS.Publication\n\n\nRegister a Publication with a known type\n\nThe Publication becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nArguments\n\nfed: the Federate in which to create a Publication\nkey: the identifier for the Publication the global publication key will be prepended with the Federate name\ntype: a code identifying the type of the Input see HELICS_DATA_TYPE for available options\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterSubscription","page":"API","title":"HELICS.helicsFederateRegisterSubscription","text":"helicsFederateRegisterSubscription(fed::HELICS.Federate, key::String) -> HELICS.Subscription\nhelicsFederateRegisterSubscription(fed::HELICS.Federate, key::String, units::String) -> HELICS.Subscription\n\n\nCreate a Subscription\n\nThe Subscription becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nArguments\n\nfed: the Federate in which to create a Subscription must have been create with helicsCreateValueFederate or helicsCreateCombinationFederate\nkey: the identifier matching a Publication to get a Subscription for\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Subscription\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterTypeInput","page":"API","title":"HELICS.helicsFederateRegisterTypeInput","text":"helicsFederateRegisterTypeInput(fed::HELICS.Federate, key::String, kind::String) -> HELICS.Subscription\nhelicsFederateRegisterTypeInput(fed::HELICS.Federate, key::String, kind::String, units::String) -> HELICS.Subscription\n\n\nRegister an Input with a defined type\n\nThe Input becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions, inputs and publications\n\nArguments\n\nfed: the Federate in which to create an Input\nkey: the identifier for the Input\ntype: a string describing the expected type of the Input\nunits: a string listing the units of the Input maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRegisterTypePublication","page":"API","title":"HELICS.helicsFederateRegisterTypePublication","text":"helicsFederateRegisterTypePublication(fed::HELICS.Federate, key::String, kind::String) -> HELICS.Publication\nhelicsFederateRegisterTypePublication(fed::HELICS.Federate, key::String, kind::String, units::String) -> HELICS.Publication\n\n\nRegister a Publication with a defined type\n\nThe Publication becomes part of the Federate and is destroyed when the Federate is freed so there are no separate free functions for subscriptions and publications\n\nArguments\n\nfed: the Federate in which to create a Publication\nkey: the identifier for the Publication\ntype: a string labeling the type of the Publication\nunits: a string listing the units of the Subscription maybe NULL\n\nReturns\n\nthe Publication\n\n\n\n\n\n","category":"function"},{"location":"api/#HELICS.helicsFederateRequestNextStep-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateRequestNextStep","text":"helicsFederateRequestNextStep(fed::HELICS.Federate) -> Float64\n\n\nRequest the next time step for federate execution\n\nfeds should have setup the period or minDelta for this to work well but it will request the next time step which is the current time plus the minimum time step.\n\nArguments\n\nfed: the Federate to make the request of\n\nReturns\n\nthe time granted to the Federate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTime-Tuple{HELICS.Federate,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsFederateRequestTime","text":"helicsFederateRequestTime(fed::HELICS.Federate, requestTime::Union{Float64, Int64}) -> Float64\n\n\nRequest the next time for federate execution\n\nArguments\n\nfed: the Federate to make the request of\nrequestTime: the next requested time\n\nReturns\n\nthe time granted to the Federate   invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTimeAdvance-Tuple{HELICS.Federate,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsFederateRequestTimeAdvance","text":"helicsFederateRequestTimeAdvance(fed::HELICS.Federate, timeDelta::Union{Float64, Int64}) -> Float64\n\n\nrequest the next time for federate execution\n\nArguments\n\nfed: The Federate to make the request of\ntimeDelta: The requested amount of time to advance\n\nReturns\n\nthe time granted to the Federate, will return maximum time if the simulation has terminated invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTimeAsync-Tuple{HELICS.Federate,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsFederateRequestTimeAsync","text":"helicsFederateRequestTimeAsync(fed::HELICS.Federate, requestTime::Union{Float64, Int64})\n\n\nRequest the next time for federate execution in an asynchronous call Call helicsFederateRequestTimeComplete to finish the call\n\nArguments\n\nfed: the Federate to make the request of\nrequestTime: the next requested time\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTimeComplete-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateRequestTimeComplete","text":"helicsFederateRequestTimeComplete(fed::HELICS.Federate) -> Float64\n\n\nComplete an asynchronous requestTime call\n\nArguments\n\nfed: the Federate to make the request of\n\nReturns\n\nthe time granted to the Federate\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTimeIterative-Tuple{HELICS.Federate,Union{Float64, Int64},Union{Int64, HELICS.Lib.helics_iteration_request}}","page":"API","title":"HELICS.helicsFederateRequestTimeIterative","text":"helicsFederateRequestTimeIterative(fed::HELICS.Federate, requestTime::Union{Float64, Int64}, iterate::Union{Int64, HELICS.Lib.helics_iteration_request}) -> Tuple{Float64,HELICS.Lib.helics_iteration_result}\n\n\nRequest an iterative time\n\nthis call allows for finer grain control of the iterative process then helicsFederateRequestTime it takes a time and iteration request and return a time and iteration status.\n\nArguments\n\nfed: the Federate to make the request of\nrequestTime: the next desired time\niterate: the requested iteration mode\n\nReturns\n\nthe granted time\nthe iteration specification of the result\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTimeIterativeAsync-Tuple{HELICS.Federate,Union{Float64, Int64},Union{Int64, HELICS.Lib.helics_iteration_request}}","page":"API","title":"HELICS.helicsFederateRequestTimeIterativeAsync","text":"helicsFederateRequestTimeIterativeAsync(fed::HELICS.Federate, requestTime::Union{Float64, Int64}, iterate::Union{Int64, HELICS.Lib.helics_iteration_request})\n\n\nRequest an iterative time through an asynchronous call\n\nthis call allows for finer grain control of the iterative process then helicsFederateRequestTime it takes a time an iteration request and returns a time and iteration status call helicsFederateRequestTimeIterativeComplete to finish the process.\n\nArguments\n\nfed: the Federate to make the request of\nrequestTime: the next desired time\niterate: the requested iteration mode\n\nReturns\n\na void object with a return code of the result\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateRequestTimeIterativeComplete-Tuple{HELICS.Federate}","page":"API","title":"HELICS.helicsFederateRequestTimeIterativeComplete","text":"helicsFederateRequestTimeIterativeComplete(fed::HELICS.Federate)\n\n\nComplete an iterative time request asynchronous call\n\nArguments\n\nfed: the Federate to make the request of\n\nReturns\n\nthe granted time\noutIterate  the iteration specification of the result\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetFlagOption-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_federate_flags, HELICS.Lib.helics_handle_options},Bool}","page":"API","title":"HELICS.helicsFederateSetFlagOption","text":"helicsFederateSetFlagOption(fed::HELICS.Federate, flag::Union{Int64, HELICS.Lib.helics_federate_flags, HELICS.Lib.helics_handle_options}, flagValue::Bool)\n\n\nSet a flag for the Federate\n\nArguments\n\nfed: the Federate to alter a flag for\nflag: the flag to change\nflagValue: the new value of the flag 0 for false !=0 for true\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetGlobal-Tuple{HELICS.Federate,String,String}","page":"API","title":"HELICS.helicsFederateSetGlobal","text":"helicsFederateSetGlobal(fed::HELICS.Federate, valueName::String, value::String)\n\n\nSet a federation global value through a Federate\n\nthis overwrites any previous value for this name\n\nArguments\n\nfed: the Federate to set the global through\nvalueName: the name of the global to set\nvalue: the value of the global\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetIntegerProperty-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_properties},Int64}","page":"API","title":"HELICS.helicsFederateSetIntegerProperty","text":"helicsFederateSetIntegerProperty(fed::HELICS.Federate, intProperty::Union{Int64, HELICS.Lib.helics_properties}, propertyVal::Int64)\n\n\nSet an integer based property of a Federate\n\nArguments\n\nfed: the Federate to change the property for\nintProperty: the property to set\npropertyVal: the value of the property\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetLogFile-Tuple{HELICS.Federate,String}","page":"API","title":"HELICS.helicsFederateSetLogFile","text":"helicsFederateSetLogFile(fed::HELICS.Federate, logFile::String)\n\n\nSet the logging file for a Federate (actually on the core associated with a federate)\n\nArguments\n\nfed: the Federate to set the log file for\nlogFile: the name of the log file\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetLoggingCallback-Tuple{HELICS.Federate,Ptr{Nothing},Any}","page":"API","title":"HELICS.helicsFederateSetLoggingCallback","text":"helicsFederateSetLoggingCallback(fed::HELICS.Federate, logger::Ptr{Nothing}, userdata::Any)\n\n\nSet the logging callback for a Federate\n\nAdd a logging callback function for the C The logging callback will be called when a message flows into a Federate from the core or from a federate\n\nArguments\n\nfed: the Federate in which to create a Subscription must have been create with helicsCreateValueFederate or helicsCreateCombinationFederate\nlogger: a callback with signature void(int, const char *, const char *, void *); the function arguments are loglevel, an identifier string, and a message string, and a pointer to user data\nuserdata: a point to user data that is passed to the function when executing\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetSeparator-Tuple{HELICS.Federate,Char}","page":"API","title":"HELICS.helicsFederateSetSeparator","text":"helicsFederateSetSeparator(fed::HELICS.Federate, separator::Char)\n\n\nSet the separator character in a Federate\n\nThe separator character is the separation character for local publications/endpoints in creating their global name. for example if the separator character is '/'  then a local endpoint would have a globally reachable name of fedName/localName.\n\nArguments\n\nfed: the Federate object to alter\nseparator: the character to use as a separator\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFederateSetTimeProperty-Tuple{HELICS.Federate,Union{Int64, HELICS.Lib.helics_properties},Union{Float64, Int64}}","page":"API","title":"HELICS.helicsFederateSetTimeProperty","text":"helicsFederateSetTimeProperty(fed::HELICS.Federate, timeProperty::Union{Int64, HELICS.Lib.helics_properties}, time::Union{Float64, Int64})\n\n\nSet a time based property for a Federate\n\nArguments\n\nfed: the Federate set the property for\ntimeProperty: a integer code for a time property\ntime: the requested value of the property\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterAddDeliveryEndpoint-Tuple{HELICS.Filter,String}","page":"API","title":"HELICS.helicsFilterAddDeliveryEndpoint","text":"helicsFilterAddDeliveryEndpoint(filt::HELICS.Filter, deliveryEndpoint::String)\n\n\nAdd a delivery endpoint to a cloning filter\n\nAll cloned messages are sent to the delivery address(es)\n\nArguments\n\nfilt: the given Filter\ndeliveryEndpoint: the name of the Endpoint to deliver messages to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterAddDestinationTarget-Tuple{HELICS.Filter,String}","page":"API","title":"HELICS.helicsFilterAddDestinationTarget","text":"helicsFilterAddDestinationTarget(filt::HELICS.Filter, dest::String)\n\n\nAdd a destination target to a Filter\n\nAll messages going to a destination are copied to the delivery address(es)\n\nArguments\n\nfilt: the given Filter to add a destination target\ndest: the name of the Endpoint to add as a destination target\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterAddSourceTarget-Tuple{HELICS.Filter,String}","page":"API","title":"HELICS.helicsFilterAddSourceTarget","text":"helicsFilterAddSourceTarget(filt::HELICS.Filter, source::String)\n\n\nAdd a source target to a Filter\n\nAll messages coming from a source are copied to the delivery address(es)\n\nfilt: the given Filter\nsource: the name of the Endpoint to add as a source target\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterGetInfo-Tuple{HELICS.Filter}","page":"API","title":"HELICS.helicsFilterGetInfo","text":"helicsFilterGetInfo(filt::HELICS.Filter) -> String\n\n\nGet the data in the info field of an filter\n\nArguments\n\nfilt: the given Filter\n\nReturns\n\na string with the info field string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterGetName-Tuple{HELICS.Filter}","page":"API","title":"HELICS.helicsFilterGetName","text":"helicsFilterGetName(filt::HELICS.Filter) -> String\n\n\nGet the name of the Filter and store in the given string\n\nArguments\n\nfilt: the given Filter\n\nReturns\n\na string with the name of the Filter\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterGetOption-Tuple{HELICS.Filter,Union{Int64, HELICS.Lib.helics_handle_options}}","page":"API","title":"HELICS.helicsFilterGetOption","text":"helicsFilterGetOption(filt::HELICS.Filter, option::Union{Int64, HELICS.Lib.helics_handle_options}) -> Bool\n\n\nGet a handle option for the Filter\n\nArguments\n\nfilt: the given Filter to query\noption: the option to query HELICS_HANDLE_OPTIONS\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterRemoveDeliveryEndpoint-Tuple{HELICS.Filter,String}","page":"API","title":"HELICS.helicsFilterRemoveDeliveryEndpoint","text":"helicsFilterRemoveDeliveryEndpoint(filt::HELICS.Filter, deliveryEndpoint::String)\n\n\nRemove a delivery destination from a cloning filter\n\nArguments\n\nfilt: the given Filter (must be a cloning filter)\ndeliveryEndpoint: a string with the deliverEndpoint to remove\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterRemoveTarget-Tuple{HELICS.Filter,String}","page":"API","title":"HELICS.helicsFilterRemoveTarget","text":"helicsFilterRemoveTarget(filt::HELICS.Filter, target::String)\n\n\nRemove a destination target from a Filter\n\nfilt: the given Filter\ntarget: the named endpoint to remove as a target\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterSet-Tuple{HELICS.Filter,String,Float64}","page":"API","title":"HELICS.helicsFilterSet","text":"helicsFilterSet(filt::HELICS.Filter, prop::String, val::Float64)\n\n\nSet a property on a Filter\n\nArguments\n\nfilt: the Filter to modify\nprop: a string containing the property to set\nval: a numerical value of the property\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterSetInfo-Tuple{HELICS.Filter,String}","page":"API","title":"HELICS.helicsFilterSetInfo","text":"helicsFilterSetInfo(filt::HELICS.Filter, info::String)\n\n\nSet the data in the info field for an filter\n\nArguments\n\nfilt: the given Filter\ninfo: the string to set\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterSetOption-Tuple{HELICS.Filter,Union{Int64, HELICS.Lib.helics_handle_options},Bool}","page":"API","title":"HELICS.helicsFilterSetOption","text":"helicsFilterSetOption(filt::HELICS.Filter, option::Union{Int64, HELICS.Lib.helics_handle_options}, value::Bool)\n\n\nSet the data in the info field for an filter\n\nArguments\n\nfilt: the given Filter\noption: the option to set HELICS_HANDLE_OPTIONS\nvalue: the value of the option (helicstrue or helicsfalse)\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsFilterSetString-Tuple{HELICS.Filter,String,String}","page":"API","title":"HELICS.helicsFilterSetString","text":"helicsFilterSetString(filt::HELICS.Filter, prop::String, val::String)\n\n\nSet a string property on a Filter\n\nArguments\n\nfilt: the Filter to modify\nprop: a string containing the property to set\nval: a string containing the new value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsGetFederateByName-Tuple{String}","page":"API","title":"HELICS.helicsGetFederateByName","text":"helicsGetFederateByName(fedName::String) -> HELICS.CombinationFederate\n\n\nGet an existing Federate from a core by name\n\nthe Federate must have been created by one of the other functions and at least one of the objects referencing the created     federate must still be active in the process\n\nArguments\n\nfedName: the name of the Federate to retrieve\n\nReturns\n\nNULL if no fed is available by that name otherwise a Federate with that name\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsGetOptionIndex-Tuple{String}","page":"API","title":"HELICS.helicsGetOptionIndex","text":"helicsGetOptionIndex(val::String) -> Int64\n\n\nGet an option index for use in helicsPublicationSetOption, helicsInputSetOption, helicsEndpointSetOption, helicsFilterSetOption, and the corresponding get functions\n\nArguments\n\nval: a string with the option name\n\nReturns\n\nan int with the option index (-1) if not a valid property\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsGetPropertyIndex-Tuple{String}","page":"API","title":"HELICS.helicsGetPropertyIndex","text":"helicsGetPropertyIndex(val::String) -> Int64\n\n\nGet a property index for use in helicsFederateInfoSetFlagOption, helicsFederateInfoSetTimeProperty, helicsFederateInfoSetIntegerProperty\n\nArguments\n\nval: a string with the property name\n\nReturns\n\nan int with the property code (-1) if not a valid property\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsGetVersion-Tuple{}","page":"API","title":"HELICS.helicsGetVersion","text":"helicsGetVersion() -> String\n\n\nGet a version string for HELICS\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputAddTarget-Tuple{HELICS.Subscription,String}","page":"API","title":"HELICS.helicsInputAddTarget","text":"helicsInputAddTarget(ipt::HELICS.Subscription, target::String)\n\n\nAdd a Publication to the list of data that an Input subscribes to\n\nArguments\n\nipt: the named input to modify\ntarget: the name of a Publication that an Input should subscribe to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputClearUpdate-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputClearUpdate","text":"helicsInputClearUpdate(ipt::HELICS.Subscription)\n\n\nClear the updated flag from an Input\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetBoolean-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetBoolean","text":"helicsInputGetBoolean(ipt::HELICS.Subscription) -> Bool\n\n\nGet a boolean value from a Subscription\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\na boolean value of current input value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetChar-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetChar","text":"helicsInputGetChar(ipt::HELICS.Subscription) -> Char\n\n\nGet a single character value from an Input\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\nthe resulting character value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetComplex-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetComplex","text":"helicsInputGetComplex(ipt::HELICS.Subscription) -> Complex{Float64}\n\n\nGet a pair of double forming a complex number from a Subscriptions\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\nComplexF64\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetComplexObject-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetComplexObject","text":"helicsInputGetComplexObject(ipt::HELICS.Subscription) -> Complex{Float64}\n\n\nGet a complex object from an Input object\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\nComplexF64\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetDouble-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetDouble","text":"helicsInputGetDouble(ipt::HELICS.Subscription) -> Float64\n\n\nGet a double value from a Subscription\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\nthe double value of the Input\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetExtractionUnits-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetExtractionUnits","text":"helicsInputGetExtractionUnits(ipt::HELICS.Subscription) -> String\n\n\nGet the units of an Input\n\nThe same as helicsInputGetUnits\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetInfo-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetInfo","text":"helicsInputGetInfo(inp::HELICS.Subscription) -> String\n\n\nGet the data in the info field of an Input\n\nArguments\n\ninp: the Input to query\n\nReturns\n\na string with the info field string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetInjectionUnits-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetInjectionUnits","text":"helicsInputGetInjectionUnits(ipt::HELICS.Subscription) -> String\n\n\nGet the units of the Publication that an Input is linked to\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetInteger-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetInteger","text":"helicsInputGetInteger(ipt::HELICS.Subscription) -> Int64\n\n\nGet an integer value from a Subscription\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\nan int64_t value with the current value of the Input\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetKey-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetKey","text":"helicsInputGetKey(ipt::HELICS.Subscription) -> String\n\n\nGet the key of an Input\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetNamedPoint-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetNamedPoint","text":"helicsInputGetNamedPoint(ipt::HELICS.Subscription) -> Tuple{String,Float64}\n\n\nGet a named point from a Subscription\n\nArguments\n\nipt: the Input to get the result for\n\nReturns\n\noutputString storage for copying a null terminated string\nval the double value for the named point\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetOption-Tuple{HELICS.Subscription,Union{Int64, HELICS.Lib.helics_handle_options}}","page":"API","title":"HELICS.helicsInputGetOption","text":"helicsInputGetOption(inp::HELICS.Subscription, option::Union{Int64, HELICS.Lib.helics_handle_options}) -> Bool\n\n\nGet the data in the info field of an Input\n\nArguments\n\ninp: the Input to query\noption: integer representation of the option in question see HELICS_HANDLE_OPTIONS\n\nReturns\n\na string with the info field string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetPublicationType-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetPublicationType","text":"helicsInputGetPublicationType(ipt::HELICS.Subscription) -> String\n\n\nGet the type of the publisher to an Input is sending\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na const char * with the type name\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetRawValue-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetRawValue","text":"helicsInputGetRawValue(ipt::HELICS.Subscription) -> String\n\n\nGet the raw data for the latest value of a Subscription\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetRawValueSize-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetRawValueSize","text":"helicsInputGetRawValueSize(ipt::HELICS.Subscription) -> Int64\n\n\nGet the size of the raw value for subscription\n\nReturns\n\nthe size of the raw data/string in bytes\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetString-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetString","text":"helicsInputGetString(ipt::HELICS.Subscription) -> String\n\n\nGet a string value from a Subscription\n\nArguments\n\nipt: the Input to get the data for\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetStringSize-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetStringSize","text":"helicsInputGetStringSize(ipt::HELICS.Subscription) -> Int64\n\n\nGet the size of a value for subscription assuming return as a string\n\nReturns\n\nthe size of the string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetTime-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetTime","text":"helicsInputGetTime(ipt::HELICS.Subscription) -> Float64\n\n\nGet a double value from a Subscription\n\nArguments\n\nipt: the Input to get the data for\n\nReturns\n\nthe resulting double value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetType-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetType","text":"helicsInputGetType(ipt::HELICS.Subscription) -> String\n\n\nGet the type of an Input\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetUnits-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetUnits","text":"helicsInputGetUnits(ipt::HELICS.Subscription) -> String\n\n\nGet the units of an Input\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetVector-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetVector","text":"helicsInputGetVector(ipt::HELICS.Subscription) -> Array{Float64,1}\n\n\nGet a vector from a Subscription\n\nArguments\n\nipt: the Input to get the result for\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputGetVectorSize-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputGetVectorSize","text":"helicsInputGetVectorSize(ipt::HELICS.Subscription) -> Int64\n\n\nGet the size of a value for subscription assuming return as an array of doubles\n\nReturns\n\nthe number of double in a return vector\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputIsUpdated-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputIsUpdated","text":"helicsInputIsUpdated(ipt::HELICS.Subscription) -> Bool\n\n\nCheck if a particular subscription was updated\n\nArguments\n\nipt: the Input to query\n\nReturns\n\ntrue if it has been updated since the last value retrieval\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputLastUpdateTime-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsInputLastUpdateTime","text":"helicsInputLastUpdateTime(ipt::HELICS.Subscription) -> Float64\n\n\nGet the last time a Subscription was updated\n\nArguments\n\nipt: the Input to query\n\nReturns\n\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultBoolean-Tuple{HELICS.Subscription,Bool}","page":"API","title":"HELICS.helicsInputSetDefaultBoolean","text":"helicsInputSetDefaultBoolean(ipt::HELICS.Subscription, val::Bool)\n\n\nSet the default as a boolean\n\nArguments\n\nipt: the Input to set the default for\nval: the default boolean value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultChar-Tuple{HELICS.Subscription,Char}","page":"API","title":"HELICS.helicsInputSetDefaultChar","text":"helicsInputSetDefaultChar(ipt::HELICS.Subscription, val::Char)\n\n\nSet the default as a double\n\nArguments\n\nipt: the Input to set the default for\nval: the default double value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultComplex-Tuple{HELICS.Subscription,Complex{Float64}}","page":"API","title":"HELICS.helicsInputSetDefaultComplex","text":"helicsInputSetDefaultComplex(ipt::HELICS.Subscription, c::Complex{Float64})\n\n\nSet the default as a complex number\n\nArguments\n\nipt: the Input to set the default for\nc: the default ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultDouble-Tuple{HELICS.Subscription,Float64}","page":"API","title":"HELICS.helicsInputSetDefaultDouble","text":"helicsInputSetDefaultDouble(ipt::HELICS.Subscription, val::Float64)\n\n\nSet the default as a double\n\nArguments\n\nipt: the Input to set the default for\nval: the default double value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultInteger-Tuple{HELICS.Subscription,Int64}","page":"API","title":"HELICS.helicsInputSetDefaultInteger","text":"helicsInputSetDefaultInteger(ipt::HELICS.Subscription, val::Int64)\n\n\nSet the default as an integer\n\nArguments\n\nipt: the Input to set the default for\nval: the default integer\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultNamedPoint-Tuple{HELICS.Subscription,String,Float64}","page":"API","title":"HELICS.helicsInputSetDefaultNamedPoint","text":"helicsInputSetDefaultNamedPoint(ipt::HELICS.Subscription, str::String, val::Float64)\n\n\nSet the default as a NamedPoint\n\nArguments\n\nipt: the Input to set the default for\nstr: a pointer to a string representing the name\nval: a double value for the value of the named point\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultRaw-Tuple{HELICS.Subscription,Any}","page":"API","title":"HELICS.helicsInputSetDefaultRaw","text":"helicsInputSetDefaultRaw(ipt::HELICS.Subscription, data::Any)\n\n\nSet the default as a raw data array\n\nArguments\n\nipt: the Input to set the default for\ndata: a pointer to the raw data to use for the default\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultString-Tuple{HELICS.Subscription,String}","page":"API","title":"HELICS.helicsInputSetDefaultString","text":"helicsInputSetDefaultString(ipt::HELICS.Subscription, str::String)\n\n\nSet the default as a string\n\nArguments\n\nipt: the Input to set the default for\nstr: a pointer to the default string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultTime-Tuple{HELICS.Subscription,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsInputSetDefaultTime","text":"helicsInputSetDefaultTime(ipt::HELICS.Subscription, val::Union{Float64, Int64})\n\n\nSet the default as a double\n\nArguments\n\nipt: the Input to set the default for\nval: the default double value\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetDefaultVector-Tuple{HELICS.Subscription,Array{Float64,1}}","page":"API","title":"HELICS.helicsInputSetDefaultVector","text":"helicsInputSetDefaultVector(ipt::HELICS.Subscription, vectorInput::Array{Float64,1})\n\n\nSet the default as a vector of doubles\n\nArguments\n\nipt: the Input to set the default for\nvectorInput: an array of double data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetInfo-Tuple{HELICS.Subscription,String}","page":"API","title":"HELICS.helicsInputSetInfo","text":"helicsInputSetInfo(inp::HELICS.Subscription, info::String)\n\n\nSet the data in the info field for an Input\n\nArguments\n\ninp: the Input to query\ninfo: the string to set\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetMinimumChange-Tuple{HELICS.Subscription,Float64}","page":"API","title":"HELICS.helicsInputSetMinimumChange","text":"helicsInputSetMinimumChange(inp::HELICS.Subscription, tolerance::Float64)\n\n\nSet the minimum change detection tolerance\n\nArguments\n\ninp: the Input to modify\ntolerance: the tolerance level for registering an update, values changing less than this value will not show as being updated\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsInputSetOption-Tuple{HELICS.Subscription,Union{Int64, HELICS.Lib.helics_handle_options},Bool}","page":"API","title":"HELICS.helicsInputSetOption","text":"helicsInputSetOption(inp::HELICS.Subscription, option::Union{Int64, HELICS.Lib.helics_handle_options}, value::Bool)\n\n\nSet the data in the info field for an Input\n\nArguments\n\ninp: the Input to query\noption: the option to set for the Input HELICS_HANDLE_OPTIONS\nvalue: the value to set the option to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsIsCoreTypeAvailable-Tuple{String}","page":"API","title":"HELICS.helicsIsCoreTypeAvailable","text":"helicsIsCoreTypeAvailable(kind::String) -> Bool\n\n\nReturns true if core/broker type specified is available in current compilation.\n\nArguments\n\ntype: a string representing a core type\n\nReturns\n\na Bool\n\npossible options include \"test\",\"zmq\",\"udp\",\"ipc\",\"interprocess\",\"tcp\",\"default\", \"mpi\"\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageAppendData-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageAppendData","text":"helicsMessageAppendData(message::HELICS.Message, data::String)\n\n\nAppend data to the payload\n\nArguments\n\nmessage: The message object in question\ndata: A string containing the message data to append\ninputDataLength: The length of the data to input\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageCheckFlag-Tuple{HELICS.Message,Union{Int64, HELICS.Lib.helics_federate_flags}}","page":"API","title":"HELICS.helicsMessageCheckFlag","text":"helicsMessageCheckFlag(message::HELICS.Message, flag::Union{Int64, HELICS.Lib.helics_federate_flags}) -> Bool\n\n\nCheck if a flag is set on a message\n\nArguments\n\nmessage: The message object in question\nflag: The flag to check should be between [0,15]\n\nReturns\n\nthe flags associated with a message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageClearFlags-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageClearFlags","text":"helicsMessageClearFlags(message::HELICS.Message)\n\n\nClear the flags of a message\n\nArguments\n\nmessage: The message object in question\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetDestination-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetDestination","text":"helicsMessageGetDestination(message::HELICS.Message) -> String\n\n\nGet the destination endpoint of a message\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\na string with the destination endpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetMessageID-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetMessageID","text":"helicsMessageGetMessageID(message::HELICS.Message) -> Int64\n\n\nGet the messageID of a message\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\nthe messageID\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetOriginalDestination-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetOriginalDestination","text":"helicsMessageGetOriginalDestination(message::HELICS.Message) -> String\n\n\nGet the original destination endpoint of a message, the destination may have been modified by filters or other actions\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\na string with the original destination of a message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetOriginalSource-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetOriginalSource","text":"helicsMessageGetOriginalSource(message::HELICS.Message) -> String\n\n\nGet the original source endpoint of a message, the source may have modified by filters or other actions\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\na string with the source of a message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetRawData-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetRawData","text":"helicsMessageGetRawData(message::HELICS.Message) -> String\n\n\nGet the raw data for a message object\n\nmessage: A message object to get the data for\ndata: The memory location of the data\nmaxMessagelen: The maximum size of information that data can hold\nactualSize: The actual length of data copied to data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetRawDataPointer-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetRawDataPointer","text":"helicsMessageGetRawDataPointer(message::HELICS.Message) -> Ptr{Nothing}\n\n\nGet a pointer to the raw data of a message\n\nArguments\n\nmessage: A message object to get the data for\n\nReturns\n\na pointer to the raw data in memory, the\n\npointer may be NULL if the message is not a valid message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetRawDataSize-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetRawDataSize","text":"helicsMessageGetRawDataSize(message::HELICS.Message) -> Int64\n\n\nGet the size of the data payload in bytes\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\nthe size of the data payload\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetSource-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetSource","text":"helicsMessageGetSource(message::HELICS.Message) -> String\n\n\nGet the source endpoint of a message\n\n message operation functions\n\nfunctions for working with helics message envelopes\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\na string with the source endpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetString-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetString","text":"helicsMessageGetString(message::HELICS.Message) -> String\n\n\nGet the payload of a message as a string\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\na string representing the payload of a message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageGetTime-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageGetTime","text":"helicsMessageGetTime(message::HELICS.Message) -> Float64\n\n\nGet the helics time associated with a message\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\nthe time associated with a message\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageIsValid-Tuple{HELICS.Message}","page":"API","title":"HELICS.helicsMessageIsValid","text":"helicsMessageIsValid(message::HELICS.Message) -> Bool\n\n\nA check if the message contains a valid payload\n\nArguments\n\nmessage: The message object in question\n\nReturns\n\ntrue if the message contains a payload\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageReserve-Tuple{HELICS.Message,Int64}","page":"API","title":"HELICS.helicsMessageReserve","text":"helicsMessageReserve(message::HELICS.Message, reserveSize::Int64)\n\n\nReserve space in a buffer but don't actually resize\n\nthe message data buffer will be reserved but not resized\n\nArguments\n\nmessage: The message object in question\nreserveSize: The number of bytes to reserve in the message object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageResize-Tuple{HELICS.Message,Int64}","page":"API","title":"HELICS.helicsMessageResize","text":"helicsMessageResize(message::HELICS.Message, newSize::Int64)\n\n\nResize the data buffer for a message\n\nthe message data buffer will be resized there is no guarantees on what is in the buffer in newly allocated space if the allocated space is not sufficient new allocations will occur\n\nArguments\n\nmessage: The message object in question\nnewSize: The new size in bytes of the buffer\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetData-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageSetData","text":"helicsMessageSetData(message::HELICS.Message, data::String)\n\n\nSet the data payload of a message as raw data\n\nArguments\n\nmessage: The message object in question\ndata: A string containing the message data\ninputDataLength: The length of the data to input\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetDestination-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageSetDestination","text":"helicsMessageSetDestination(message::HELICS.Message, dest::String)\n\n\nSet the destination of a message\n\nArguments\n\nmessage: The message object in question\ndest: A string containing the new destination\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetFlagOption-Tuple{HELICS.Message,Union{Int64, HELICS.Lib.helics_federate_flags},Bool}","page":"API","title":"HELICS.helicsMessageSetFlagOption","text":"helicsMessageSetFlagOption(message::HELICS.Message, flag::Union{Int64, HELICS.Lib.helics_federate_flags}, flagValue::Bool)\n\n\nSet a flag on a message\n\nArguments\n\nmessage: The message object in question\nflag: An index of a flag to set on the message\nflagValue: The desired value of the flag\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetMessageID-Tuple{HELICS.Message,Int32}","page":"API","title":"HELICS.helicsMessageSetMessageID","text":"helicsMessageSetMessageID(message::HELICS.Message, messageID::Int32)\n\n\nSet the message ID for the message\n\nnormally this is not needed and the core of HELICS will adjust as needed\n\nArguments\n\nmessage: The message object in question\nmessageID: A new message ID\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetOriginalDestination-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageSetOriginalDestination","text":"helicsMessageSetOriginalDestination(message::HELICS.Message, dest::String)\n\n\nSet the original destination of a message\n\nArguments\n\nmessage: The message object in question\ndest: A string containing the new original source\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetOriginalSource-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageSetOriginalSource","text":"helicsMessageSetOriginalSource(message::HELICS.Message, src::String)\n\n\nSet the original source of a message\n\nArguments\n\nmessage: The message object in question\nsrc: A string containing the new original source\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetSource-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageSetSource","text":"helicsMessageSetSource(message::HELICS.Message, src::String)\n\n\nSet the source of a message\n\nArguments\n\nmessage: The message object in question\nsrc: A string containing the source\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetString-Tuple{HELICS.Message,String}","page":"API","title":"HELICS.helicsMessageSetString","text":"helicsMessageSetString(message::HELICS.Message, str::String)\n\n\nSet the data payload of a message as a string\n\nArguments\n\nmessage: The message object in question\nstr: A string containing the message data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsMessageSetTime-Tuple{HELICS.Message,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsMessageSetTime","text":"helicsMessageSetTime(message::HELICS.Message, time::Union{Float64, Int64})\n\n\nSet the delivery time for a message\n\nArguments\n\nmessage: The message object in question\ntime: The time the message should be delivered\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationAddTarget-Tuple{HELICS.Publication,String}","page":"API","title":"HELICS.helicsPublicationAddTarget","text":"helicsPublicationAddTarget(pub::HELICS.Publication, target::String)\n\n\nAdd a named input to the list of targets a Publication publishes to\n\nArguments\n\npub: the Publication to add the target for\ntarget: the name of an Input that the data should be sent to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationGetInfo-Tuple{HELICS.Publication}","page":"API","title":"HELICS.helicsPublicationGetInfo","text":"helicsPublicationGetInfo(pub::HELICS.Publication) -> String\n\n\nGet the data in the info field of an publication\n\nArguments\n\npub: the Publication to query\n\nReturns\n\na string with the info field string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationGetKey-Tuple{HELICS.Publication}","page":"API","title":"HELICS.helicsPublicationGetKey","text":"helicsPublicationGetKey(pub::HELICS.Publication) -> String\n\n\nGet the key of a Publication\n\nthis will be the global key used to identify the Publication to the federation\n\nArguments\n\npub: the Publication to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationGetOption-Tuple{HELICS.Publication,Union{Int64, HELICS.Lib.helics_handle_options}}","page":"API","title":"HELICS.helicsPublicationGetOption","text":"helicsPublicationGetOption(pub::HELICS.Publication, option::Union{Int64, HELICS.Lib.helics_handle_options}) -> Bool\n\n\nGet the data in the info field of an publication\n\nArguments\n\npub: the Publication to query\noption: the value to query see HELICS_HANDLE_OPTIONS\n\nArguments\n\na string with the info field string\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationGetType-Tuple{HELICS.Publication}","page":"API","title":"HELICS.helicsPublicationGetType","text":"helicsPublicationGetType(pub::HELICS.Publication) -> String\n\n\nGet the type of a Publication\n\nArguments\n\npub: the Publication to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationGetUnits-Tuple{HELICS.Publication}","page":"API","title":"HELICS.helicsPublicationGetUnits","text":"helicsPublicationGetUnits(pub::HELICS.Publication) -> String\n\n\nGet the units of the Publication that an Input is linked to\n\nArguments\n\nipt: the Input to query\n\nReturns\n\na void enumeration, helics_ok if everything worked\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishBoolean-Tuple{HELICS.Publication,Bool}","page":"API","title":"HELICS.helicsPublicationPublishBoolean","text":"helicsPublicationPublishBoolean(pub::HELICS.Publication, val::Bool)\n\n\nPublish a Boolean Value\n\nArguments\n\npub: the Publication to publish for\nval: the boolean value to publish either true or false\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishChar-Tuple{HELICS.Publication,Char}","page":"API","title":"HELICS.helicsPublicationPublishChar","text":"helicsPublicationPublishChar(pub::HELICS.Publication, val::Char)\n\n\nPublish a single character\n\nArguments\n\npub: the Publication to publish for\nval: the numerical value to publish\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishComplex-Tuple{HELICS.Publication,Complex{Float64}}","page":"API","title":"HELICS.helicsPublicationPublishComplex","text":"helicsPublicationPublishComplex(pub::HELICS.Publication, c::Complex{Float64})\n\n\nPublish a complex value (or pair of values)\n\nArguments\n\npub: the Publication to publish for\nc: the complex number to publish\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishDouble-Tuple{HELICS.Publication,Float64}","page":"API","title":"HELICS.helicsPublicationPublishDouble","text":"helicsPublicationPublishDouble(pub::HELICS.Publication, val::Float64)\n\n\nPublish a double floating point value\n\nArguments\n\npub the Publication to publish for\nval the numerical value to publish\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishInteger-Tuple{HELICS.Publication,Int64}","page":"API","title":"HELICS.helicsPublicationPublishInteger","text":"helicsPublicationPublishInteger(pub::HELICS.Publication, val::Int64)\n\n\nPublish an integer value\n\nArguments\n\npub: the Publication to publish for\nval: the numerical value to publish\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishNamedPoint-Tuple{HELICS.Publication,String,Float64}","page":"API","title":"HELICS.helicsPublicationPublishNamedPoint","text":"helicsPublicationPublishNamedPoint(pub::HELICS.Publication, str::String, val::Float64)\n\n\nPublish a named point\n\nArguments\n\npub: the Publication to publish for\nstr: a String\nval: a Float64 to publish\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishRaw-Tuple{HELICS.Publication,String}","page":"API","title":"HELICS.helicsPublicationPublishRaw","text":"helicsPublicationPublishRaw(pub::HELICS.Publication, data::String)\n\n\nPublish raw data from bytes\n\nArguments\n\npub: the Publication to publish for\ndata: the raw data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishString-Tuple{HELICS.Publication,String}","page":"API","title":"HELICS.helicsPublicationPublishString","text":"helicsPublicationPublishString(pub::HELICS.Publication, str::String)\n\n\nPublish a string\n\nArguments\n\npub: the Publication to publish for\nstr: String\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishTime-Tuple{HELICS.Publication,Union{Float64, Int64}}","page":"API","title":"HELICS.helicsPublicationPublishTime","text":"helicsPublicationPublishTime(pub::HELICS.Publication, val::Union{Float64, Int64})\n\n\nPublish a time value\n\nArguments\n\npub: the Publication to publish for\nval: the numerical value to publish\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationPublishVector-Tuple{HELICS.Publication,Array{Float64,1}}","page":"API","title":"HELICS.helicsPublicationPublishVector","text":"helicsPublicationPublishVector(pub::HELICS.Publication, vectorInput::Array{Float64,1})\n\n\npublish a vector of doubles\n\nArguments\n\npub: the Publication to publish for\nvectorInput: Vector of Float64 data\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationSetInfo-Tuple{HELICS.Publication,String}","page":"API","title":"HELICS.helicsPublicationSetInfo","text":"helicsPublicationSetInfo(pub::HELICS.Publication, info::String)\n\n\nSet the data in the info field for an publication\n\nArguments\n\npub: the Publication to set the info field for\ninfo: the string to set\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationSetMinimumChange-Tuple{HELICS.Publication,Float64}","page":"API","title":"HELICS.helicsPublicationSetMinimumChange","text":"helicsPublicationSetMinimumChange(pub::HELICS.Publication, tolerance::Float64)\n\n\nSet the minimum change detection tolerance\n\nArguments\n\npub: the Publication to modify\ntolerance: the tolerance level for the Publication, values changing less than this value will not be published\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsPublicationSetOption-Tuple{HELICS.Publication,Union{Int64, HELICS.Lib.helics_handle_options},Bool}","page":"API","title":"HELICS.helicsPublicationSetOption","text":"helicsPublicationSetOption(pub::HELICS.Publication, option::Union{Int64, HELICS.Lib.helics_handle_options}, val::Bool)\n\n\nSet the data in the info field for an publication\n\nArguments\n\npub: the Publication to query\noption: integer code for the option to set HELICS_HANDLE_OPTIONS\nval: the value to set the option to\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryBrokerExecute-Tuple{HELICS.Query,HELICS.Broker}","page":"API","title":"HELICS.helicsQueryBrokerExecute","text":"helicsQueryBrokerExecute(query::HELICS.Query, broker::HELICS.Broker) -> String\n\n\nExecute a Query directly on a broker\n\nthe call will block until the Query finishes which may require communication or other delays\n\nArguments\n\nquery: the Query to use in the query\nbroker: the Broker to send the Query to\n\nReturns\n\na string. String will remain valid until the Query is freed or executed again\n\nthe return will be nullptr if fed or Query is an invalid object, the return string will be \"#invalid\" if the Query itself was invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryCoreExecute-Tuple{HELICS.Query,HELICS.Core}","page":"API","title":"HELICS.helicsQueryCoreExecute","text":"helicsQueryCoreExecute(query::HELICS.Query, core::HELICS.Core) -> String\n\n\nExecute a Query directly on a core\n\nthe call will block until the Query finishes which may require communication or other delays\n\nArguments\n\nquery: the Query to use in the query\ncore: the core to send the Query to\n\nReturns\n\na string. String will remain valid until the Query is freed or executed again\n\nthe return will be nullptr if fed or Query is an invalid object, the return string will be \"#invalid\" if the Query itself was invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryExecute-Tuple{HELICS.Query,HELICS.Federate}","page":"API","title":"HELICS.helicsQueryExecute","text":"helicsQueryExecute(query::HELICS.Query, fed::HELICS.Federate) -> String\n\n\nExecute a query\n\nthe call will block until the Query finishes which may require communication or other delays\n\nArguments\n\nquery: the Query to use in the query\nfed: a Federate to send the Query through\n\nReturns\n\na string. String will remain valid until the Query is freed or executed again\n\nthe return will be nullptr if fed or Query is an invalid object, the return string will be \"#invalid\" if the Query itself was invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryExecuteAsync-Tuple{HELICS.Query,HELICS.Federate}","page":"API","title":"HELICS.helicsQueryExecuteAsync","text":"helicsQueryExecuteAsync(query::HELICS.Query, fed::HELICS.Federate)\n\n\nExecute a Query in a non-blocking call\n\nArguments\n\nquery: the Query to use in the query\nfed: a Federate to send the Query through\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryExecuteComplete-Tuple{HELICS.Query}","page":"API","title":"HELICS.helicsQueryExecuteComplete","text":"helicsQueryExecuteComplete(query::HELICS.Query) -> String\n\n\nComplete the return from a Query called with helicsQueryExecuteAsync\n\nthe function will block until the Query completes helicsQueryIsCompleted can be called to determine if a Query has completed or not.\n\nArguments\n\nquery: the Query to complete execution of\n\nReturns\n\na string. String will remain valid until the Query is freed or executed again\n\nthe return will be nullptr if Query is an invalid object\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryFree-Tuple{HELICS.Query}","page":"API","title":"HELICS.helicsQueryFree","text":"helicsQueryFree(query::HELICS.Query)\n\n\nFree the memory associated with a Query\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsQueryIsCompleted-Tuple{HELICS.Query}","page":"API","title":"HELICS.helicsQueryIsCompleted","text":"helicsQueryIsCompleted(query::HELICS.Query) -> Bool\n\n\nCheck if an asynchronously executed Query has completed\n\nthis function should usually be called after a QueryExecuteAsync function has been called.\n\nArguments\n\nquery: the Query to check if completed\n\nReturns\n\nwill return true if an asynchronous Query has complete or a regular Query call was made with a result and false if an asynchronous Query has not completed or is invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#HELICS.helicsSubscriptionGetKey-Tuple{HELICS.Subscription}","page":"API","title":"HELICS.helicsSubscriptionGetKey","text":"helicsSubscriptionGetKey(ipt::HELICS.Subscription) -> String\n\n\nGet the key of a Subscription\n\nReturns\n\na const char with the Subscription key\n\n\n\n\n\n","category":"method"},{"location":"api/#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [HELICS]\nFilter = t -> typeof(t) === DataType && !(t <: HELICS.Lib.CEnum.Cenum)","category":"page"},{"location":"api/#HELICS.Broker","page":"API","title":"HELICS.Broker","text":"Summary\n\nstruct HELICS.Broker <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.CWrapper","page":"API","title":"HELICS.CWrapper","text":"Summary\n\nabstract type HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.CombinationFederate","page":"API","title":"HELICS.CombinationFederate","text":"Summary\n\nstruct HELICS.CombinationFederate <: HELICS.Federate\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Core","page":"API","title":"HELICS.Core","text":"Summary\n\nstruct HELICS.Core <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Endpoint","page":"API","title":"HELICS.Endpoint","text":"Summary\n\nstruct HELICS.Endpoint <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Federate","page":"API","title":"HELICS.Federate","text":"Summary\n\nabstract type HELICS.Federate <: HELICS.CWrapper\n\nSubtypes\n\nHELICS.CombinationFederate\nHELICS.MessageFederate\nHELICS.ValueFederate\n\nSupertype Hierarchy\n\nHELICS.Federate <: HELICS.CWrapper <: Any\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.FederateInfo","page":"API","title":"HELICS.FederateInfo","text":"Summary\n\nstruct HELICS.FederateInfo <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Filter","page":"API","title":"HELICS.Filter","text":"Summary\n\nstruct HELICS.Filter <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Message","page":"API","title":"HELICS.Message","text":"Summary\n\nstruct HELICS.Message <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.MessageFederate","page":"API","title":"HELICS.MessageFederate","text":"Summary\n\nstruct HELICS.MessageFederate <: HELICS.Federate\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Publication","page":"API","title":"HELICS.Publication","text":"Summary\n\nstruct HELICS.Publication <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Query","page":"API","title":"HELICS.Query","text":"Summary\n\nstruct HELICS.Query <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.Subscription","page":"API","title":"HELICS.Subscription","text":"Summary\n\nstruct HELICS.Subscription <: HELICS.CWrapper\n\n\n\n\n\n","category":"type"},{"location":"api/#HELICS.ValueFederate","page":"API","title":"HELICS.ValueFederate","text":"Summary\n\nstruct HELICS.ValueFederate <: HELICS.Federate\n\n\n\n\n\n","category":"type"},{"location":"api/#Index-1","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"#HELICS.jl-1","page":"Home","title":"HELICS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: CI) (Image: Docs) (Image: Codecov) (Image: Coverage Status) (Image: Gitter) (Image: Releases)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"HELICS.jl is a cross-platform Julia wrapper around the HELICS library.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package is now available for Windows, Mac, and Linux.","category":"page"},{"location":"#Documentation-1","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The documentation for the development latest of this package is here.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Use the Julia package manager to install HELICS.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ]\n(v1.1)> add HELICS","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Open the package manager REPL (using ])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install the latest development version, use the following from within Julia:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> add HELICS#master","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package includes HELICS as a library. You do not have to install HELICS separately.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that this should work on 64-bit Windows, Mac and Linux systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you wish to develop HELICS.jl you may want to use the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> dev HELICS","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can also get a specific version,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> add HELICS#33c98625","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or specific branch,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> add HELICS#kd/some-new-feature","category":"page"},{"location":"#","page":"Home","title":"Home","text":"if these features haven't been merged to master yet.","category":"page"},{"location":"#Troubleshooting-1","page":"Home","title":"Troubleshooting","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package interfaces with HELICS, so a good understanding of HELICS will help troubleshooting. There are plenty of useful resources located here.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you are having issues using this Julia interface, feel free to open an issue on GitHub here.","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This work was initially developed as an extension to work done as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL).","category":"page"},{"location":"#Release-1","page":"Home","title":"Release","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"HELICS.jl is distributed under the terms of the BSD-3 clause license. All new contributions must be made under this license. LICENSE","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SPDX-License-Identifier: BSD-3-Clause","category":"page"},{"location":"terminology/#Terminology-1","page":"Terminology","title":"Terminology","text":"","category":"section"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"Illustration of a simple federation consisting of two federates.","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"    +--------------------+               +--------------------+\n    |                    |               |                    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |    Federate - 1    |               |    Federate - 2    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |                    |               |                    |\n    |       +-----------------+     +-----------------+       |\n    |       |                 |     |                 |       |\n    |       |                 |     |                 |       |\n    |       | helicsSharedLib |     | helicsSharedLib |       |\n    |       |                 |     |                 |       |\n    |       |                 |     |                 |       |\n    |       +---------------x-+     +-x---------------+       |\n    |                    |  ^         ^  |                    |\n    +--------------------+  |         |  +--------------------+\n                            |         |\n                            v         v\n                         +--x---------x--+\n                         |               |\n                         |               |\n                         | helics-broker |\n                         |               |\n                         |               |\n                         +---------------+","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"A federation, also called a co-simulation consists of multiple federates, or components, agents or actors. These federates exchange data at given points in time. HELICS manages time in a distributed fashion based on how the federation is configured during initialization. If you have a Julia program, and you wish to exchange data with another HELICS federate, you can create a Federate by calling the HELICS.helicsCreateCombinationFederate function. This federate must be provided with some information in order to set it up correctly. A FederateInfo object must be first created in order to set up a Federate. This FederateInfo object contains information about what type of communication core is used in HELICS (e.g. zmq, mpi, tcp, udp), the name of the Federate, where the Broker is located, etc. All Federates must connect to a Broker. A Broker is a separate process that can run on the same machine or a remote machine. You can start a Broker by running HELICS.helicsCreateBroker, or running helics_broker -f ${NUMBER_OF_FEDERATES} from the command line. Both creating a FederateInfo and Broker object can take some initialization options in the form of a initstring. See the examples folder for more information.","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"After creating a Federate, you will want to create Publications and Subscriptions. The strings you choose for these publications and subscriptions must be unique, and they act like topics in a federation. You can send data in the form of values from a Publication to a Subscription. Additionally, you can register Endpoints as well, which allow you to send Messages. Messages can be filtered on by any Federate and can be used to model complex communication interactions.","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"You can use functions like HELICS.helicsPublicationPublishDouble to send values at the \"current time\", and use functions like HELICS.helicsSubscriptionGetKey or HELICS.helicsInputGetDouble to receive values at the \"current time\". You can use functions like HELICS.helicsEndpointSendMessage to send messages at the \"current time\", and use functions like HELICS.helicsEndpointGetMessage functions to receive messages that arrived before the \"current time\".","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"You can request to move to a time by using the HELICS.helicsFederateRequestTime function. This function returns a time back that you can safely move to. The time granted will always be less than or equal to the requested time. If you wish to move to the requested time, you may use a while loop until that the granted time is equal to the requested time.","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"for t in 1:100\n\n    requested_time = t\n    while granted_time < requested_time\n        granted_time = helicsFederateRequestTime(requested_time)\n    end\n\n    # granted_time here will be equal to requested time\n    # Send or Receive data here\n\nend","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"HELICS.helicsFederateRequestTime is a blocking call. There are other asynchronous request time functions available that allow you to do work while you wait for others to move forward in simulation time.","category":"page"},{"location":"terminology/#","page":"Terminology","title":"Terminology","text":"helicsSharedLib is a shared library that is included in the Julia package. This C/C++ shared library interfaces with the broker in other to communicate with other federates.","category":"page"}]
}
